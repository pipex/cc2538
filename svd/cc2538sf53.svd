<!-- Created by tixml2svd; https://github.com/dhoove/tixml2svd -->
<?xml version="1.0" encoding="utf-8"?>
<device>
  <name>CC2652</name>
  <version>1.1</version>
  <description>CC2652</description>
  <cpu>
    <name>CM4</name>
    <revision>r1p0</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <nvicPrioBits>3</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <size>32</size>
  <access>read-write</access>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>SSI0</name>
      <baseAddress>0x40008000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00001000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>CR0</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>The CR0 register contains bit fields that control various functions within the SSI module. Functionality such as protocol mode, clock rate, and data size are configured in this register.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Reserved</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>SCR</name>
              <description>[15:8] SSI serial clock rate (R/W)
Reset value: 0x0
The value SCR is used to generate the transmit and receive bit rate of the SSI. Where the bit rate is:
BR = FSSICLK/(CPSDVR * (1 + SCR))
where CPSDVR is an even value from 2-254, programmed in
the SSICPSR register and SCR is a value from 0-255.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SPH</name>
              <description>[7:7] SSI serial clock phase (R/W)
Reset value: 0x0
This bit is only applicable to the Motorola SPI Format.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SPO</name>
              <description>[6:6] SSI serial clock phase (R/W)
Reset value: 0x0
This bit is only applicable to the Motorola SPI Format.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>FRF</name>
              <description>[5:4] SSI frame format select (R/W)
Reset value: 0x0
00: Motorola SPI frame format
01: TI synchronous serial frame format
10: National Microwire frame format
11: Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DSS</name>
              <description>[3:0] SSI data size select (R/W)
Reset value: 0x0
0000-0010: Reserved
0011: 4-bit data
0100: 5-bit data
0101: 6-bit data
0110: 7-bit data
0111: 8-bit data
1000: 9-bit data
1001: 10-bit data
1010: 11-bit data
1011: 12-bit data
1100: 13-bit data
1101: 14-bit data
1110: 15-bit data
1111: 16-bit data</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CR1</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>The CR1 register contains bit fields that control various functions within the SSI module. Master and slave mode functionality is controlled by this register.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Reserved</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved16</name>
              <description>[15:4] Reserved, read unpredictable, should be written as 0.
3 SOD</description>
              <bitWidth>12</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SOD</name>
              <description>[3:3] SSI slave mode output disable (R/W)
Reset value: 0x0
This bit is relevant only in the slave mode (MS = 1). In multiple-slave systems, it is possible for the SSI master to broadcast a message to all slaves in the system while ensuring that only one slave drives data onto the serial output line. In such systems, the RXD lines from multiple slaves could be tied together. To operate in such a system, the SOD bit can be set if the SSI slave is not suppose to drive the SSITXD line.
0: SSI can drive SSITXD in slave output mode
1: SSI must not drive the SSITXD output in slave mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MS</name>
              <description>[2:2] SSI master and slave select (R/W)
Reset value: 0x0
This bit can be modified only when the SSI is disabled (SSE = 0).
0: Device configured as a master (default)
1: Device configured as a slave</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SSE</name>
              <description>[1:1] SSI synchronous serial port enable (R/W)
Reset value: 0x0
0: SSI operation is disabled.
1: SSI operation is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>LBM</name>
              <description>[0:0] SSI loop-back mode (R/W)
Reset value: 0x0
0: Normal serial port operation is enabled.
1: The output of the transmit serial shifter is connected to the input of the receive serial shift register internally.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>The DR register is 16 bits wide. When the SSIDR register is read, the entry in the receive FIFO that is pointed to by the current FIFO read pointer is accessed. When a data value is removed by the SSI receive logic from the incoming data frame, it is placed into the entry in the receive FIFO pointed to by the current FIFO write pointer.

When the DR register is written to, the entry in the transmit FIFO that is pointed to by the write pointer is written to. Data values are removed from the transmit FIFO one value at a time by the transmit logic. Each data value is loaded into the transmit serial shifter, then serially shifted out onto the SSITx pin at the programmed bit rate.

When a data size of less than 16 bits is selected, the user must right-justify data written to the transmit FIFO. The transmit logic ignores the unused bits. Received data less than 16 bits is automatically right-justified in the receive buffer.

When the SSI is programmed for MICROWIRE frame format, the default size for transmit data is eight bits (the most significant byte is ignored). The receive data size is controlled by the programmer. The transmit FIFO and the receive FIFO are not cleared even when the SSE bit in the SSICR1 register is cleared, allowing the software to fill the transmit FIFO before enabling the SSI.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Reserved</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DATA</name>
              <description>[15:0] SSI receive/transmit data register (R/W)
Reset value: 0xXXXX
A read operation reads the receive FIFO. A write operation writes the transmit FIFO.
Software must right-justify data when the SSI is programmed
for a data size that is less than 16 bits. Unused bits at the top
are ignored by the transmit logic. The receive logic automatically right-justified the data.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SR</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>The SR register contains bits that indicate the FIFO fill status and the SSI busy status.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Reserved</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved16</name>
              <description>[15:5] Reserved, read unpredictable, should be written as 0.</description>
              <bitWidth>11</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>BSY</name>
              <description>[4:4] SSI busy bit (RO)
Reset value: 0x0
0: SSI is idle.
1: SSI is currently transmitting and/or receiving a frame or the
transmit FIFO is not empty.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RFF</name>
              <description>[3:3] SSI receive FIFO full (RO)
Reset value: 0x0
0: Receive FIFO is not full.
1: Receive FIFO is full.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RNE</name>
              <description>[2:2] SSI receive FIFO not empty (RO)
Reset value: 0x0
0: Receive FIFO is empty.
1: Receive FIFO is not empty.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TNF</name>
              <description>[1:1] SSI transmit FIFO not full (RO)
Reset value: 0x1
0: Transmit FIFO is full.
1: Transmit FIFO is not full.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TFE</name>
              <description>[0:0] SSI transmit FIFO empty (RO)
Reset value: 0x1
0: Transmit FIFO is not empty.
1: Transmit FIFO is empty.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CPSR</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>The CPSR register specifies the division factor which is used to derive the SSIClk from the system clock. The clock is further divided by a value from 1 to 256, which is 1 + SCR. SCR is programmed in the SSICR0 register. The frequency of the SSIClk is defined by:
SSIClk = SysClk / (CPSDVSR x (1 + SCR))
The value programmed into this register must be an even number between 2 and 254. The least-significant bit of the programmed number is hard-coded to zero. If an odd number is written to this register, data read back from this register has the least-significant bit as zero.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Reserved</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved16</name>
              <description>[15:8] Reserved, read unpredictable, should be written as 0.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CPSDVSR</name>
              <description>[7:0] SSI clock prescale divisor (R/W)
Reset value: 0x0
This value must be an even number from 2 to 254, depending on the frequency of SSICLK. The LSB always returns zero on reads.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IM</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>The IM register is the interrupt mask set or clear register. It is a read/write register and all bits are cleared on reset.

On a read, this register gives the current value of the mask on the corresponding interrupt. Setting a bit sets the mask, preventing the interrupt from being signaled to the interrupt controller. Clearing a bit clears the corresponding mask, enabling the interrupt to be sent to the interrupt controller.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:4] Reserved, read as zero, do not modify.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TXIM</name>
              <description>[3:3] SSI transmit FIFO interrupt mask (R/W)
Reset value: 0x0
0: TX FIFO half empty or condition interrupt is masked.
1: TX FIFO half empty or less condition interrupt is not masked.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RXIM</name>
              <description>[2:2] SSI receive FIFO interrupt mask (R/W)
Reset value: 0x0
0: RX FIFO half empty or condition interrupt is masked.
1: RX FIFO half empty or less condition interrupt is not masked.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RTIM</name>
              <description>[1:1] SSI receive time-out interrupt mask (R/W)
Reset value: 0x0
0: RX FIFO time-out interrupt is masked.
1: RX FIFO time-out interrupt is not masked</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RORIM</name>
              <description>[0:0] SSI receive overrun interrupt mask (R/W)
Reset value: 0x0
0: RX FIFO Overrun interrupt is masked.
1: RX FIFO Overrun interrupt is not masked</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>The RIS register is the raw interrupt status register. On a read, this register gives the current raw status value of the corresponding interrupt before masking. A write has no effect.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Reserved</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved11</name>
              <description>[15:4] Reserved, read as zero, do not modify.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TXRIS</name>
              <description>[3:3] SSI SSITXINTR raw state (RO)
Reset value: 0x1
Gives the raw interrupt state (before masking) of SSITXINTR</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RXRIS</name>
              <description>[2:2] SSI SSIRXINTR raw state (RO)
Reset value: 0x0
Gives the raw interrupt state (before masking) of SSIRXINTR</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RTRIS</name>
              <description>[1:1] SSI SSIRTINTR raw state (RO)
Reset value: 0x0
Gives the raw interrupt state (before masking) of SSIRTINTR</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RORRIS</name>
              <description>[0:0] SSI SSIRORINTR raw state (RO)
Reset value: 0x0
Gives the raw interrupt state (before masking) of SSIRORINTR</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>The MIS register is the masked interrupt status register. On a read, this register gives the current masked status value of the corresponding interrupt. A write has no effect.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Reserved</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved16</name>
              <description>[15:4] Reserved, read as zero, do not modify.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TXMIS</name>
              <description>[3:3] SSI SSITXINTR masked state (RO)
Reset value: 0x0
Gives the interrupt state (after masking) of SSITXINTR</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RXMIS</name>
              <description>[2:2] SSI SSIRXINTR masked state (RO)
Reset value: 0x0
Gives the interrupt state (after masking) of SSIRXINTR</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RTMIS</name>
              <description>[1:1] SSI SSIRTINTR masked state (RO)
Reset value: 0x0
Gives the interrupt state (after masking) of SSIRTINTR</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RORMIS</name>
              <description>[0:0] SSI SSIRORINTR masked state (RO)
Reset value: 0x0
Gives the interrupt state (after masking) of SSIRORINTR</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>The ICR register is the interrupt clear register. On a write of 1, the corresponding interrupt is cleared. A write of 0 has no effect.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Reserved</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved16</name>
              <description>[15:2] Reserved, read as zero, do not modify.</description>
              <bitWidth>14</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RTIC</name>
              <description>[1:1] SSI receive time-out interrupt clear (W1C)
Reset value: 0x0
0: No effect on interrupt
1: Clears interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RORIC</name>
              <description>[0:0] SSI receive overrun interrupt clear (W1C)
Reset value: 0x0
0: No effect on interrupt
1: Clears interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMACTL</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>The DMACTL register is the uDMA control register.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:2] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TXDMAE</name>
              <description>[1:1] Transmit DMA enable
0: uDMA for the transmit FIFO is disabled.
1: uDMA for the transmit FIFO is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RXDMAE</name>
              <description>[0:0] Receive DMA enable
0: uDMA for the receive FIFO is disabled.
1: uDMA for the receive FIFO is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC</name>
          <addressOffset>0xfc8</addressOffset>
          <size>32</size>
          <description>SSI clock configuration
The CC register controls the baud clock and system clocks sources for the SSI module.
Note: If the PIOSC is used for the SSI baud clock, the system clock frequency must be at least 16 MHz in run mode.</description>
          <fields>
            <field>
              <name>Reserved29</name>
              <description>[31:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CS</name>
              <description>[2:0] SSI baud and system clock source
The following bits determine the clock source that generates the baud and system clocks for the SSI.
bit0 (PIOSC): 
       1: The SSI baud clock is determined by the IO DIV setting in the system controller.
       0: The SSI baud clock is determined by the SYS DIV setting in the system controller.
bit1: Unused
bit2: (DSEN) Only meaningful when the system is in deep sleep mode. This bit is a don't care when not in sleep mode. 
       1: The SSI system clock is running on the same clock as the baud clock, as per PIOSC setting above.
       0: The SSI system clock is determined by the SYS DIV setting in the system controller.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SSI1</name>
      <baseAddress>0x40009000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00001000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>CR0</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>The CR0 register contains bit fields that control various functions within the SSI module. Functionality such as protocol mode, clock rate, and data size are configured in this register.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Reserved</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>SCR</name>
              <description>[15:8] SSI serial clock rate (R/W)
Reset value: 0x0
The value SCR is used to generate the transmit and receive bit rate of the SSI. Where the bit rate is:
BR = FSSICLK/(CPSDVR * (1 + SCR))
where CPSDVR is an even value from 2-254, programmed in
the SSICPSR register and SCR is a value from 0-255.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SPH</name>
              <description>[7:7] SSI serial clock phase (R/W)
Reset value: 0x0
This bit is only applicable to the Motorola SPI Format.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SPO</name>
              <description>[6:6] SSI serial clock phase (R/W)
Reset value: 0x0
This bit is only applicable to the Motorola SPI Format.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>FRF</name>
              <description>[5:4] SSI frame format select (R/W)
Reset value: 0x0
00: Motorola SPI frame format
01: TI synchronous serial frame format
10: National Microwire frame format
11: Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DSS</name>
              <description>[3:0] SSI data size select (R/W)
Reset value: 0x0
0000-0010: Reserved
0011: 4-bit data
0100: 5-bit data
0101: 6-bit data
0110: 7-bit data
0111: 8-bit data
1000: 9-bit data
1001: 10-bit data
1010: 11-bit data
1011: 12-bit data
1100: 13-bit data
1101: 14-bit data
1110: 15-bit data
1111: 16-bit data</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CR1</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>The CR1 register contains bit fields that control various functions within the SSI module. Master and slave mode functionality is controlled by this register.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Reserved</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved16</name>
              <description>[15:4] Reserved, read unpredictable, should be written as 0.
3 SOD</description>
              <bitWidth>12</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SOD</name>
              <description>[3:3] SSI slave mode output disable (R/W)
Reset value: 0x0
This bit is relevant only in the slave mode (MS = 1). In multiple-slave systems, it is possible for the SSI master to broadcast a message to all slaves in the system while ensuring that only one slave drives data onto the serial output line. In such systems, the RXD lines from multiple slaves could be tied together. To operate in such a system, the SOD bit can be set if the SSI slave is not suppose to drive the SSITXD line.
0: SSI can drive SSITXD in slave output mode
1: SSI must not drive the SSITXD output in slave mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MS</name>
              <description>[2:2] SSI master and slave select (R/W)
Reset value: 0x0
This bit can be modified only when the SSI is disabled (SSE = 0).
0: Device configured as a master (default)
1: Device configured as a slave</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SSE</name>
              <description>[1:1] SSI synchronous serial port enable (R/W)
Reset value: 0x0
0: SSI operation is disabled.
1: SSI operation is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>LBM</name>
              <description>[0:0] SSI loop-back mode (R/W)
Reset value: 0x0
0: Normal serial port operation is enabled.
1: The output of the transmit serial shifter is connected to the input of the receive serial shift register internally.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>The DR register is 16 bits wide. When the SSIDR register is read, the entry in the receive FIFO that is pointed to by the current FIFO read pointer is accessed. When a data value is removed by the SSI receive logic from the incoming data frame, it is placed into the entry in the receive FIFO pointed to by the current FIFO write pointer.

When the DR register is written to, the entry in the transmit FIFO that is pointed to by the write pointer is written to. Data values are removed from the transmit FIFO one value at a time by the transmit logic. Each data value is loaded into the transmit serial shifter, then serially shifted out onto the SSITx pin at the programmed bit rate.

When a data size of less than 16 bits is selected, the user must right-justify data written to the transmit FIFO. The transmit logic ignores the unused bits. Received data less than 16 bits is automatically right-justified in the receive buffer.

When the SSI is programmed for MICROWIRE frame format, the default size for transmit data is eight bits (the most significant byte is ignored). The receive data size is controlled by the programmer. The transmit FIFO and the receive FIFO are not cleared even when the SSE bit in the SSICR1 register is cleared, allowing the software to fill the transmit FIFO before enabling the SSI.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Reserved</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DATA</name>
              <description>[15:0] SSI receive/transmit data register (R/W)
Reset value: 0xXXXX
A read operation reads the receive FIFO. A write operation writes the transmit FIFO.
Software must right-justify data when the SSI is programmed
for a data size that is less than 16 bits. Unused bits at the top
are ignored by the transmit logic. The receive logic automatically right-justified the data.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SR</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>The SR register contains bits that indicate the FIFO fill status and the SSI busy status.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Reserved</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved16</name>
              <description>[15:5] Reserved, read unpredictable, should be written as 0.</description>
              <bitWidth>11</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>BSY</name>
              <description>[4:4] SSI busy bit (RO)
Reset value: 0x0
0: SSI is idle.
1: SSI is currently transmitting and/or receiving a frame or the
transmit FIFO is not empty.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RFF</name>
              <description>[3:3] SSI receive FIFO full (RO)
Reset value: 0x0
0: Receive FIFO is not full.
1: Receive FIFO is full.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RNE</name>
              <description>[2:2] SSI receive FIFO not empty (RO)
Reset value: 0x0
0: Receive FIFO is empty.
1: Receive FIFO is not empty.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TNF</name>
              <description>[1:1] SSI transmit FIFO not full (RO)
Reset value: 0x1
0: Transmit FIFO is full.
1: Transmit FIFO is not full.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TFE</name>
              <description>[0:0] SSI transmit FIFO empty (RO)
Reset value: 0x1
0: Transmit FIFO is not empty.
1: Transmit FIFO is empty.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CPSR</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>The CPSR register specifies the division factor which is used to derive the SSIClk from the system clock. The clock is further divided by a value from 1 to 256, which is 1 + SCR. SCR is programmed in the SSICR0 register. The frequency of the SSIClk is defined by:
SSIClk = SysClk / (CPSDVSR x (1 + SCR))
The value programmed into this register must be an even number between 2 and 254. The least-significant bit of the programmed number is hard-coded to zero. If an odd number is written to this register, data read back from this register has the least-significant bit as zero.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Reserved</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved16</name>
              <description>[15:8] Reserved, read unpredictable, should be written as 0.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CPSDVSR</name>
              <description>[7:0] SSI clock prescale divisor (R/W)
Reset value: 0x0
This value must be an even number from 2 to 254, depending on the frequency of SSICLK. The LSB always returns zero on reads.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IM</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>The IM register is the interrupt mask set or clear register. It is a read/write register and all bits are cleared on reset.

On a read, this register gives the current value of the mask on the corresponding interrupt. Setting a bit sets the mask, preventing the interrupt from being signaled to the interrupt controller. Clearing a bit clears the corresponding mask, enabling the interrupt to be sent to the interrupt controller.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:4] Reserved, read as zero, do not modify.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TXIM</name>
              <description>[3:3] SSI transmit FIFO interrupt mask (R/W)
Reset value: 0x0
0: TX FIFO half empty or condition interrupt is masked.
1: TX FIFO half empty or less condition interrupt is not masked.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RXIM</name>
              <description>[2:2] SSI receive FIFO interrupt mask (R/W)
Reset value: 0x0
0: RX FIFO half empty or condition interrupt is masked.
1: RX FIFO half empty or less condition interrupt is not masked.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RTIM</name>
              <description>[1:1] SSI receive time-out interrupt mask (R/W)
Reset value: 0x0
0: RX FIFO time-out interrupt is masked.
1: RX FIFO time-out interrupt is not masked</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RORIM</name>
              <description>[0:0] SSI receive overrun interrupt mask (R/W)
Reset value: 0x0
0: RX FIFO Overrun interrupt is masked.
1: RX FIFO Overrun interrupt is not masked</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>The RIS register is the raw interrupt status register. On a read, this register gives the current raw status value of the corresponding interrupt before masking. A write has no effect.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Reserved</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved11</name>
              <description>[15:4] Reserved, read as zero, do not modify.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TXRIS</name>
              <description>[3:3] SSI SSITXINTR raw state (RO)
Reset value: 0x1
Gives the raw interrupt state (before masking) of SSITXINTR</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RXRIS</name>
              <description>[2:2] SSI SSIRXINTR raw state (RO)
Reset value: 0x0
Gives the raw interrupt state (before masking) of SSIRXINTR</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RTRIS</name>
              <description>[1:1] SSI SSIRTINTR raw state (RO)
Reset value: 0x0
Gives the raw interrupt state (before masking) of SSIRTINTR</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RORRIS</name>
              <description>[0:0] SSI SSIRORINTR raw state (RO)
Reset value: 0x0
Gives the raw interrupt state (before masking) of SSIRORINTR</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>The MIS register is the masked interrupt status register. On a read, this register gives the current masked status value of the corresponding interrupt. A write has no effect.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Reserved</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved16</name>
              <description>[15:4] Reserved, read as zero, do not modify.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TXMIS</name>
              <description>[3:3] SSI SSITXINTR masked state (RO)
Reset value: 0x0
Gives the interrupt state (after masking) of SSITXINTR</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RXMIS</name>
              <description>[2:2] SSI SSIRXINTR masked state (RO)
Reset value: 0x0
Gives the interrupt state (after masking) of SSIRXINTR</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RTMIS</name>
              <description>[1:1] SSI SSIRTINTR masked state (RO)
Reset value: 0x0
Gives the interrupt state (after masking) of SSIRTINTR</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RORMIS</name>
              <description>[0:0] SSI SSIRORINTR masked state (RO)
Reset value: 0x0
Gives the interrupt state (after masking) of SSIRORINTR</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>The ICR register is the interrupt clear register. On a write of 1, the corresponding interrupt is cleared. A write of 0 has no effect.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Reserved</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved16</name>
              <description>[15:2] Reserved, read as zero, do not modify.</description>
              <bitWidth>14</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RTIC</name>
              <description>[1:1] SSI receive time-out interrupt clear (W1C)
Reset value: 0x0
0: No effect on interrupt
1: Clears interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RORIC</name>
              <description>[0:0] SSI receive overrun interrupt clear (W1C)
Reset value: 0x0
0: No effect on interrupt
1: Clears interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMACTL</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>The DMACTL register is the uDMA control register.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:2] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TXDMAE</name>
              <description>[1:1] Transmit DMA enable
0: uDMA for the transmit FIFO is disabled.
1: uDMA for the transmit FIFO is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RXDMAE</name>
              <description>[0:0] Receive DMA enable
0: uDMA for the receive FIFO is disabled.
1: uDMA for the receive FIFO is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC</name>
          <addressOffset>0xfc8</addressOffset>
          <size>32</size>
          <description>SSI clock configuration
The CC register controls the baud clock and system clocks sources for the SSI module.
Note: If the PIOSC is used for the SSI baud clock, the system clock frequency must be at least 16 MHz in run mode.</description>
          <fields>
            <field>
              <name>Reserved29</name>
              <description>[31:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CS</name>
              <description>[2:0] SSI baud and system clock source
The following bits determine the clock source that generates the baud and system clocks for the SSI.
bit0 (PIOSC): 
       1: The SSI baud clock is determined by the IO DIV setting in the system controller.
       0: The SSI baud clock is determined by the SYS DIV setting in the system controller.
bit1: Unused
bit2: (DSEN) Only meaningful when the system is in deep sleep mode. This bit is a don't care when not in sleep mode. 
       1: The SSI system clock is running on the same clock as the baud clock, as per PIOSC setting above.
       0: The SSI system clock is determined by the SYS DIV setting in the system controller.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART0</name>
      <baseAddress>0x4000C000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00001000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>DR</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>UART data
Important: This register is read-sensitive. See the register description for details.
This register is the data register (the interface to the FIFOs).
For transmitted data, if the FIFO is enabled, data written to this location is pushed onto the transmit FIFO. If the FIFO is disabled, data is stored in the transmitter holding register (the bottom word of the transmit FIFO). A write to this register initiates a transmission from the UART.
For received data, if the FIFO is enabled, the data byte and the 4-bit status (break, frame, parity, and overrun) is pushed onto the 12-bit wide receive FIFO. If the FIFO is disabled, the data byte and status are stored in the receiving holding register (the bottom word of the receive FIFO). The received data can be retrieved by reading this register.</description>
          <fields>
            <field>
              <name>Reserved20</name>
              <description>[31:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>OE</name>
              <description>[11:11] UART overrun error
1: New data was received when the FIFO was full, resulting in data loss.
0: No data has been lost due to a FIFO overrun.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>BE</name>
              <description>[10:10] UART break error
1: A break condition has been detected, indicating that the receive data input was held low for longer than a full-word transmission time (defined as start, data, parity, and stop bits).
0: No break condition has occurred.
In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only the one 0 character is loaded into the FIFO. The next character is only enabled after the received data input goes to a 1 (marking state), and the next valid start bit is received.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PE</name>
              <description>[9:9] UART parity error
1: The parity of the received data character does not match the parity defined by bits 2 and 7 of the UARTLCRH register
0: No parity error has occurred.
In FIFO mode, this error is associated with the character at the top of the FIFO.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>FE</name>
              <description>[8:8] UART framing error
1: The received character does not have a valid stop bit (a valid stop bit is 1).
0: No framing error has occurred.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DATA</name>
              <description>[7:0] Data transmitted or received
Data that is to be transmitted via the UART is written to this field.
When read, this field contains the data that was received by the UART.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RSR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>UART receive status and error clear
The RSR/ECR register is the receive status register and error clear register.
In addition to the DR register, receive status can also be read from the RSR register. If the status is read from this register, then the status information corresponds to the entry read from DR before reading RSR. The status information for overrun is set immediately when an overrun condition occurs.
The RSR register cannot be written.
Read-only status register</description>
          <fields>
            <field>
              <name>Reserved28</name>
              <description>[31:4] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>OE</name>
              <description>[3:3] UART overrun error
1: New data was received when the FIFO was full, resulting in data loss.
0: No data has been lost due to a FIFO overrun.
This bit is cleared by a write to UARTECR.
The FIFO contents remain valid because no further data is written when the FIFO is full, only the contents of the shift register are overwritten. The CPU must read the data in order to empty the FIFO.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>BE</name>
              <description>[2:2] UART break error
1: A break condition has been detected, indicating that the receive data input was held low for longer than a full-word transmission time (defined as start, data, parity, and stop bits).
0: No break condition has occurred.
This bit is cleared to 0 by a write to UARTECR.
In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PE</name>
              <description>[1:1] UART parity error
1: The parity of the received data character does not match the parity defined by bits 2 and 7 of the UARTLCRH register.
0: No parity error has occurred.
This bit is cleared to 0 by a write to UARTECR.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>FE</name>
              <description>[0:0] UART framing error
1: The received character does not have a valid stop bit (a valid stop bit is 1).
0: No framing error has occurred.
This bit is cleared to 0 by a write to UARTECR.
In FIFO mode, this error is associated with the character at the top of the FIFO.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ECR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>UART receive status and error clear
The RSR/ECR register is the receive status register/error clear register.
A write of any value to the ECR register clears the framing, parity, break, and overrun errors. All the bits are cleared on reset.
Write-only error clear register</description>
          <fields>
            <field>
              <name>Reserved24</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DATA</name>
              <description>[7:0] Error clear
A write to this register of any data clears the framing, parity, break, and overrun flags.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FR</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>UART flag
The FR register is the flag register. After reset, the TXFF, RXFF, and BUSY bits are 0, and TXFE and RXFE bits are 1. The CTS bit indicate the modem flow control. Note that the modem bits are only implemented on UART1 and are tied inactive on UART0. Due to this difference, the reset state of the UART0 FR register is 0x90, while UART1 FR register reset state 0x197 .</description>
          <fields>
            <field>
              <name>Reserved24</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TXFE</name>
              <description>[7:7] UART transmit FIFO empty
The meaning of this bit depends on the state of the FEN bit in the UARTLCRH register.
1: If the FIFO is disabled (FEN is 0), the transmit holding register is empty. If the FIFO is enabled (FEN is 1), the transmit FIFO is empty.
0: The transmitter has data to transmit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RXFF</name>
              <description>[6:6] UART receive FIFO full
The meaning of this bit depends on the state of the FEN bit in the UARTLCRH register.
1: If the FIFO is disabled (FEN is 0), the receive holding register is full. If the FIFO is enabled (FEN is 1), the receive FIFO is full.
0: The receiver can receive data.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TXFF</name>
              <description>[5:5] UART transmit FIFO full
The meaning of this bit depends on the state of the FEN bit in the UARTLCRH register.
1: If the FIFO is disabled (FEN is 0), the transmit holding register is full. If the FIFO is enabled (FEN is 1), the transmit FIFO is full.
0: The transmitter is not full.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RXFE</name>
              <description>[4:4] UART receive FIFO empty
The meaning of this bit depends on the state of the FEN bit in the UARTLCRH register.
1: If the FIFO is disabled (FEN is 0), the receive holding register is empty. If the FIFO is enabled (FEN is 1), the receive FIFO is empty.
0: The receiver is not empty.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>BUSY</name>
              <description>[3:3] UART busy
1: The UART is busy transmitting data. This bit remains set until the complete byte, including all stop bits, has been sent from the shift register.
0: The UART is not busy.
This bit is set as soon as the transmit FIFO becomes non-empty (regardless of whether UART is enabled).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>Reserved2</name>
              <description>[2:1] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CTS</name>
              <description>[0:0] Clear to send (UART1 only, reserved for UART0).
1: The U1CTS signal is asserted.
0: The U1CTS signal is not asserted.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ILPR</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>UART IrDA low-power register
The ILPR register stores the 8-bit low-power counter divisor value used to derive the low-power SIR pulse width clock by dividing down the system clock (SysClk). All the bits are cleared when reset.
The internal IrLPBaud16 clock is generated by dividing down SysClk according to the low-power divisor value written to ILPR. The duration of SIR pulses generated when low-power mode is enabled is three times the period of the IrLPBaud16 clock. The low-power divisor value is calculated as follows:
ILPDVSR = SysClk / FIrLPBaud16
where FIrLPBaud16 is nominally 1.8432 MHz
The divisor must be programmed such that FIrLPBaud16 is in the range 1.42 MHz to 2.12 MHz, resulting in a low-power pulse duration of 1.41-2.11 us (three times the period of IrLPBaud16). The minimum
frequency of IrLPBaud16 ensures that pulses less than one period of IrLPBaud16 are rejected, but pulses greater than 1.4 us are accepted as valid pulses.
Note: Zero is an illegal value. Programming a zero value results in no IrLPBaud16 pulses being generated.</description>
          <fields>
            <field>
              <name>Reserved24</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ILPDVSR</name>
              <description>[7:0] IrDA low-power divisor
This field contains the 8-bit low-power divisor value.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IBRD</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>UART integer baud-rate divisor
The IBRD register is the integer part of the baud-rate divisor value. All the bits are cleared on reset. The minimum possible divide ratio is 1 (when IBRD = 0), in which case the FBRD register is ignored. When changing the IBRD register, the new value does not take effect until transmission or reception of the current character is complete. Any changes to the baud-rate divisor must be followed by a write to the LCRH register.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DIVINT</name>
              <description>[15:0] Integer baud-rate divisor</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FBRD</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>UART fractional baud-rate divisor
The FBRD register is the fractional part of the baud-rate divisor value. All the bits are cleared on reset. When changing the FBRD register, the new value does not take effect until transmission or reception of the current character is complete. Any changes to the baud-rate divisor must be followed by a write to the LCRH register.</description>
          <fields>
            <field>
              <name>Reserved26</name>
              <description>[31:6] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DIVFRAC</name>
              <description>[5:0] Fractional baud-rate divisor</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LCRH</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>UART line control
The LCRH register is the line control register. Serial parameters such as data length, parity, and stop bit selection are implemented in this register.
When updating the baud-rate divisor (IBRD and/or IFRD), the LCRH register must also be written. The write strobe for the baud-rate divisor registers is tied to the LCRH register.</description>
          <fields>
            <field>
              <name>Reserved24</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SPS</name>
              <description>[7:7] UART stick parity select
When bits 1, 2, and 7 of UARTLCRH are set, the parity bit is transmitted and checked as a 0. When bits 1 and 7 are set and 2 is cleared, the parity bit is transmitted and checked as a 1.
When this bit is cleared, stick parity is disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>WLEN</name>
              <description>[6:5] UART word length
The bits indicate the number of data bits transmitted or received in a frame as follows:
0x0: 5 bits (default)
0x1: 6 bits
0x2: 7 bits
0x3: 8 bits</description>
              <bitWidth>2</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>FEN</name>
              <description>[4:4] UART enable FIFOs
1: The transmit and receive FIFObuffers are enabled (FIFOmode).
0: The FIFOs are disabled (Character mode). The FIFOs become 1-byte-deep holding registers.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>STP2</name>
              <description>[3:3] UART two stop bits select
1: Two stop bits are transmitted at the end of a frame. The receive logic does not check for two stop bits being received. 
0: One stop bit is transmitted at the end of a frame.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>EPS</name>
              <description>[2:2] UART even parity select
1: Even parity generation and checking is performed during transmission and reception, which checks for an even number of 1s in data and parity bits.
0: Odd parity is performed, which checks for an odd number of 1s.
This bit has no effect when parity is disabled by the PEN bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PEN</name>
              <description>[1:1] UART parity enable
1: Parity checking and generation is enabled.
0: Parity is disabled and no parity bit is added to the data frame.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>BRK</name>
              <description>[0:0] UART send break
1: A low level is continually output on the UnTx signal, after completing transmission of the current character. For the proper execution of the break command, software must set this bit for at least two frames (character periods).
0: Normal use</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>UART control
The CTL register is the control register. All the bits are cleared on reset except for the transmit enable (TXE) and receive enable (RXE) bits, which are set.
To enable the UART module, the UARTEN bit must be set. If software requires a configuration change in the module, the UARTEN bit must be cleared before the configuration changes are written. If the UART is disabled during a transmit or receive operation, the current transaction is completed before the UART stopping.
Note: The UARTCTL register should not be changed while the UART is enabled or else the results are unpredictable. The following sequence is recommended for making changes to the UARTCTL register:
1. Disable the UART.
2. Wait for the end of transmission or reception of the current character.
3. Flush the transmit FIFO by clearing bit 4 (FEN) in the line control register (UARTLCRH).
4. Reprogram the control register.
5. Enable the UART.</description>
          <fields>
            <field>
              <name>Reserved6</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CTSEN</name>
              <description>[15:15] U1CTS Hardware Flow control enable
1: When U1CTS input is asserted, UART1 can transmit data.
0: U1CTS does not control UART1 data transmission.
Note: Only used for UART1. This bit is reserved RO for UART0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>RTSEN</name>
              <description>[14:14] U1RTS Hardware Flow control enable
1: U1RTS indicates the state of UART1 receive FIFO. U1RTS remains asserted until the preprogrammed watermark level is reached, indicating that the UART1 RXFIFO has no space to store additional characters.
0: U1RTS does not indicate state of UART1 RX FIFO.
Note: Only used for UART1. This bit is reserved RO for UART0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>Reserved4</name>
              <description>[13:10] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>RXE</name>
              <description>[9:9] UART receive enable
1: The receive section of the UART is enabled.
0: The receive section of the UART is disabled.
If the UART is disabled in the middle of a receive, it completes the current character before stopping.
Note: To enable reception, the UARTEN bit must also be set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TXE</name>
              <description>[8:8] UART transmit enable
1: The transmit section of the UART is enabled.
0: The transmit section of the UART is disabled.
If the UART is disabled in the middle of a transmission, it completes the current character before stopping.
Note: To enable transmission, the UARTEN bit must also be set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>LBE</name>
              <description>[7:7] UART loop back enable
1: The UnTx path is fed through the UnRx path.
0: Normal operation</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>LIN</name>
              <description>[6:6] LIN mode enable
1: The UART operates in LIN mode.
0: Normal operation</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>HSE</name>
              <description>[5:5] High-speed enable
0: The UART is clocked using the system clock divided by 16.
1: The UART is clocked using the system clock divided by 8.
Note: System clock used is also dependent on the baud-rate divisor configuration (See Universal Asynchronous Receivers/Transmitters - Baud-Rate Generation).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>EOT</name>
              <description>[4:4] End of transmission
This bit determines the behavior of the TXRIS bit in the UARTRIS register.
1: The TXRIS bit is set only after all transmitted data, including stop bits, have cleared the serializer.
0: The TXRIS bit is set when the transmit FIFO condition specified in UARTIFLS is met.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[3:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation. Note field should always be written as 0 for correct operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>SIRLP</name>
              <description>[2:2] UART SIR low-power mode
This bit selects the IrDA encoding mode.
1: The UART operates in SIR Low-Power mode. Low-level bits are transmitted with a pulse width which is 3 times the period of the IrLPBaud16 input signal, regardless of the selected bit rate.
0: Low-level bits are transmitted as an active high pulse with a width of 3/16th of the bit period.
Setting this bit uses less power, but might reduce transmission distances.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SIREN</name>
              <description>[1:1] UART SIR enable
1: The IrDA SIR block is enabled, and the UART transmits and receives data using SIR protocol.
0: Normal operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>UARTEN</name>
              <description>[0:0] UART enable
1: The UART is enabled.
0: The UART is disabled.
If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IFLS</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>UART interrupt FIFO level select
The IFLS register is the interrupt FIFO level select register. This register can be used to define the FIFO level at which the TXRIS and RXRIS bits in the RIS register are triggered.
The interrupts are generated based on a transition through a level rather than being based on the level. That is, the interrupts are generated when the fill level progresses through the trigger level. For example, if the receive trigger level is set to the half-way mark, the interrupt is triggered as the module is receiving the 9th character.
Out of reset, the TXIFLSEL and RXIFLSEL bits are configured so that the FIFOs trigger an interrupt at the half-way mark.</description>
          <fields>
            <field>
              <name>Reserved26</name>
              <description>[31:6] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>RXIFLSEL</name>
              <description>[5:3] UART receive interrupt FIFO level select
The trigger points for the receive interrupt are as follows:
0x0: RX FIFO >= 1/8 full
0x1: RX FIFO >= 1/4 full
0x2: RX FIFO >= 1/2 full (default)
0x3: RX FIFO >= 3/4 full
0x4: RX FIFO >= 7/8 full
0x5-0x7: Reserved</description>
              <bitWidth>3</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>TXIFLSEL</name>
              <description>[2:0] UART Transmit Interrupt FIFO Level Select
The trigger points for the transmit interrupt are as follows:
0x0: TX FIFO &lt;= 7/8 empty
0x1: TX FIFO &lt;= 3/4 empty
0x2: TX FIFO &lt;= 1/2 empty (default)
0x3: TX FIFO &lt;= 1/4 empty
0x4: TX FIFO &lt;= 1/8 empty
0x5-0x7: Reserved
Note: If the EOT bit in UARTCTL is set, the transmit interrupt is generated once the FIFO is completely empty and all data including stop bits have left the transmit serializer. In this case, the setting of TXIFLSEL is ignored.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IM</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>UART interrupt mask
The IM register is the interrupt mask set/clear register.
On a read, this register gives the current value of the mask on the relevant interrupt. Setting a bit allows the corresponding raw interrupt signal to be routed to the interrupt controller. Clearing a bit prevents the raw interrupt signal from being sent to the interrupt controller.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>LME5IM</name>
              <description>[15:15] LIN mode edge 5 interrupt mask
1: An interrupt is sent to the interrupt controller when the LME5RIS bit in the UARTRIS register is set.
0: The LME5RIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>LME1IM</name>
              <description>[14:14] LIN mode edge 1 interrupt mask
1: An interrupt is sent to the interrupt controller when the LME1RIS bit in the UARTRIS register is set.
0: The LME1RIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>LMSBIM</name>
              <description>[13:13] LIN mode sync break interrupt mask
1: An interrupt is sent to the interrupt controller when the LMSBRIS bit in the UARTRIS register is set.
0: The LMSBRIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>NINEBITIM</name>
              <description>[12:12] 9-bit mode interrupt mask
1: An interrupt is sent to the interrupt controller when the 9BITRIS bit in the UARTRIS register is set.
0: The 9BITRIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[11:11] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>OEIM</name>
              <description>[10:10] UART overrun error interrupt mask
1: An interrupt is sent to the interrupt controller when the OERIS bit in the UARTRIS register is set.
0: The OERIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>BEIM</name>
              <description>[9:9] UART break error interrupt mask
1: An interrupt is sent to the interrupt controller when the BERIS bit in the UARTRIS register is set.
0: The BERIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PEIM</name>
              <description>[8:8] UART parity error interrupt mask
1: An interrupt is sent to the interrupt controller when the PERIS bit in the UARTRIS register is set.
0: The PERIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>FEIM</name>
              <description>[7:7] UART framing error interrupt mask
1: An interrupt is sent to the interrupt controller when the FERIS bit in the UARTRIS register is set.
0: The FERIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RTIM</name>
              <description>[6:6] UART receive time-out interrupt mask
1: An interrupt is sent to the interrupt controller when the RTRIS bit in the UARTRIS register is set.
0: The RTRIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TXIM</name>
              <description>[5:5] UART transmit interrupt mask
1: An interrupt is sent to the interrupt controller when the TXRIS bit in the UARTRIS register is set.
0: The TXRIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RXIM</name>
              <description>[4:4] UART receive interrupt mask
1: An interrupt is sent to the interrupt controller when the RXRIS bit in the UARTRIS register is set.
0: The RXRIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved4</name>
              <description>[3:0] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>UART raw interrupt status
The RIS register is the raw interrupt status register. On a read, this register gives the current raw status value of the corresponding interrupt. A write has no effect. Note that the HW modem flow control bits are only implemented on UART1 and are tied inactive on UART0.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>LME5RIS</name>
              <description>[15:15] LIN mode edge 5 raw interrupt status
1: The timer value at the 5th falling edge of the LIN sync field has been captured.
0: No interrupt
This bit is cleared by writing 1 to the LME5IC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>LME1RIS</name>
              <description>[14:14] LIN mode edge 1 raw interrupt status
1: The timer value at the 1st falling edge of the LIN Sync Field has been captured.
0: No interrupt
This bit is cleared by writing 1 to the LME1IC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>LMSBRIS</name>
              <description>[13:13] LIN mode sync break raw interrupt status
1: A LIN sync break has been detected.
0: No interrupt
This bit is cleared by writing 1 to the LMSBIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>NINEBITRIS</name>
              <description>[12:12] 9-mit mode raw interrupt status
1: A receive address match has occurred.
0: No interrupt
This bit is cleared by writing 1 to the 9BITIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[11:11] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>OERIS</name>
              <description>[10:10] UART overrun error raw interrupt status
1: An overrun error has occurred.
0: No interrupt
This bit is cleared by writing 1 to the OEIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>BERIS</name>
              <description>[9:9] UART break error raw interrupt status
1: A break error has occurred.
0: No interrupt
This bit is cleared by writing 1 to the BEIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PERIS</name>
              <description>[8:8] UART parity error raw interrupt status
1: A parity error has occurred.
0: No interrupt
This bit is cleared by writing 1 to the PEIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>FERIS</name>
              <description>[7:7] UART framing error raw interrupt status
1: A framing error has occurred.
0: No interrupt
This bit is cleared by writing 1 to the FEIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RTRIS</name>
              <description>[6:6] UART receive time-out raw interrupt status
1: A receive time out has occurred.
0: No interrupt
This bit is cleared by writing 1 to the RTIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TXRIS</name>
              <description>[5:5] UART transmit raw interrupt status
1: If the EOT bit in the UARTCTL register is clear, the transmit FIFO level has passed through the condition defined in the UARTIFLS register. If the EOT bit is set, the last bit of all transmitted data and flags has left the serializer.
0: No interrupt
This bit is cleared by writing 1 to the TXIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RXRIS</name>
              <description>[4:4] UART receive raw interrupt status
1: The receive FIFO level has passed through the condition defined in the UARTIFLS register.
0: No interrupt
This bit is cleared by writing 1 to the RXIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved4</name>
              <description>[3:0] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>UART masked interrupt status
The MIS register is the masked interrupt status register. On a read, this register gives the current masked status value of the corresponding interrupt. A write has no effect.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>LME5MIS</name>
              <description>[15:15] LIN mode edge 5 masked interrupt status
1: An unmasked interrupt was signaled due to the 5th falling edge of the LIN sync field.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the LME5IC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>LME1MIS</name>
              <description>[14:14] LIN mode edge 1 masked interrupt status
1: An unmasked interrupt was signaled due to the 1st falling edge of the LIN sync field.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the LME1IC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>LMSBMIS</name>
              <description>[13:13] LIN mode sync break masked interrupt status
1: An unmasked interrupt was signaled due to the receipt of a LIN sync break.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the LMSBIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>NINEBITMIS</name>
              <description>[12:12] 9-bit mode masked interrupt status
1: An unmasked interrupt was signaled due to a receive address match.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the 9BITIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[11:11] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>OEMIS</name>
              <description>[10:10] UART overrun error masked interrupt status
1: An unmasked interrupt was signaled due to an overrun error.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the OEIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>BEMIS</name>
              <description>[9:9] UART break error masked interrupt status
1: An unmasked interrupt was signaled due to a break error.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the BEIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PEMIS</name>
              <description>[8:8] UART parity error masked interrupt status
1: An unmasked interrupt was signaled due to a parity error.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the PEIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>FEMIS</name>
              <description>[7:7] UART framing error masked interrupt status
1: An unmasked interrupt was signaled due to a framing error.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the FEIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RTMIS</name>
              <description>[6:6] UART receive time-out masked interrupt status
1: An unmasked interrupt was signaled due to a receive time out.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the RTIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TXMIS</name>
              <description>[5:5] UART transmit masked interrupt status
1: An unmasked interrupt was signaled due to passing through the specified transmit FIFO level (if the EOT bit is clear) or due to the transmission of the last data bit (if the EOT bit is set).
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the TXIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RXMIS</name>
              <description>[4:4] UART receive masked interrupt status
1: An unmasked interrupt was signaled due to passing through the specified receive FIFO level.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the RXIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved4</name>
              <description>[3:0] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>UART interrupt clear
The ICR register is the interrupt clear register. On a write of 1, the corresponding interrupt (both raw interrupt and masked interrupt, if enabled) is cleared. A write of 0 has no effect.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>LME5IC</name>
              <description>[15:15] LIN mode edge 5 interrupt clear
Writing 1 to this bit clears the LME5RIS bit in the UARTRIS register and the LME5MIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>LME1IC</name>
              <description>[14:14] LIN mode edge 1 interrupt clear
Writing 1 to this bit clears the LME1RIS bit in the UARTRIS register and the LME1MIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>LMSBIC</name>
              <description>[13:13] LIN mode sync break interrupt clear
Writing 1 to this bit clears the LMSBRIS bit in the UARTRIS register and the LMSBMIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>NINEBITIC</name>
              <description>[12:12] 9-bit mode interrupt clear
Writing 1 to this bit clears the 9BITRIS bit in the UARTRIS register and the 9BITMIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[11:11] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>OEIC</name>
              <description>[10:10] Overrun error interrupt clear
Writing 1 to this bit clears the OERIS bit in the UARTRIS register and the OEMIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>BEIC</name>
              <description>[9:9] Break error interrupt clear
Writing 1 to this bit clears the BERIS bit in the UARTRIS register and the BEMIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PEIC</name>
              <description>[8:8] Parity error interrupt clear
Writing 1 to this bit clears the PERIS bit in the UARTRIS register and the PEMIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>FEIC</name>
              <description>[7:7] Framing error interrupt clear
Writing 1 to this bit clears the FERIS bit in the UARTRIS register and the FEMIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RTIC</name>
              <description>[6:6] Receive time-out interrupt clear
Writing 1 to this bit clears the RTRIS bit in the UARTRIS register and the RTMIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TXIC</name>
              <description>[5:5] Transmit interrupt clear
Writing 1 to this bit clears the TXRIS bit in the UARTRIS register and the TXMIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RXIC</name>
              <description>[4:4] Receive interrupt clear
Writing 1 to this bit clears the RXRIS bit in the UARTRIS register and the RXMIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved4</name>
              <description>[3:0] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMACTL</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>UART DMA control
The DMACTL register is the DMA control register.</description>
          <fields>
            <field>
              <name>Reserved29</name>
              <description>[31:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>DMAERR</name>
              <description>[2:2] DMA on error
1: uDMA receive requests are automatically disabled when a receive error occurs.
0: uDMA receive requests are unaffected when a receive error occurs.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TXDMAE</name>
              <description>[1:1] Transmit DMA enable
1: uDMA for the transmit FIFO is enabled.
0: uDMA for the transmit FIFO is disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RXDMAE</name>
              <description>[0:0] Receive DMA enable
1: uDMA for the receive FIFO is enabled.
0: uDMA for the receive FIFO is disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LCTL</name>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <description>UART LIN control
The LCTL register is the configures the operation of the UART when in LIN mode.</description>
          <fields>
            <field>
              <name>Reserved26</name>
              <description>[31:6] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>BLEN</name>
              <description>[5:4] Sync break length
0x3: Sync break length is 16T bits
0x2: Sync break length is 15T bits
0x1: Sync break length is 14T bits
0x0: Sync break length is 13T bits (default)</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:1] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>MASTER</name>
              <description>[0:0] LIN master enable
1: The UART operates as a LIN master.
0: The UART operates as a LIN slave.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LSS</name>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <description>LIN snap shot
The LSS register captures the free-running timer value when either the sync edge 1 or the sync edge 5 is detected in LIN mode.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TSS</name>
              <description>[15:0] Timer snap shot
This field contains the value of the free-running timer when either the sync edge 5 or the sync edge 1 was detected.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LTIM</name>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <description>UART LIN timer
The LTIM register contains the current timer value for the free-running timer that is used to calculate the baud rate when in LIN slave mode. The value in this register is used along with the value in the UART LIN snap shot (LSS) register to adjust the baud rate to match that of the master.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TIMER</name>
              <description>[15:0] Timer value
This field contains the value of the free-running timer.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NINEBITADDR</name>
          <addressOffset>0xa4</addressOffset>
          <size>32</size>
          <description>UART 9-bit self address
The NINEBITADDR register is used to write the specific address that should be matched with the receiving byte when the 9-bit address mask (NINEBITAMASK) is set to 0xFF. This register is used in conjunction with NINEBITAMASK to form a match for address-byte received.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>NINEBITEN</name>
              <description>[15:15] Enable 9-bit mode
1: 9-bit mode is enabled.
0: 9-bit mode is disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>Reserved7</name>
              <description>[14:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ADDR</name>
              <description>[7:0] Self address for 9-bit mode
This field contains the address that should be matched when UART9BITAMASK is 0xFF.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NINEBITAMASK</name>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <description>UART 9-bit self address mask
The NINEBITAMASK register is used to enable the address mask for 9-bit mode. The lower address bits are masked to create a range of address to be matched with the received address byte.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RANGE</name>
              <description>[15:8] Self address range for 9-bit mode
Writing to the RANGE field does not have any effect; reading it reflects the ANDed output of the ADDR field in the UART9BITADDR register and the MASK field.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MASK</name>
              <description>[7:0] Self Address Mask for 9-Bit Mode
This field contains the address mask that creates a range of addresses that should be matched.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PP</name>
          <addressOffset>0xfc0</addressOffset>
          <size>32</size>
          <description>UART peripheral properties
The PP register provides information regarding the properties of the UART module.</description>
          <fields>
            <field>
              <name>Reserved30</name>
              <description>[31:2] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>NB</name>
              <description>[1:1] 9-bit support
1: The UART module provides support for the transmission of 9-bit data for RS-485 support.
0: The UART module does not provide support for the transmission of 9-bit data for RS-485 support.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SC</name>
              <description>[0:0] Smart card support
1: The UART module provides smart card support.
0: The UART module does not provide smart card support.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC</name>
          <addressOffset>0xfc8</addressOffset>
          <size>32</size>
          <description>UART clock configuration
The CC register controls the baud and system clocks sources for the UART module. For more information, see the section called "Baud-Rate Generation".
Note: If the PIOSC is used for the UART baud clock, the system clock frequency must be at least 9 MHz in run mode.</description>
          <fields>
            <field>
              <name>Reserved29</name>
              <description>[31:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CS</name>
              <description>[2:0] UART baud and system clock source
The following bits determine the clock source that generates the baud and system clocks for the UART.
bit0 (PIOSC): 
       1: The UART baud clock is determined by the IO DIV setting in the system controller.
       0: The UART baud clock is determined by the SYS DIV setting in the system controller.
bit1: Unused
bit2: (DSEN) Only meaningful when the system is in deep sleep mode. This bit is a don't care when not in sleep mode. 
       1: The UART system clock is running on the same clock as the baud clock, as per PIOSC setting above.
       0: The UART system clock is determined by the SYS DIV setting in the system controller.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART1</name>
      <baseAddress>0x4000D000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00001000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>DR</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>UART data
Important: This register is read-sensitive. See the register description for details.
This register is the data register (the interface to the FIFOs).
For transmitted data, if the FIFO is enabled, data written to this location is pushed onto the transmit FIFO. If the FIFO is disabled, data is stored in the transmitter holding register (the bottom word of the transmit FIFO). A write to this register initiates a transmission from the UART.
For received data, if the FIFO is enabled, the data byte and the 4-bit status (break, frame, parity, and overrun) is pushed onto the 12-bit wide receive FIFO. If the FIFO is disabled, the data byte and status are stored in the receiving holding register (the bottom word of the receive FIFO). The received data can be retrieved by reading this register.</description>
          <fields>
            <field>
              <name>Reserved20</name>
              <description>[31:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>OE</name>
              <description>[11:11] UART overrun error
1: New data was received when the FIFO was full, resulting in data loss.
0: No data has been lost due to a FIFO overrun.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>BE</name>
              <description>[10:10] UART break error
1: A break condition has been detected, indicating that the receive data input was held low for longer than a full-word transmission time (defined as start, data, parity, and stop bits).
0: No break condition has occurred.
In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only the one 0 character is loaded into the FIFO. The next character is only enabled after the received data input goes to a 1 (marking state), and the next valid start bit is received.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PE</name>
              <description>[9:9] UART parity error
1: The parity of the received data character does not match the parity defined by bits 2 and 7 of the UARTLCRH register
0: No parity error has occurred.
In FIFO mode, this error is associated with the character at the top of the FIFO.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>FE</name>
              <description>[8:8] UART framing error
1: The received character does not have a valid stop bit (a valid stop bit is 1).
0: No framing error has occurred.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DATA</name>
              <description>[7:0] Data transmitted or received
Data that is to be transmitted via the UART is written to this field.
When read, this field contains the data that was received by the UART.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RSR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>UART receive status and error clear
The RSR/ECR register is the receive status register and error clear register.
In addition to the DR register, receive status can also be read from the RSR register. If the status is read from this register, then the status information corresponds to the entry read from DR before reading RSR. The status information for overrun is set immediately when an overrun condition occurs.
The RSR register cannot be written.
Read-only status register</description>
          <fields>
            <field>
              <name>Reserved28</name>
              <description>[31:4] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>OE</name>
              <description>[3:3] UART overrun error
1: New data was received when the FIFO was full, resulting in data loss.
0: No data has been lost due to a FIFO overrun.
This bit is cleared by a write to UARTECR.
The FIFO contents remain valid because no further data is written when the FIFO is full, only the contents of the shift register are overwritten. The CPU must read the data in order to empty the FIFO.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>BE</name>
              <description>[2:2] UART break error
1: A break condition has been detected, indicating that the receive data input was held low for longer than a full-word transmission time (defined as start, data, parity, and stop bits).
0: No break condition has occurred.
This bit is cleared to 0 by a write to UARTECR.
In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PE</name>
              <description>[1:1] UART parity error
1: The parity of the received data character does not match the parity defined by bits 2 and 7 of the UARTLCRH register.
0: No parity error has occurred.
This bit is cleared to 0 by a write to UARTECR.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>FE</name>
              <description>[0:0] UART framing error
1: The received character does not have a valid stop bit (a valid stop bit is 1).
0: No framing error has occurred.
This bit is cleared to 0 by a write to UARTECR.
In FIFO mode, this error is associated with the character at the top of the FIFO.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ECR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>UART receive status and error clear
The RSR/ECR register is the receive status register/error clear register.
A write of any value to the ECR register clears the framing, parity, break, and overrun errors. All the bits are cleared on reset.
Write-only error clear register</description>
          <fields>
            <field>
              <name>Reserved24</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DATA</name>
              <description>[7:0] Error clear
A write to this register of any data clears the framing, parity, break, and overrun flags.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FR</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>UART flag
The FR register is the flag register. After reset, the TXFF, RXFF, and BUSY bits are 0, and TXFE and RXFE bits are 1. The CTS bit indicate the modem flow control. Note that the modem bits are only implemented on UART1 and are tied inactive on UART0. Due to this difference, the reset state of the UART0 FR register is 0x90, while UART1 FR register reset state 0x197 .</description>
          <fields>
            <field>
              <name>Reserved24</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TXFE</name>
              <description>[7:7] UART transmit FIFO empty
The meaning of this bit depends on the state of the FEN bit in the UARTLCRH register.
1: If the FIFO is disabled (FEN is 0), the transmit holding register is empty. If the FIFO is enabled (FEN is 1), the transmit FIFO is empty.
0: The transmitter has data to transmit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RXFF</name>
              <description>[6:6] UART receive FIFO full
The meaning of this bit depends on the state of the FEN bit in the UARTLCRH register.
1: If the FIFO is disabled (FEN is 0), the receive holding register is full. If the FIFO is enabled (FEN is 1), the receive FIFO is full.
0: The receiver can receive data.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TXFF</name>
              <description>[5:5] UART transmit FIFO full
The meaning of this bit depends on the state of the FEN bit in the UARTLCRH register.
1: If the FIFO is disabled (FEN is 0), the transmit holding register is full. If the FIFO is enabled (FEN is 1), the transmit FIFO is full.
0: The transmitter is not full.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RXFE</name>
              <description>[4:4] UART receive FIFO empty
The meaning of this bit depends on the state of the FEN bit in the UARTLCRH register.
1: If the FIFO is disabled (FEN is 0), the receive holding register is empty. If the FIFO is enabled (FEN is 1), the receive FIFO is empty.
0: The receiver is not empty.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>BUSY</name>
              <description>[3:3] UART busy
1: The UART is busy transmitting data. This bit remains set until the complete byte, including all stop bits, has been sent from the shift register.
0: The UART is not busy.
This bit is set as soon as the transmit FIFO becomes non-empty (regardless of whether UART is enabled).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>Reserved2</name>
              <description>[2:1] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CTS</name>
              <description>[0:0] Clear to send (UART1 only, reserved for UART0).
1: The U1CTS signal is asserted.
0: The U1CTS signal is not asserted.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ILPR</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>UART IrDA low-power register
The ILPR register stores the 8-bit low-power counter divisor value used to derive the low-power SIR pulse width clock by dividing down the system clock (SysClk). All the bits are cleared when reset.
The internal IrLPBaud16 clock is generated by dividing down SysClk according to the low-power divisor value written to ILPR. The duration of SIR pulses generated when low-power mode is enabled is three times the period of the IrLPBaud16 clock. The low-power divisor value is calculated as follows:
ILPDVSR = SysClk / FIrLPBaud16
where FIrLPBaud16 is nominally 1.8432 MHz
The divisor must be programmed such that FIrLPBaud16 is in the range 1.42 MHz to 2.12 MHz, resulting in a low-power pulse duration of 1.41-2.11 us (three times the period of IrLPBaud16). The minimum
frequency of IrLPBaud16 ensures that pulses less than one period of IrLPBaud16 are rejected, but pulses greater than 1.4 us are accepted as valid pulses.
Note: Zero is an illegal value. Programming a zero value results in no IrLPBaud16 pulses being generated.</description>
          <fields>
            <field>
              <name>Reserved24</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ILPDVSR</name>
              <description>[7:0] IrDA low-power divisor
This field contains the 8-bit low-power divisor value.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IBRD</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>UART integer baud-rate divisor
The IBRD register is the integer part of the baud-rate divisor value. All the bits are cleared on reset. The minimum possible divide ratio is 1 (when IBRD = 0), in which case the FBRD register is ignored. When changing the IBRD register, the new value does not take effect until transmission or reception of the current character is complete. Any changes to the baud-rate divisor must be followed by a write to the LCRH register.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DIVINT</name>
              <description>[15:0] Integer baud-rate divisor</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FBRD</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>UART fractional baud-rate divisor
The FBRD register is the fractional part of the baud-rate divisor value. All the bits are cleared on reset. When changing the FBRD register, the new value does not take effect until transmission or reception of the current character is complete. Any changes to the baud-rate divisor must be followed by a write to the LCRH register.</description>
          <fields>
            <field>
              <name>Reserved26</name>
              <description>[31:6] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DIVFRAC</name>
              <description>[5:0] Fractional baud-rate divisor</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LCRH</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>UART line control
The LCRH register is the line control register. Serial parameters such as data length, parity, and stop bit selection are implemented in this register.
When updating the baud-rate divisor (IBRD and/or IFRD), the LCRH register must also be written. The write strobe for the baud-rate divisor registers is tied to the LCRH register.</description>
          <fields>
            <field>
              <name>Reserved24</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SPS</name>
              <description>[7:7] UART stick parity select
When bits 1, 2, and 7 of UARTLCRH are set, the parity bit is transmitted and checked as a 0. When bits 1 and 7 are set and 2 is cleared, the parity bit is transmitted and checked as a 1.
When this bit is cleared, stick parity is disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>WLEN</name>
              <description>[6:5] UART word length
The bits indicate the number of data bits transmitted or received in a frame as follows:
0x0: 5 bits (default)
0x1: 6 bits
0x2: 7 bits
0x3: 8 bits</description>
              <bitWidth>2</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>FEN</name>
              <description>[4:4] UART enable FIFOs
1: The transmit and receive FIFObuffers are enabled (FIFOmode).
0: The FIFOs are disabled (Character mode). The FIFOs become 1-byte-deep holding registers.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>STP2</name>
              <description>[3:3] UART two stop bits select
1: Two stop bits are transmitted at the end of a frame. The receive logic does not check for two stop bits being received. 
0: One stop bit is transmitted at the end of a frame.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>EPS</name>
              <description>[2:2] UART even parity select
1: Even parity generation and checking is performed during transmission and reception, which checks for an even number of 1s in data and parity bits.
0: Odd parity is performed, which checks for an odd number of 1s.
This bit has no effect when parity is disabled by the PEN bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PEN</name>
              <description>[1:1] UART parity enable
1: Parity checking and generation is enabled.
0: Parity is disabled and no parity bit is added to the data frame.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>BRK</name>
              <description>[0:0] UART send break
1: A low level is continually output on the UnTx signal, after completing transmission of the current character. For the proper execution of the break command, software must set this bit for at least two frames (character periods).
0: Normal use</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>UART control
The CTL register is the control register. All the bits are cleared on reset except for the transmit enable (TXE) and receive enable (RXE) bits, which are set.
To enable the UART module, the UARTEN bit must be set. If software requires a configuration change in the module, the UARTEN bit must be cleared before the configuration changes are written. If the UART is disabled during a transmit or receive operation, the current transaction is completed before the UART stopping.
Note: The UARTCTL register should not be changed while the UART is enabled or else the results are unpredictable. The following sequence is recommended for making changes to the UARTCTL register:
1. Disable the UART.
2. Wait for the end of transmission or reception of the current character.
3. Flush the transmit FIFO by clearing bit 4 (FEN) in the line control register (UARTLCRH).
4. Reprogram the control register.
5. Enable the UART.</description>
          <fields>
            <field>
              <name>Reserved6</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CTSEN</name>
              <description>[15:15] U1CTS Hardware Flow control enable
1: When U1CTS input is asserted, UART1 can transmit data.
0: U1CTS does not control UART1 data transmission.
Note: Only used for UART1. This bit is reserved RO for UART0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>RTSEN</name>
              <description>[14:14] U1RTS Hardware Flow control enable
1: U1RTS indicates the state of UART1 receive FIFO. U1RTS remains asserted until the preprogrammed watermark level is reached, indicating that the UART1 RXFIFO has no space to store additional characters.
0: U1RTS does not indicate state of UART1 RX FIFO.
Note: Only used for UART1. This bit is reserved RO for UART0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>Reserved4</name>
              <description>[13:10] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>RXE</name>
              <description>[9:9] UART receive enable
1: The receive section of the UART is enabled.
0: The receive section of the UART is disabled.
If the UART is disabled in the middle of a receive, it completes the current character before stopping.
Note: To enable reception, the UARTEN bit must also be set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TXE</name>
              <description>[8:8] UART transmit enable
1: The transmit section of the UART is enabled.
0: The transmit section of the UART is disabled.
If the UART is disabled in the middle of a transmission, it completes the current character before stopping.
Note: To enable transmission, the UARTEN bit must also be set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>LBE</name>
              <description>[7:7] UART loop back enable
1: The UnTx path is fed through the UnRx path.
0: Normal operation</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>LIN</name>
              <description>[6:6] LIN mode enable
1: The UART operates in LIN mode.
0: Normal operation</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>HSE</name>
              <description>[5:5] High-speed enable
0: The UART is clocked using the system clock divided by 16.
1: The UART is clocked using the system clock divided by 8.
Note: System clock used is also dependent on the baud-rate divisor configuration (See Universal Asynchronous Receivers/Transmitters - Baud-Rate Generation).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>EOT</name>
              <description>[4:4] End of transmission
This bit determines the behavior of the TXRIS bit in the UARTRIS register.
1: The TXRIS bit is set only after all transmitted data, including stop bits, have cleared the serializer.
0: The TXRIS bit is set when the transmit FIFO condition specified in UARTIFLS is met.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[3:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation. Note field should always be written as 0 for correct operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>SIRLP</name>
              <description>[2:2] UART SIR low-power mode
This bit selects the IrDA encoding mode.
1: The UART operates in SIR Low-Power mode. Low-level bits are transmitted with a pulse width which is 3 times the period of the IrLPBaud16 input signal, regardless of the selected bit rate.
0: Low-level bits are transmitted as an active high pulse with a width of 3/16th of the bit period.
Setting this bit uses less power, but might reduce transmission distances.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SIREN</name>
              <description>[1:1] UART SIR enable
1: The IrDA SIR block is enabled, and the UART transmits and receives data using SIR protocol.
0: Normal operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>UARTEN</name>
              <description>[0:0] UART enable
1: The UART is enabled.
0: The UART is disabled.
If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IFLS</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>UART interrupt FIFO level select
The IFLS register is the interrupt FIFO level select register. This register can be used to define the FIFO level at which the TXRIS and RXRIS bits in the RIS register are triggered.
The interrupts are generated based on a transition through a level rather than being based on the level. That is, the interrupts are generated when the fill level progresses through the trigger level. For example, if the receive trigger level is set to the half-way mark, the interrupt is triggered as the module is receiving the 9th character.
Out of reset, the TXIFLSEL and RXIFLSEL bits are configured so that the FIFOs trigger an interrupt at the half-way mark.</description>
          <fields>
            <field>
              <name>Reserved26</name>
              <description>[31:6] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>RXIFLSEL</name>
              <description>[5:3] UART receive interrupt FIFO level select
The trigger points for the receive interrupt are as follows:
0x0: RX FIFO >= 1/8 full
0x1: RX FIFO >= 1/4 full
0x2: RX FIFO >= 1/2 full (default)
0x3: RX FIFO >= 3/4 full
0x4: RX FIFO >= 7/8 full
0x5-0x7: Reserved</description>
              <bitWidth>3</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>TXIFLSEL</name>
              <description>[2:0] UART Transmit Interrupt FIFO Level Select
The trigger points for the transmit interrupt are as follows:
0x0: TX FIFO &lt;= 7/8 empty
0x1: TX FIFO &lt;= 3/4 empty
0x2: TX FIFO &lt;= 1/2 empty (default)
0x3: TX FIFO &lt;= 1/4 empty
0x4: TX FIFO &lt;= 1/8 empty
0x5-0x7: Reserved
Note: If the EOT bit in UARTCTL is set, the transmit interrupt is generated once the FIFO is completely empty and all data including stop bits have left the transmit serializer. In this case, the setting of TXIFLSEL is ignored.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IM</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>UART interrupt mask
The IM register is the interrupt mask set/clear register.
On a read, this register gives the current value of the mask on the relevant interrupt. Setting a bit allows the corresponding raw interrupt signal to be routed to the interrupt controller. Clearing a bit prevents the raw interrupt signal from being sent to the interrupt controller.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>LME5IM</name>
              <description>[15:15] LIN mode edge 5 interrupt mask
1: An interrupt is sent to the interrupt controller when the LME5RIS bit in the UARTRIS register is set.
0: The LME5RIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>LME1IM</name>
              <description>[14:14] LIN mode edge 1 interrupt mask
1: An interrupt is sent to the interrupt controller when the LME1RIS bit in the UARTRIS register is set.
0: The LME1RIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>LMSBIM</name>
              <description>[13:13] LIN mode sync break interrupt mask
1: An interrupt is sent to the interrupt controller when the LMSBRIS bit in the UARTRIS register is set.
0: The LMSBRIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>NINEBITIM</name>
              <description>[12:12] 9-bit mode interrupt mask
1: An interrupt is sent to the interrupt controller when the 9BITRIS bit in the UARTRIS register is set.
0: The 9BITRIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[11:11] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>OEIM</name>
              <description>[10:10] UART overrun error interrupt mask
1: An interrupt is sent to the interrupt controller when the OERIS bit in the UARTRIS register is set.
0: The OERIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>BEIM</name>
              <description>[9:9] UART break error interrupt mask
1: An interrupt is sent to the interrupt controller when the BERIS bit in the UARTRIS register is set.
0: The BERIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PEIM</name>
              <description>[8:8] UART parity error interrupt mask
1: An interrupt is sent to the interrupt controller when the PERIS bit in the UARTRIS register is set.
0: The PERIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>FEIM</name>
              <description>[7:7] UART framing error interrupt mask
1: An interrupt is sent to the interrupt controller when the FERIS bit in the UARTRIS register is set.
0: The FERIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RTIM</name>
              <description>[6:6] UART receive time-out interrupt mask
1: An interrupt is sent to the interrupt controller when the RTRIS bit in the UARTRIS register is set.
0: The RTRIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TXIM</name>
              <description>[5:5] UART transmit interrupt mask
1: An interrupt is sent to the interrupt controller when the TXRIS bit in the UARTRIS register is set.
0: The TXRIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RXIM</name>
              <description>[4:4] UART receive interrupt mask
1: An interrupt is sent to the interrupt controller when the RXRIS bit in the UARTRIS register is set.
0: The RXRIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved4</name>
              <description>[3:0] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>UART raw interrupt status
The RIS register is the raw interrupt status register. On a read, this register gives the current raw status value of the corresponding interrupt. A write has no effect. Note that the HW modem flow control bits are only implemented on UART1 and are tied inactive on UART0.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>LME5RIS</name>
              <description>[15:15] LIN mode edge 5 raw interrupt status
1: The timer value at the 5th falling edge of the LIN sync field has been captured.
0: No interrupt
This bit is cleared by writing 1 to the LME5IC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>LME1RIS</name>
              <description>[14:14] LIN mode edge 1 raw interrupt status
1: The timer value at the 1st falling edge of the LIN Sync Field has been captured.
0: No interrupt
This bit is cleared by writing 1 to the LME1IC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>LMSBRIS</name>
              <description>[13:13] LIN mode sync break raw interrupt status
1: A LIN sync break has been detected.
0: No interrupt
This bit is cleared by writing 1 to the LMSBIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>NINEBITRIS</name>
              <description>[12:12] 9-mit mode raw interrupt status
1: A receive address match has occurred.
0: No interrupt
This bit is cleared by writing 1 to the 9BITIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[11:11] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>OERIS</name>
              <description>[10:10] UART overrun error raw interrupt status
1: An overrun error has occurred.
0: No interrupt
This bit is cleared by writing 1 to the OEIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>BERIS</name>
              <description>[9:9] UART break error raw interrupt status
1: A break error has occurred.
0: No interrupt
This bit is cleared by writing 1 to the BEIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PERIS</name>
              <description>[8:8] UART parity error raw interrupt status
1: A parity error has occurred.
0: No interrupt
This bit is cleared by writing 1 to the PEIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>FERIS</name>
              <description>[7:7] UART framing error raw interrupt status
1: A framing error has occurred.
0: No interrupt
This bit is cleared by writing 1 to the FEIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RTRIS</name>
              <description>[6:6] UART receive time-out raw interrupt status
1: A receive time out has occurred.
0: No interrupt
This bit is cleared by writing 1 to the RTIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TXRIS</name>
              <description>[5:5] UART transmit raw interrupt status
1: If the EOT bit in the UARTCTL register is clear, the transmit FIFO level has passed through the condition defined in the UARTIFLS register. If the EOT bit is set, the last bit of all transmitted data and flags has left the serializer.
0: No interrupt
This bit is cleared by writing 1 to the TXIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RXRIS</name>
              <description>[4:4] UART receive raw interrupt status
1: The receive FIFO level has passed through the condition defined in the UARTIFLS register.
0: No interrupt
This bit is cleared by writing 1 to the RXIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved4</name>
              <description>[3:0] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>UART masked interrupt status
The MIS register is the masked interrupt status register. On a read, this register gives the current masked status value of the corresponding interrupt. A write has no effect.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>LME5MIS</name>
              <description>[15:15] LIN mode edge 5 masked interrupt status
1: An unmasked interrupt was signaled due to the 5th falling edge of the LIN sync field.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the LME5IC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>LME1MIS</name>
              <description>[14:14] LIN mode edge 1 masked interrupt status
1: An unmasked interrupt was signaled due to the 1st falling edge of the LIN sync field.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the LME1IC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>LMSBMIS</name>
              <description>[13:13] LIN mode sync break masked interrupt status
1: An unmasked interrupt was signaled due to the receipt of a LIN sync break.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the LMSBIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>NINEBITMIS</name>
              <description>[12:12] 9-bit mode masked interrupt status
1: An unmasked interrupt was signaled due to a receive address match.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the 9BITIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[11:11] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>OEMIS</name>
              <description>[10:10] UART overrun error masked interrupt status
1: An unmasked interrupt was signaled due to an overrun error.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the OEIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>BEMIS</name>
              <description>[9:9] UART break error masked interrupt status
1: An unmasked interrupt was signaled due to a break error.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the BEIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PEMIS</name>
              <description>[8:8] UART parity error masked interrupt status
1: An unmasked interrupt was signaled due to a parity error.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the PEIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>FEMIS</name>
              <description>[7:7] UART framing error masked interrupt status
1: An unmasked interrupt was signaled due to a framing error.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the FEIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RTMIS</name>
              <description>[6:6] UART receive time-out masked interrupt status
1: An unmasked interrupt was signaled due to a receive time out.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the RTIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TXMIS</name>
              <description>[5:5] UART transmit masked interrupt status
1: An unmasked interrupt was signaled due to passing through the specified transmit FIFO level (if the EOT bit is clear) or due to the transmission of the last data bit (if the EOT bit is set).
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the TXIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RXMIS</name>
              <description>[4:4] UART receive masked interrupt status
1: An unmasked interrupt was signaled due to passing through the specified receive FIFO level.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the RXIC bit in the UARTICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved4</name>
              <description>[3:0] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>UART interrupt clear
The ICR register is the interrupt clear register. On a write of 1, the corresponding interrupt (both raw interrupt and masked interrupt, if enabled) is cleared. A write of 0 has no effect.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>LME5IC</name>
              <description>[15:15] LIN mode edge 5 interrupt clear
Writing 1 to this bit clears the LME5RIS bit in the UARTRIS register and the LME5MIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>LME1IC</name>
              <description>[14:14] LIN mode edge 1 interrupt clear
Writing 1 to this bit clears the LME1RIS bit in the UARTRIS register and the LME1MIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>LMSBIC</name>
              <description>[13:13] LIN mode sync break interrupt clear
Writing 1 to this bit clears the LMSBRIS bit in the UARTRIS register and the LMSBMIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>NINEBITIC</name>
              <description>[12:12] 9-bit mode interrupt clear
Writing 1 to this bit clears the 9BITRIS bit in the UARTRIS register and the 9BITMIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[11:11] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>OEIC</name>
              <description>[10:10] Overrun error interrupt clear
Writing 1 to this bit clears the OERIS bit in the UARTRIS register and the OEMIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>BEIC</name>
              <description>[9:9] Break error interrupt clear
Writing 1 to this bit clears the BERIS bit in the UARTRIS register and the BEMIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PEIC</name>
              <description>[8:8] Parity error interrupt clear
Writing 1 to this bit clears the PERIS bit in the UARTRIS register and the PEMIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>FEIC</name>
              <description>[7:7] Framing error interrupt clear
Writing 1 to this bit clears the FERIS bit in the UARTRIS register and the FEMIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RTIC</name>
              <description>[6:6] Receive time-out interrupt clear
Writing 1 to this bit clears the RTRIS bit in the UARTRIS register and the RTMIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TXIC</name>
              <description>[5:5] Transmit interrupt clear
Writing 1 to this bit clears the TXRIS bit in the UARTRIS register and the TXMIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RXIC</name>
              <description>[4:4] Receive interrupt clear
Writing 1 to this bit clears the RXRIS bit in the UARTRIS register and the RXMIS bit in the UARTMIS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved4</name>
              <description>[3:0] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMACTL</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>UART DMA control
The DMACTL register is the DMA control register.</description>
          <fields>
            <field>
              <name>Reserved29</name>
              <description>[31:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>DMAERR</name>
              <description>[2:2] DMA on error
1: uDMA receive requests are automatically disabled when a receive error occurs.
0: uDMA receive requests are unaffected when a receive error occurs.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TXDMAE</name>
              <description>[1:1] Transmit DMA enable
1: uDMA for the transmit FIFO is enabled.
0: uDMA for the transmit FIFO is disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RXDMAE</name>
              <description>[0:0] Receive DMA enable
1: uDMA for the receive FIFO is enabled.
0: uDMA for the receive FIFO is disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LCTL</name>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <description>UART LIN control
The LCTL register is the configures the operation of the UART when in LIN mode.</description>
          <fields>
            <field>
              <name>Reserved26</name>
              <description>[31:6] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>BLEN</name>
              <description>[5:4] Sync break length
0x3: Sync break length is 16T bits
0x2: Sync break length is 15T bits
0x1: Sync break length is 14T bits
0x0: Sync break length is 13T bits (default)</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:1] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>MASTER</name>
              <description>[0:0] LIN master enable
1: The UART operates as a LIN master.
0: The UART operates as a LIN slave.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LSS</name>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <description>LIN snap shot
The LSS register captures the free-running timer value when either the sync edge 1 or the sync edge 5 is detected in LIN mode.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TSS</name>
              <description>[15:0] Timer snap shot
This field contains the value of the free-running timer when either the sync edge 5 or the sync edge 1 was detected.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LTIM</name>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <description>UART LIN timer
The LTIM register contains the current timer value for the free-running timer that is used to calculate the baud rate when in LIN slave mode. The value in this register is used along with the value in the UART LIN snap shot (LSS) register to adjust the baud rate to match that of the master.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TIMER</name>
              <description>[15:0] Timer value
This field contains the value of the free-running timer.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NINEBITADDR</name>
          <addressOffset>0xa4</addressOffset>
          <size>32</size>
          <description>UART 9-bit self address
The NINEBITADDR register is used to write the specific address that should be matched with the receiving byte when the 9-bit address mask (NINEBITAMASK) is set to 0xFF. This register is used in conjunction with NINEBITAMASK to form a match for address-byte received.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>NINEBITEN</name>
              <description>[15:15] Enable 9-bit mode
1: 9-bit mode is enabled.
0: 9-bit mode is disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>Reserved7</name>
              <description>[14:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ADDR</name>
              <description>[7:0] Self address for 9-bit mode
This field contains the address that should be matched when UART9BITAMASK is 0xFF.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>NINEBITAMASK</name>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <description>UART 9-bit self address mask
The NINEBITAMASK register is used to enable the address mask for 9-bit mode. The lower address bits are masked to create a range of address to be matched with the received address byte.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RANGE</name>
              <description>[15:8] Self address range for 9-bit mode
Writing to the RANGE field does not have any effect; reading it reflects the ANDed output of the ADDR field in the UART9BITADDR register and the MASK field.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MASK</name>
              <description>[7:0] Self Address Mask for 9-Bit Mode
This field contains the address mask that creates a range of addresses that should be matched.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PP</name>
          <addressOffset>0xfc0</addressOffset>
          <size>32</size>
          <description>UART peripheral properties
The PP register provides information regarding the properties of the UART module.</description>
          <fields>
            <field>
              <name>Reserved30</name>
              <description>[31:2] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>NB</name>
              <description>[1:1] 9-bit support
1: The UART module provides support for the transmission of 9-bit data for RS-485 support.
0: The UART module does not provide support for the transmission of 9-bit data for RS-485 support.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SC</name>
              <description>[0:0] Smart card support
1: The UART module provides smart card support.
0: The UART module does not provide smart card support.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CC</name>
          <addressOffset>0xfc8</addressOffset>
          <size>32</size>
          <description>UART clock configuration
The CC register controls the baud and system clocks sources for the UART module. For more information, see the section called "Baud-Rate Generation".
Note: If the PIOSC is used for the UART baud clock, the system clock frequency must be at least 9 MHz in run mode.</description>
          <fields>
            <field>
              <name>Reserved29</name>
              <description>[31:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CS</name>
              <description>[2:0] UART baud and system clock source
The following bits determine the clock source that generates the baud and system clocks for the UART.
bit0 (PIOSC): 
       1: The UART baud clock is determined by the IO DIV setting in the system controller.
       0: The UART baud clock is determined by the SYS DIV setting in the system controller.
bit1: Unused
bit2: (DSEN) Only meaningful when the system is in deep sleep mode. This bit is a don't care when not in sleep mode. 
       1: The UART system clock is running on the same clock as the baud clock, as per PIOSC setting above.
       0: The UART system clock is determined by the SYS DIV setting in the system controller.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2CM</name>
      <baseAddress>0x40020000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00000100</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>SA</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>I2C master slave address
This register consists of eight bits, seven address bits (A6-A0), and a receive and send bit, which determines if the next operation is a receive (high) or transmit (low).</description>
          <fields>
            <field>
              <name>Reserved24</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SA</name>
              <description>[7:1] I2C slave address</description>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RS</name>
              <description>[0:0] Receive and send
The R/S bit specifies if the next operation is a receive (high) or transmit (low).
0: Transmit
1: Receive</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTRL</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>I2C master control and status
This register accesses status bits when read and control bits when written. When read, the status register indicates the state of the I2C bus controller. When written, the control register configures the I2C controller operation.
The START bit generates the START or REPEATED START condition. The STOP bit determines if the cycle stops at the end of the data cycle or continues on to a repeated START condition. To generate a single transmit cycle, the I2C master slave address (I2CMSA) register is written with the desired address, the R/S bit is cleared, and this register is written with ACK = X (0 or 1), STOP = 1, START = 1, and RUN = 1 to perform the operation and stop. When the operation is completed (or aborted due an error), an interrupt becomes active and the data may be read from the I2CMDR register. When the I2C module operates in master receiver mode, the ACK bit is normally set, causing the I2C bus controller to automatically transmit an acknowledge after each byte. This bit must be cleared when the I2C bus controller requires no further data to be transmitted from the slave transmitter.</description>
          <fields>
            <field>
              <name>Reserved28</name>
              <description>[31:4] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>ACK</name>
              <description>[3:3] Data acknowledge enable
0: The received data byte is not acknowledged automatically by the master.
1: The received data byte is acknowledged automatically by the master.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>STOP</name>
              <description>[2:2] Generate STOP
0: The controller does not generate the STOP condition.
1: The controller generates the STOP condition.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>START</name>
              <description>[1:1] Generate START
0: The controller does not generate the START condition.
1: The controller generates the START condition.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RUN</name>
              <description>[0:0] I2C master enable
0: The master is disabled.
1: The master is enabled to transmit or receive data.
When the BUSY bit is set, the other status bits are not valid.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>STAT</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>I2C master control and status
This register accesses status bits when read and control bits when written. When read, the status register indicates the state of the I2C bus controller. When written, the control register configures the I2C controller operation.
The START bit generates the START or REPEATED START condition. The STOP bit determines if the cycle stops at the end of the data cycle or continues on to a repeated START condition. To generate a single transmit cycle, the I2C master slave address (I2CMSA) register is written with the desired address, the R/S bit is cleared, and this register is written with ACK = X (0 or 1), STOP = 1, START = 1, and RUN = 1 to perform the operation and stop. When the operation is completed (or aborted due an error), an interrupt becomes active and the data may be read from the I2CMDR register. When the I2C module operates in master receiver mode, the ACK bit is normally set, causing the I2C bus controller to automatically transmit an acknowledge after each byte. This bit must be cleared when the I2C bus controller requires no further data to be transmitted from the slave transmitter.</description>
          <fields>
            <field>
              <name>Reserved25</name>
              <description>[31:7] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>BUSBSY</name>
              <description>[6:6] Bus busy
0: The I2C bus is idle.
1: The I2C bus is busy.
The bit changes based on the START and STOP conditions.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>IDLE</name>
              <description>[5:5] I2C idle
0: The I2C controller is not idle.
1: The I2C controller is idle.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>ARBLST</name>
              <description>[4:4] Arbitration lost
0: The I2C controller won arbitration.
1: The I2C controller lost arbitration.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DATACK</name>
              <description>[3:3] Acknowledge data
0: The transmited data was acknowledged.
1: The transmited data was not acknowledged.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>ADRACK</name>
              <description>[2:2] Acknowledge address
0: The transmited address was acknowledged.
1: The transmited address was not acknowledged.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>ERROR</name>
              <description>[1:1] Error
0: No error was detected on the last operation.
1: An error occurred on the last operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>BUSY</name>
              <description>[0:0] I2C busy
0: The controller is idle.
1: The controller is busy.
When the BUSY bit is set, the other status bits are not valid.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>I2C master data
This register contains the data to be transmitted when in the master transmit state and the data received when in the master receive state.</description>
          <fields>
            <field>
              <name>Reserved24</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DATA</name>
              <description>[7:0] Data transferred
Data transferred during transaction</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TPR</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>I2C master timer period
This register specifies the period of the SCL clock.</description>
          <fields>
            <field>
              <name>Reserved25</name>
              <description>[31:7] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TPR</name>
              <description>[6:0] SCL clock period
This field specifies the period of the SCL clock.
SCL_PRD = 2 * (1+TPR)*(SCL_LP + SCL_HP)*CLK_PRD
where:
SCL_PRD is the SCL line period (I2C clock).
TPR is the timer period register value (range of 1 to 127)
SCL_LP is the SCL low period (fixed at 6).
SCL_HP is the SCL high period (fixed at 4).
CLK_PRD is the system clock period in ns.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IMR</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>I2C master interrupt mask
This register controls whether a raw interrupt is promoted to a controller interrupt.</description>
          <fields>
            <field>
              <name>Reserved31</name>
              <description>[31:1] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>IM</name>
              <description>[0:0] Interrupt mask
1: The master interrupt is sent to the interrupt controller when the RIS bit in the I2CMRIS register is set.
0: The RIS interrupt is suppressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>I2C master raw interrupt status
This register specifies whether an interrupt is pending.</description>
          <fields>
            <field>
              <name>Reserved31</name>
              <description>[31:1] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RIS</name>
              <description>[0:0] Raw interrupt status
1: A master interrupt is pending.
0: No interrupt
This bit is cleared by writing 1 to the IC bit in the I2CMICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>I2C master masked interrupt status
This register specifies whether an interrupt was signaled.</description>
          <fields>
            <field>
              <name>Reserved31</name>
              <description>[31:1] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>MIS</name>
              <description>[0:0] Masked interrupt status
1: An unmasked master interrupt is pending.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the IC bit in the I2CMICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>I2C master interrupt clear
This register clears the raw and masked interrupts.</description>
          <fields>
            <field>
              <name>Reserved31</name>
              <description>[31:1] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>IC</name>
              <description>[0:0] Interrupt clear
Writing 1 to this bit clears the RIS bit in the I2CMRIS register and the MIS bit in the I2CMMIS register.
Reading this register returns no meaningful data.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CR</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>I2C master configuration
This register configures the mode (master or slave) and sets the interface for test mode loopback.</description>
          <fields>
            <field>
              <name>Reserved26</name>
              <description>[31:6] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SFE</name>
              <description>[5:5] I2C slave function enable
1: Slave mode is enabled.
0: Slave mode is disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>MFE</name>
              <description>[4:4] I2C master function enable
1: Master mode is enabled.
0: Master mode is disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:1] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>LPBK</name>
              <description>[0:0] I2C loopback
1: The controller in a test mode loopback configuration.
0: Normal operation</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2CS</name>
      <baseAddress>0x40020800</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00000100</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>OAR</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>I2C slave own address
This register consists of seven address bits that identify the CC2538 I2C device on the I2C bus.</description>
          <fields>
            <field>
              <name>Reserved25</name>
              <description>[31:7] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>OAR</name>
              <description>[6:0] I2C slave own address
This field specifies bits A6 through A0 of the slave address.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>STAT</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>I2C slave control and status
This register functions as a control register when written, and a status register when read.</description>
          <fields>
            <field>
              <name>Reserved29</name>
              <description>[31:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>FBR</name>
              <description>[2:2] First byte received
1: The first byte following the slave's own address has been received.
0: The first byte has not been received.
This bit is only valid when the RREQ bit is set and is automatically cleared when data has been read from the I2CSDR register.
Note: This bit is not used for slave transmit operations.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TREQ</name>
              <description>[1:1] Transmit request
1: The I2C controller has been addressed as a slave transmitter and is using clock stretching to delay the master until data has been written to the I2CSDR register.
0: No outstanding transmit request.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RREQ</name>
              <description>[0:0] Receive request
1: The I2C controller has outstanding receive data from the I2C master and is using clock stretching to delay the master until data has been read from the I2CSDR register.
0: No outstanding receive data</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTRL</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>I2C slave control and status
This register functions as a control register when written, and a status register when read.</description>
          <fields>
            <field>
              <name>Reserved31</name>
              <description>[31:1] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DA</name>
              <description>[0:0] Device active
0: Disables the I2C slave operation
1: Enables the I2C slave operation</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>I2C slave data
This register contains the data to be transmitted when in the slave transmit state, and the data received when in the slave receive state.</description>
          <fields>
            <field>
              <name>Reserved24</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DATA</name>
              <description>[7:0] Data for transfer
This field contains the data for transfer during a slave receive or transmit operation.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IMR</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>I2C slave interrupt mask
This register controls whether a raw interrupt is promoted to a controller interrupt.</description>
          <fields>
            <field>
              <name>Reserved29</name>
              <description>[31:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>STOPIM</name>
              <description>[2:2] Stop condition interrupt mask
1: The STOP condition interrupt is sent to the interrupt controller when the STOPRIS bit in the I2CSRIS register is set.
0: The STOPRIS interrupt is supressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>STARTIM</name>
              <description>[1:1] Start condition interrupt mask
1: The START condition interrupt is sent to the interrupt controller when the STARTRIS bit in the I2CSRIS register is set.
0: The STARTRIS interrupt is supressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DATAIM</name>
              <description>[0:0] Data interrupt mask
1: The data received or data requested interrupt is sent to the interrupt controller when the DATARIS bit in the I2CSRIS register is set.
0: The DATARIS interrupt is surpressed and not sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>I2C slave raw interrupt status
This register specifies whether an interrupt is pending.</description>
          <fields>
            <field>
              <name>Reserved29</name>
              <description>[31:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>STOPRIS</name>
              <description>[2:2] Stop condition raw interrupt status
1: A STOP condition interrupt is pending.
0: No interrupt
This bit is cleared by writing 1 to the STOPIC bit in the I2CSICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>STARTRIS</name>
              <description>[1:1] Start condition raw interrupt status
1: A START condition interrupt is pending.
0: No interrupt
This bit is cleared by writing 1 to the STARTIC bit in the I2CSICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DATARIS</name>
              <description>[0:0] Data raw interrupt status
1: A data received or data requested interrupt is pending.
0: No interrupt
This bit is cleared by writing 1 to the DATAIC bit in the I2CSICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>I2C slave masked interrupt status
This register specifies whether an interrupt was signaled.</description>
          <fields>
            <field>
              <name>Reserved29</name>
              <description>[31:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>STOPMIS</name>
              <description>[2:2] Stop condition masked interrupt status
1: An unmasked STOP condition interrupt is pending.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the STOPIC bit in the I2CSICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>STARTMIS</name>
              <description>[1:1] Start condition masked interrupt status
1: An unmasked START condition interrupt is pending.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the STARTIC bit in the I2CSICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DATAMIS</name>
              <description>[0:0] Data masked interrupt status
1: An unmasked data received or data requested interrupt is pending.
0: An interrupt has not occurred or is masked.
This bit is cleared by writing 1 to the DATAIC bit in the I2CSICR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>I2C slave interrupt clear
This register clears the raw interrupt. A read of this register returns no meaningful data.</description>
          <fields>
            <field>
              <name>Reserved29</name>
              <description>[31:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>STOPIC</name>
              <description>[2:2] Stop condition interrupt clear
Writing 1 to this bit clears the STOPRIS bit in the I2CSRIS register and the STOPMIS bit in the I2CSMIS register.
A read of this register returns no meaningful data.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>STARTIC</name>
              <description>[1:1] Start condition interrupt vlear
Writing 1 to this bit clears the STARTRIS bit in the I2CSRIS register and the STARTMIS bit in the I2CSMIS register.
A read of this register returns no meaningful data.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DATAIC</name>
              <description>[0:0] Data interrupt clear
Writing 1 to this bit clears the DATARIS bit in the I2CSRIS register and the DATAMIS bit in the I2CSMIS register.
A read of this register returns no meaningful data.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPTIMER0</name>
      <baseAddress>0x40030000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00001000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>CFG</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>GPTM configuration
This register configures the global operation of the GPTM. The value written to this register determines whether the GPTM is in 32-bit mode (concatenated timers) or in 16-bit mode (individual, split timers).</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>GPTMCFG</name>
              <description>[2:0] GPTM configuration
The GPTMCFG values are defined as follows:
0x0: 32-bit timer configuration.
0x1: 32-bit real-time clock
0x2: Reserved
0x3: Reserved
0x4: 16-bit timer configuration.
The function is controlled by bits [1:0] of GPTMTAMR and GPTMTBMR.
0x5-0x7: Reserved</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAMR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>GPTM Timer A mode
This register configures the GPTM based on the configuration selected in the CFG register.
This register controls the modes for Timer A when it is used individually. When Timer A and Timer B are concatenated, this register controls the modes for both Timer A and Timer B, and the contents of TBMR are ignored.</description>
          <fields>
            <field>
              <name>Reserved12</name>
              <description>[31:12] Reserved</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TAPLO</name>
              <description>[11:11] Legacy PWM operation
0: Legacy operation
1: CCP is set to 1 on time-out.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>TAMRSU</name>
              <description>[10:10] Timer A match register update mode
0: Update GPTMAMATCHR and GPTMAPR if used on the next cycle.
1: Update GPTMAMATCHR and GPTMAPR if used on the next
time-out. If the timer is disabled (TAEN is clear) when this bit is set, GPTMTAMATCHR and GPTMTAPR are updated when the timer is
enabled. If the timer is stalled (TASTALL is set), GPTMTAMATCHR and GPTMTAPR are updated according to the configuration of this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>TAPWMIE</name>
              <description>[9:9] GPTM Timer A PWM interrupt enable
This bit enables interrupts in PWM mode on rising, falling, or both edges of the CCP output.
0: Interrupt is disabled.
1: Interrupt is enabled.
This bit is valid only in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TAILD</name>
              <description>[8:8] GPTM Timer A PWM interval load write
0: Update the GPTMTAR register with the value in the GPTMTAILR register on the next cycle. If the prescaler is used, update the GPTMTAPS register with the value in the GPTMTAPR register on the next cycle.
1: Update the GPTMTAR register with the value in the GPTMTAILR register on the next cycle. If the prescaler is used, update the GPTMTAPS register with the value in the GPTMTAPR register on the next time-out.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TASNAPS</name>
              <description>[7:7] GPTM Timer A snap-shot mode
0: Snap-shot mode is disabled.
1: If Timer A is configured in periodic mode, the actual free-running value of Timer A is loaded at the time-out event into the GPTM Timer A (GPTMTAR) register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TAWOT</name>
              <description>[6:6] GPTM Timer A wait-on-trigger
0: Timer A begins counting as soon as it is enabled.
1: If Timer A is enabled (TAEN is set in the GPTMCTL register), Timer A does not begin counting until it receives a trigger from the Timer in the previous position in the daisy-chain. This bit must be clear for GP Timer module 0, Timer A.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TAMIE</name>
              <description>[5:5] GPTM Timer A match interrupt enable
0: The match interrupt is disabled.
1: An interrupt is generated when the match value in the GPTMTAMATCHR register is reached in the one-shot and periodic
modes.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TACDIR</name>
              <description>[4:4] GPTM Timer A count direction
0: The timer counts down.
1: The timer counts up. When counting up, the timer starts from a value of 0x0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TAAMS</name>
              <description>[3:3] GPTM Timer A alternate mode
0: Capture mode is enabled.
1: PWM mode is enabled.
Note: To enable PWM mode, the TACM bit must be cleared and the TAMR field must be configured to 0x2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>TACMR</name>
              <description>[2:2] GPTM Timer A capture mode
0: Edge-count mode
1: Edge-time mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TAMR</name>
              <description>[1:0] GPTM Timer A mode
0x0: Reserved
0x1: One-shot mode
0x2: Periodic mode
0x3: Capture mode
The timer mode is based on the timer configuration defined by bits [2:0] in the GPTMCFG register.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBMR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>GPTM Timer B mode
This register configures the GPTM based on the configuration selected in the CFG register.
This register controls the modes for Timer B when it is used individually. When Timer A and Timer B are concatenated, this register is ignored and TBMR controls the modes for both Timer A and Timer B.</description>
          <fields>
            <field>
              <name>Reserved12</name>
              <description>[31:12] Reserved</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBPLO</name>
              <description>[11:11] Legacy PWM operation
0: Legacy operation
1: CCP is set to 1 on time-out.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>TBMRSU</name>
              <description>[10:10] Timer B match register update mode
0: Update the GPTMBMATCHR and the GPTMBPR, if used on the next cycle.
1: Update the GPTMBMATCHR and the GPTMBPR, if used on the next time-out. If the timer is disabled (TAEN is clear) when this bit is set, GPTMTBMATCHR and GPTMTBPR are updated when the timer is enabled. If the timer is stalled (TBSTALL is set), GPTMTBMATCHR and GPTMTBPR are updated according to the configuration of this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>TBPWMIE</name>
              <description>[9:9] GPTM Timer B PWM interrupt enable
This bit enables interrupts in PWM mode on rising, falling, or both edges of the CCP output.
0: Interrupt is disabled.
1: Interrupt is enabled.
This bit is valid only in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBILD</name>
              <description>[8:8] GPTM Timer B PWM interval load write
0: Update the GPTMTBR register with the value in the GPTMTBILR register on the next cycle. If the prescaler is used, update the GPTMTBPS register with the value in the GPTMTBPR register on the next cycle.
1: Update the GPTMTBR register with the value in the GPTMTBILR register on the next cycle. If the prescaler is used, update the GPTMTBPS register with the value in the GPTMTBPR register on the next time-out.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBSNAPS</name>
              <description>[7:7] GPTM Timer B snap-shot mode
0: Snap-shot mode is disabled.
1: If Timer B is configured in the periodic mode, the actual free-running value of Timer A is loaded into the GPTM Timer B (GPTMTBR) register at the time-out event.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TBWOT</name>
              <description>[6:6] GPTM Timer B wait-on-trigger
0: Timer B begins counting as soon as it is enabled.
1: If Timer B is enabled (TBEN is set in the GPTMCTL register), Timer B does not begin counting until it receives a trigger from the timer in the previous position in the daisy-chain.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TBMIE</name>
              <description>[5:5] GPTM Timer B match interrupt enable
0: The match interrupt is disabled.
1: An interrupt is generated when the match value in the GPTMTBMATCHR register is reached in the one-shot and periodic
modes.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TBCDIR</name>
              <description>[4:4] GPTM Timer B count direction
0: The timer counts down.
1: The timer counts up. When counting up, the timer starts from a value of 0x0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TBAMS</name>
              <description>[3:3] GPTM Timer B alternate mode
0: Capture mode is enabled.
1: PWM mode is enabled.
Note: To enable PWM mode, the TBCM bit must be cleared and the
TBMR field must be configured to 0x2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>TBCMR</name>
              <description>[2:2] GPTM Timer B capture mode
0: Edge-count mode
1: Edge-time mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TBMR</name>
              <description>[1:0] GPTM Timer B mode
0x0: Reserved
0x1: One-shot timer mode
0x2: Periodic timer mode
0x3: Capture mode
The timer mode is based on the timer configuration defined by bits [2:0] in the GPTMCFG register.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>GPTM control
This register is used alongside the CFG and TnMR registers to fine-tune the timer configuration, and to enable other features such as timer stall.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:15] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>17</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>TBPWML</name>
              <description>[14:14] GPTM Timer B PWM output level
0: Output is unaffected.
1: Output is inverted.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>TBOTE</name>
              <description>[13:13] GPTM Timer B output trigger enable
0: The ADC trigger of output Timer B is disabled.
1: The ADC trigger of output Timer B is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>Reserved13</name>
              <description>[12:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBEVENT</name>
              <description>[11:10] GPTM Timer B event mode
0x0: Positive edge
0x1: Negative edge
0x2: Reserved
0x3: Both edges</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>TBSTALL</name>
              <description>[9:9] GPTM Timer B stall enable
0: Timer B continues counting while the processor is halted by the debugger.
1: Timer B freezes counting while the processor is halted by the debugger.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBEN</name>
              <description>[8:8] GPTM Timer B enable
0: Timer B is disabled.
1: Timer B is enabled and begins counting or the capture logic is enabled based on the GPTMCFG register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:7] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TAPWML</name>
              <description>[6:6] GPTM Timer A PWM output level
0: Output is unaffected.
1: Output is inverted.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TAOTE</name>
              <description>[5:5] GPTM Timer A output trigger enable
0: The ADC trigger of output Timer A is disabled.
1: The ADC trigger of output Timer A is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>Reserved4</name>
              <description>[4:4] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TAEVENT</name>
              <description>[3:2] GPTM Timer A event mode
0x0: Positive edge
0x1: Negative edge
0x2: Reserved
0x3: Both edges</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TASTALL</name>
              <description>[1:1] GPTM Timer A stall enable
0: Timer A continues counting while the processor is halted by the debugger.
1: Timer A freezes counting while the processor is halted by the debugger.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TAEN</name>
              <description>[0:0] GPTM Timer A enable
0: Timer A is disabled.
1: Timer A is enabled and begins counting or the capture logic is enabled based on the GPTMCFG register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYNC</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>GPTM synchronize
Note: This register is implemented on GPTM 0 base address only.
This register does however, allow software to synchronize a number of timers.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SYNC3</name>
              <description>[7:6] Synchronize GPTM3
0x0: GPTM3 is not affected.
0x1: A time-out event for Timer A of GPTM3 is triggered.
0x2: A time-out event for Timer B of GPTM3 is triggered.
0x3: A time-out event for Timer A and Timer B of GPTM3 is triggered.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SYNC2</name>
              <description>[5:4] Synchronize GPTM2
0x0: GPTM2 is not affected.
0x1: A time-out event for Timer A of GPTM2 is triggered.
0x2: A time-out event for Timer B of GPTM2 is triggered.
0x3: A time-out event for Timer A and Timer B of GPTM2 is triggered.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SYNC1</name>
              <description>[3:2] Synchronize GPTM1
0x0: GPTM1 is not affected.
0x1: A time-out event for Timer A of GPTM1 is triggered.
0x2: A time-out event for Timer B of GPTM1 is triggered.
0x3: A time-out event for Timer A and Timer B of GPTM1 is triggered.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SYNC0</name>
              <description>[1:0] Synchronize GPTM0
0x0: GPTM0 is not affected.
0x1: A time-out event for Timer A of GPTM0 is triggered.
0x2: A time-out event for Timer B of GPTM0 is triggered.
0x3: A time-out event for Timer A and Timer B of GPTM0 is triggered.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IMR</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>GPTM interrupt mask
This register allows software to enable and disable GPTM controller-level interrupts. Setting a bit enables the corresponding interrupt, while clearing a bit disables it.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMIM</name>
              <description>[11:11] GPTM Timer B match interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBEIM</name>
              <description>[10:10] GPTM Timer B capture event interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMIM</name>
              <description>[9:9] GPTM Timer B capture match interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTOIM</name>
              <description>[8:8] GPTM Timer B time-out interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:5] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMIM</name>
              <description>[4:4] GPTM Timer A match interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAEIM</name>
              <description>[2:2] GPTM Timer A capture event interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMIM</name>
              <description>[1:1] GPTM Timer A capture match interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATOIM</name>
              <description>[0:0] GPTM Timer A time-out interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>GPTM raw interrupt status
This register shows the state of the GPTM internal interrupt signal. These bits are set whether or not the interrupt is masked in the IMR register. Each bit can be cleared by writing 1 to its corresponding bit in ICR.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMRIS</name>
              <description>[11:11] GPTM Timer B match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBERIS</name>
              <description>[10:10] GPTM Timer B capture event raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMRIS</name>
              <description>[9:9] GPTM Timer B capture match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTORIS</name>
              <description>[8:8] GPTM Timer B time-out raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:5] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMRIS</name>
              <description>[4:4] GPTM Timer A match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:3] Reserved</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAERIS</name>
              <description>[2:2] GPTM Timer A capture event raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMRIS</name>
              <description>[1:1] GPTM Timer A capture match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATORIS</name>
              <description>[0:0] GPTM Timer A time-out raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>GPTM masked interrupt status
This register shows the state of the GPTM controller-level interrupt. If an interrupt is unmasked in IMR, and there is an event that causes the interrupt to be asserted, the corresponding bit is set in this register. All bits are cleared by writing 1 to the corresponding bit in ICR.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMMIS</name>
              <description>[11:11] GPTM Timer B match masked interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBEMIS</name>
              <description>[10:10] GPTM Timer B capture event masked interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMMIS</name>
              <description>[9:9] GPTM Timer B capture match masked interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTOMIS</name>
              <description>[8:8] GPTM Timer B time-out masked interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:5] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMRIS</name>
              <description>[4:4] GPTM Timer A match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:3] Reserved</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAEMIS</name>
              <description>[2:2] GPTM Timer A capture event raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMMIS</name>
              <description>[1:1] GPTM Timer A capture match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATOMIS</name>
              <description>[0:0] GPTM Timer A time-out raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>GPTM interrupt clear
This register is used to clear the status bits in the RIS and MIS registers. Writing 1 to a bit clears the corresponding bit in the RIS and MIS registers.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:17] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>15</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>WUECINT</name>
              <description>[16:16] GPTM write update error interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved16</name>
              <description>[15:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMCINT</name>
              <description>[11:11] GPTM Timer B match interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBECINT</name>
              <description>[10:10] GPTM Timer B capture event Interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMCINT</name>
              <description>[9:9] GPTM Timer B capture match interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTOCINT</name>
              <description>[8:8] GPTM Timer B time-out interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:5] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMCINT</name>
              <description>[4:4] GPTM Timer A match interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAECINT</name>
              <description>[2:2] GPTM Timer A capture event Interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMCINT</name>
              <description>[1:1] GPTM Timer A capture match interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATOCINT</name>
              <description>[0:0] GPTM Timer A time-out interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAILR</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>GPTM Timer A interval load
When the Timer is counting down, this register is used to load the starting count value into the Timer. When the Timer is counting up, this register sets the upper bound for the timeout event.
When a GPTM is configured to one of the 32-bit modes, TAILR appears as a 32-bit register (the upper 16-bits correspond to the contents of the GPTM Timer B Interval Load (TBILR) register). In a 16-bit mode, the upper 16 bits of this register read as 0s and have no effect on the state of TBILR.</description>
          <fields>
            <field>
              <name>TAILR</name>
              <description>[31:0] GPTM A interval load register</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBILR</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>GPTM Timer B interval load
When the Timer is counting down, this register is used to load the starting count value into the Timer. When the Timer is counting up, this register sets the upper bound for the time-out event.
When a GPTM is configured to one of the 32-bit modes, the contents of bits [15:0] in this register are loaded into the upper 16 bits of the TAILR register. Reads from this register return the current value of Timer B and writes are ignored. In a 16-bit mode, bits [15:0] are used for the load value. Bits [31:16] are reserved in both cases.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TBILR</name>
              <description>[15:0] GPTM B interval load register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAMATCHR</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>GPTM Timer A match
This register is loaded with a match value. Interrupts can be generated when the Timer value is equal to the value in this register in one-shot or periodic mode.
When a GPTM is configured to one of the 32-bit modes, TAMATCHR appears as a 32-bit register (the upper 16-bits correspond to the contents of the GPTM Timer B match (GPTMTBMATCHR) register). In a 16-bit mode, the upper 16 bits of this register read as 0s and have no effect on the state of TBMATCHR.</description>
          <fields>
            <field>
              <name>TAMR</name>
              <description>[31:0] GPTM Timer A match register</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBMATCHR</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>PTM Timer B match
This register is loaded with a match value. Interrupts can be generated when the Timer value is equal to the value in this register in one-shot or periodic mode.
When a GPTM is configured to one of the 32-bit modes, the contents of bits [15:0] in this register are loaded into the upper 16 bits of the TAMATCHR register. Reads from this register return the current match value of Timer B and writes are ignored. In a 16-bit mode, bits [15:0] are used for the match value. Bits [31:16] are reserved in both cases.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TBMR</name>
              <description>[15:0] GPTM Timer B match register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPR</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>GPTM Timer A prescale
This register allows software to extend the range of the 16-bit Timers in periodic and one-shot modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSR</name>
              <description>[7:0] GPTM Timer A prescale</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPR</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>GPTM Timer B prescale
This register allows software to extend the range of the 16-bit Timers in periodic and one-shot modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSR</name>
              <description>[7:0] GPTM Timer B prescale</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPMR</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>GPTM Timer A prescale match
This register effectively extends the range of TAMATCHR to 24 bits when operating in 16-bit, one-shot or periodic mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSR</name>
              <description>[7:0] GPTM Timer A prescale match</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPMR</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>GPTM Timer B prescale match
This register effectively extends the range ofMTBMATCHR to 24 bits when operating in 16-bit, one-shot or periodic mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSR</name>
              <description>[7:0] GPTM Timer B prescale match</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAR</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>GPTM Timer A
This register shows the current value of the Timer A counter.
When a GPTM is configured to one of the 32-bit modes, TAR appears as a 32-bit register (the upper 16-bits correspond to the contents of the GPTM Timer B (TBR) register). In the16-bit Input edge count, input edge time, and PWM modes, bits [15:0] contain the value of the counter and bits 23:16 contain the value of the prescaler, which is the upper 8 bits of the count. Bits [31:24] always read as 0. To read the value of the prescaler in 16-bit, one-shot and periodic modes, read bits [23:16] in the TAV register.</description>
          <fields>
            <field>
              <name>TAR</name>
              <description>[31:0] GPTM Timer A register</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBR</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>GPTM Timer B
This register shows the current value of the Timer B counter.
When a GPTM is configured to one of the 32-bit modes, the contents of bits [15:0] in this register are loaded into the upper 16 bits of the TAR register. Reads from this register return the current value of Timer B. In a 16-bit mode, bits 15:0 contain the value of the counter and bits [23:16] contain the value of the prescaler in Input edge count, input edge time, and PWM modes, which is the upper 8 bits of the count. Bits [31:24] always read as 0. To read the value of the prescaler in 16-bit, one-shot and periodic modes, read bits [23:16] in the TBV register.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TBR</name>
              <description>[15:0] GPTM Timer B register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAV</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>GPTM Timer A value
When read, this register shows the current, free-running value of Timer A in all modes. Software can use this value to determine the time elapsed between an interrupt and the ISR entry when using the snapshot feature with the periodic operating mode. When written, the value written into this register is loaded into the TAR register on the next clock cycle.
When a GPTM is configured to one of the 32-bit modes, TAV appears as a 32-bit register (the upper 16-bits correspond to the contents of the GPTM Timer B Value (TBV) register). In a 16-bit mode, bits [15:0] contain the value of the counter and bits [23:16] contain the current, free-running value of the prescaler, which is the upper 8 bits of the count in input edge count, input edge time, PWM and one-shot or periodic up count modes. In one-shot or periodic down count modes, the prescaler stored in [23:16] is a true prescaler, meaning bits [23:16] count down before decrementing the value in bits [15:0]. The prescaler its [31:24] always read as 0.</description>
          <fields>
            <field>
              <name>TAV</name>
              <description>[31:0] GPTM Timer A register</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBV</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>GPTM Timer B value
When read, this register shows the current, free-running value of Timer B in all modes. Software can use this value to determine the time elapsed between an interrupt and the ISR entry. When written, the value written into this register is loaded into the TBR register on the next clock cycle.
When a GPTM is configured to one of the 32-bit modes, the contents of bits 15:0 in this register are loaded into the upper 16 bits of the TAV register. Reads from this register return the current free-running value of Timer B. In a 16-bit mode, bits [15:0] contain the value of the counter and bits [23:16] contain the current, free-running value of the prescaler, which is the upper 8 bits of the count in input edge count, input edge time, PWM and one-shot or periodic up count modes. In one-shot or periodic down count modes, the prescaler stored in [23:16] is a true prescaler, meaning bits [23:16] count down before decrementing the value in bits [15:0]. The prescaler its [31:24] always read as 0.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:24] GPTM Timer B register</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PRE</name>
              <description>[23:16] GPTM Timer B prescale register (16-bit mode)</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TBV</name>
              <description>[15:0] GPTM Timer B register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPS</name>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <description>GPTM Timer A prescale snapshot
For the 32-bit wide GPTM, this register shows the current value of the Timer A prescaler in the 32-bit modes. This register is ununsed in 16-bit GPTM mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PSS</name>
              <description>[15:0] GPTM Timer A prescaler</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPS</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>GPTM Timer B prescale snapshot
For the 32-bit wide GPTM, this register shows the current value of the Timer B prescaler in the 32-bit modes. This register is ununsed in 16-bit GPTM mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PSS</name>
              <description>[15:0] GPTM Timer B prescaler</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPV</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>GPTM Timer A prescale value
For the 32-bit wide GPTM, this register shows the current free-running value of the Timer A prescaler in the 32-bit modes. Software can use this value in conjunction with the TAV register to determine the time elapsed between an interrupt and the ISR entry. This register is ununsed in 16- or 32-bit GPTM mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PSV</name>
              <description>[15:0] GPTM Timer A prescaler value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPV</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>GPTM Timer B prescale value
For the 32-bit wide GPTM, this register shows the current free-running value of the Timer B prescaler in the 32-bit modes. Software can use this value in conjunction with the TBV register to determine the time elapsed between an interrupt and the ISR entry. This register is ununsed in 16- or 32-bit GPTM mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PSV</name>
              <description>[15:0] GPTM Timer B prescaler value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PP</name>
          <addressOffset>0xfc0</addressOffset>
          <size>32</size>
          <description>GPTM peripheral properties
The PP register provides information regarding the properties of the general-purpose Timer module.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:7] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>ALTCLK</name>
              <description>[6:6] Alternate clock source
0: Timer is not capable of using an alternate clock.
1: Timer is capable of using an alternate clock.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SYNCNT</name>
              <description>[5:5] Synchronized start
0: Timer is not capable of synchronizing the count value with other timers.
1: Timer is capable of synchronizing the count value with other timers.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>CHAIN</name>
              <description>[4:4] Chain with other timers
0: Timer is not capable of chaining with previously numbered Timers.
1: Timer is capable of chaining with previously numbered timers.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SIZE</name>
              <description>[3:0] Timer size
0: Timer A and Timer B are 16 bits wide with 8-bit prescale.
1: Timer A and Timer B are 32 bits wide with 16-bit prescale.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPTIMER1</name>
      <baseAddress>0x40031000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00001000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>CFG</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>GPTM configuration
This register configures the global operation of the GPTM. The value written to this register determines whether the GPTM is in 32-bit mode (concatenated timers) or in 16-bit mode (individual, split timers).</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>GPTMCFG</name>
              <description>[2:0] GPTM configuration
The GPTMCFG values are defined as follows:
0x0: 32-bit timer configuration.
0x1: 32-bit real-time clock
0x2: Reserved
0x3: Reserved
0x4: 16-bit timer configuration.
The function is controlled by bits [1:0] of GPTMTAMR and GPTMTBMR.
0x5-0x7: Reserved</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAMR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>GPTM Timer A mode
This register configures the GPTM based on the configuration selected in the CFG register.
This register controls the modes for Timer A when it is used individually. When Timer A and Timer B are concatenated, this register controls the modes for both Timer A and Timer B, and the contents of TBMR are ignored.</description>
          <fields>
            <field>
              <name>Reserved12</name>
              <description>[31:12] Reserved</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TAPLO</name>
              <description>[11:11] Legacy PWM operation
0: Legacy operation
1: CCP is set to 1 on time-out.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>TAMRSU</name>
              <description>[10:10] Timer A match register update mode
0: Update GPTMAMATCHR and GPTMAPR if used on the next cycle.
1: Update GPTMAMATCHR and GPTMAPR if used on the next
time-out. If the timer is disabled (TAEN is clear) when this bit is set, GPTMTAMATCHR and GPTMTAPR are updated when the timer is
enabled. If the timer is stalled (TASTALL is set), GPTMTAMATCHR and GPTMTAPR are updated according to the configuration of this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>TAPWMIE</name>
              <description>[9:9] GPTM Timer A PWM interrupt enable
This bit enables interrupts in PWM mode on rising, falling, or both edges of the CCP output.
0: Interrupt is disabled.
1: Interrupt is enabled.
This bit is valid only in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TAILD</name>
              <description>[8:8] GPTM Timer A PWM interval load write
0: Update the GPTMTAR register with the value in the GPTMTAILR register on the next cycle. If the prescaler is used, update the GPTMTAPS register with the value in the GPTMTAPR register on the next cycle.
1: Update the GPTMTAR register with the value in the GPTMTAILR register on the next cycle. If the prescaler is used, update the GPTMTAPS register with the value in the GPTMTAPR register on the next time-out.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TASNAPS</name>
              <description>[7:7] GPTM Timer A snap-shot mode
0: Snap-shot mode is disabled.
1: If Timer A is configured in periodic mode, the actual free-running value of Timer A is loaded at the time-out event into the GPTM Timer A (GPTMTAR) register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TAWOT</name>
              <description>[6:6] GPTM Timer A wait-on-trigger
0: Timer A begins counting as soon as it is enabled.
1: If Timer A is enabled (TAEN is set in the GPTMCTL register), Timer A does not begin counting until it receives a trigger from the Timer in the previous position in the daisy-chain. This bit must be clear for GP Timer module 0, Timer A.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TAMIE</name>
              <description>[5:5] GPTM Timer A match interrupt enable
0: The match interrupt is disabled.
1: An interrupt is generated when the match value in the GPTMTAMATCHR register is reached in the one-shot and periodic
modes.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TACDIR</name>
              <description>[4:4] GPTM Timer A count direction
0: The timer counts down.
1: The timer counts up. When counting up, the timer starts from a value of 0x0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TAAMS</name>
              <description>[3:3] GPTM Timer A alternate mode
0: Capture mode is enabled.
1: PWM mode is enabled.
Note: To enable PWM mode, the TACM bit must be cleared and the TAMR field must be configured to 0x2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>TACMR</name>
              <description>[2:2] GPTM Timer A capture mode
0: Edge-count mode
1: Edge-time mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TAMR</name>
              <description>[1:0] GPTM Timer A mode
0x0: Reserved
0x1: One-shot mode
0x2: Periodic mode
0x3: Capture mode
The timer mode is based on the timer configuration defined by bits [2:0] in the GPTMCFG register.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBMR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>GPTM Timer B mode
This register configures the GPTM based on the configuration selected in the CFG register.
This register controls the modes for Timer B when it is used individually. When Timer A and Timer B are concatenated, this register is ignored and TBMR controls the modes for both Timer A and Timer B.</description>
          <fields>
            <field>
              <name>Reserved12</name>
              <description>[31:12] Reserved</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBPLO</name>
              <description>[11:11] Legacy PWM operation
0: Legacy operation
1: CCP is set to 1 on time-out.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>TBMRSU</name>
              <description>[10:10] Timer B match register update mode
0: Update the GPTMBMATCHR and the GPTMBPR, if used on the next cycle.
1: Update the GPTMBMATCHR and the GPTMBPR, if used on the next time-out. If the timer is disabled (TAEN is clear) when this bit is set, GPTMTBMATCHR and GPTMTBPR are updated when the timer is enabled. If the timer is stalled (TBSTALL is set), GPTMTBMATCHR and GPTMTBPR are updated according to the configuration of this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>TBPWMIE</name>
              <description>[9:9] GPTM Timer B PWM interrupt enable
This bit enables interrupts in PWM mode on rising, falling, or both edges of the CCP output.
0: Interrupt is disabled.
1: Interrupt is enabled.
This bit is valid only in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBILD</name>
              <description>[8:8] GPTM Timer B PWM interval load write
0: Update the GPTMTBR register with the value in the GPTMTBILR register on the next cycle. If the prescaler is used, update the GPTMTBPS register with the value in the GPTMTBPR register on the next cycle.
1: Update the GPTMTBR register with the value in the GPTMTBILR register on the next cycle. If the prescaler is used, update the GPTMTBPS register with the value in the GPTMTBPR register on the next time-out.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBSNAPS</name>
              <description>[7:7] GPTM Timer B snap-shot mode
0: Snap-shot mode is disabled.
1: If Timer B is configured in the periodic mode, the actual free-running value of Timer A is loaded into the GPTM Timer B (GPTMTBR) register at the time-out event.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TBWOT</name>
              <description>[6:6] GPTM Timer B wait-on-trigger
0: Timer B begins counting as soon as it is enabled.
1: If Timer B is enabled (TBEN is set in the GPTMCTL register), Timer B does not begin counting until it receives a trigger from the timer in the previous position in the daisy-chain.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TBMIE</name>
              <description>[5:5] GPTM Timer B match interrupt enable
0: The match interrupt is disabled.
1: An interrupt is generated when the match value in the GPTMTBMATCHR register is reached in the one-shot and periodic
modes.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TBCDIR</name>
              <description>[4:4] GPTM Timer B count direction
0: The timer counts down.
1: The timer counts up. When counting up, the timer starts from a value of 0x0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TBAMS</name>
              <description>[3:3] GPTM Timer B alternate mode
0: Capture mode is enabled.
1: PWM mode is enabled.
Note: To enable PWM mode, the TBCM bit must be cleared and the
TBMR field must be configured to 0x2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>TBCMR</name>
              <description>[2:2] GPTM Timer B capture mode
0: Edge-count mode
1: Edge-time mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TBMR</name>
              <description>[1:0] GPTM Timer B mode
0x0: Reserved
0x1: One-shot timer mode
0x2: Periodic timer mode
0x3: Capture mode
The timer mode is based on the timer configuration defined by bits [2:0] in the GPTMCFG register.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>GPTM control
This register is used alongside the CFG and TnMR registers to fine-tune the timer configuration, and to enable other features such as timer stall.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:15] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>17</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>TBPWML</name>
              <description>[14:14] GPTM Timer B PWM output level
0: Output is unaffected.
1: Output is inverted.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>TBOTE</name>
              <description>[13:13] GPTM Timer B output trigger enable
0: The ADC trigger of output Timer B is disabled.
1: The ADC trigger of output Timer B is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>Reserved13</name>
              <description>[12:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBEVENT</name>
              <description>[11:10] GPTM Timer B event mode
0x0: Positive edge
0x1: Negative edge
0x2: Reserved
0x3: Both edges</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>TBSTALL</name>
              <description>[9:9] GPTM Timer B stall enable
0: Timer B continues counting while the processor is halted by the debugger.
1: Timer B freezes counting while the processor is halted by the debugger.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBEN</name>
              <description>[8:8] GPTM Timer B enable
0: Timer B is disabled.
1: Timer B is enabled and begins counting or the capture logic is enabled based on the GPTMCFG register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:7] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TAPWML</name>
              <description>[6:6] GPTM Timer A PWM output level
0: Output is unaffected.
1: Output is inverted.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TAOTE</name>
              <description>[5:5] GPTM Timer A output trigger enable
0: The ADC trigger of output Timer A is disabled.
1: The ADC trigger of output Timer A is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>Reserved4</name>
              <description>[4:4] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TAEVENT</name>
              <description>[3:2] GPTM Timer A event mode
0x0: Positive edge
0x1: Negative edge
0x2: Reserved
0x3: Both edges</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TASTALL</name>
              <description>[1:1] GPTM Timer A stall enable
0: Timer A continues counting while the processor is halted by the debugger.
1: Timer A freezes counting while the processor is halted by the debugger.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TAEN</name>
              <description>[0:0] GPTM Timer A enable
0: Timer A is disabled.
1: Timer A is enabled and begins counting or the capture logic is enabled based on the GPTMCFG register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYNC</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>GPTM synchronize
Note: This register is implemented on GPTM 0 base address only.
This register does however, allow software to synchronize a number of timers.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SYNC3</name>
              <description>[7:6] Synchronize GPTM3
0x0: GPTM3 is not affected.
0x1: A time-out event for Timer A of GPTM3 is triggered.
0x2: A time-out event for Timer B of GPTM3 is triggered.
0x3: A time-out event for Timer A and Timer B of GPTM3 is triggered.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SYNC2</name>
              <description>[5:4] Synchronize GPTM2
0x0: GPTM2 is not affected.
0x1: A time-out event for Timer A of GPTM2 is triggered.
0x2: A time-out event for Timer B of GPTM2 is triggered.
0x3: A time-out event for Timer A and Timer B of GPTM2 is triggered.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SYNC1</name>
              <description>[3:2] Synchronize GPTM1
0x0: GPTM1 is not affected.
0x1: A time-out event for Timer A of GPTM1 is triggered.
0x2: A time-out event for Timer B of GPTM1 is triggered.
0x3: A time-out event for Timer A and Timer B of GPTM1 is triggered.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SYNC0</name>
              <description>[1:0] Synchronize GPTM0
0x0: GPTM0 is not affected.
0x1: A time-out event for Timer A of GPTM0 is triggered.
0x2: A time-out event for Timer B of GPTM0 is triggered.
0x3: A time-out event for Timer A and Timer B of GPTM0 is triggered.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IMR</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>GPTM interrupt mask
This register allows software to enable and disable GPTM controller-level interrupts. Setting a bit enables the corresponding interrupt, while clearing a bit disables it.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMIM</name>
              <description>[11:11] GPTM Timer B match interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBEIM</name>
              <description>[10:10] GPTM Timer B capture event interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMIM</name>
              <description>[9:9] GPTM Timer B capture match interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTOIM</name>
              <description>[8:8] GPTM Timer B time-out interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:5] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMIM</name>
              <description>[4:4] GPTM Timer A match interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAEIM</name>
              <description>[2:2] GPTM Timer A capture event interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMIM</name>
              <description>[1:1] GPTM Timer A capture match interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATOIM</name>
              <description>[0:0] GPTM Timer A time-out interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>GPTM raw interrupt status
This register shows the state of the GPTM internal interrupt signal. These bits are set whether or not the interrupt is masked in the IMR register. Each bit can be cleared by writing 1 to its corresponding bit in ICR.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMRIS</name>
              <description>[11:11] GPTM Timer B match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBERIS</name>
              <description>[10:10] GPTM Timer B capture event raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMRIS</name>
              <description>[9:9] GPTM Timer B capture match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTORIS</name>
              <description>[8:8] GPTM Timer B time-out raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:5] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMRIS</name>
              <description>[4:4] GPTM Timer A match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:3] Reserved</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAERIS</name>
              <description>[2:2] GPTM Timer A capture event raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMRIS</name>
              <description>[1:1] GPTM Timer A capture match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATORIS</name>
              <description>[0:0] GPTM Timer A time-out raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>GPTM masked interrupt status
This register shows the state of the GPTM controller-level interrupt. If an interrupt is unmasked in IMR, and there is an event that causes the interrupt to be asserted, the corresponding bit is set in this register. All bits are cleared by writing 1 to the corresponding bit in ICR.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMMIS</name>
              <description>[11:11] GPTM Timer B match masked interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBEMIS</name>
              <description>[10:10] GPTM Timer B capture event masked interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMMIS</name>
              <description>[9:9] GPTM Timer B capture match masked interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTOMIS</name>
              <description>[8:8] GPTM Timer B time-out masked interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:5] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMRIS</name>
              <description>[4:4] GPTM Timer A match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:3] Reserved</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAEMIS</name>
              <description>[2:2] GPTM Timer A capture event raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMMIS</name>
              <description>[1:1] GPTM Timer A capture match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATOMIS</name>
              <description>[0:0] GPTM Timer A time-out raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>GPTM interrupt clear
This register is used to clear the status bits in the RIS and MIS registers. Writing 1 to a bit clears the corresponding bit in the RIS and MIS registers.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:17] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>15</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>WUECINT</name>
              <description>[16:16] GPTM write update error interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved16</name>
              <description>[15:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMCINT</name>
              <description>[11:11] GPTM Timer B match interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBECINT</name>
              <description>[10:10] GPTM Timer B capture event Interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMCINT</name>
              <description>[9:9] GPTM Timer B capture match interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTOCINT</name>
              <description>[8:8] GPTM Timer B time-out interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:5] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMCINT</name>
              <description>[4:4] GPTM Timer A match interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAECINT</name>
              <description>[2:2] GPTM Timer A capture event Interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMCINT</name>
              <description>[1:1] GPTM Timer A capture match interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATOCINT</name>
              <description>[0:0] GPTM Timer A time-out interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAILR</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>GPTM Timer A interval load
When the Timer is counting down, this register is used to load the starting count value into the Timer. When the Timer is counting up, this register sets the upper bound for the timeout event.
When a GPTM is configured to one of the 32-bit modes, TAILR appears as a 32-bit register (the upper 16-bits correspond to the contents of the GPTM Timer B Interval Load (TBILR) register). In a 16-bit mode, the upper 16 bits of this register read as 0s and have no effect on the state of TBILR.</description>
          <fields>
            <field>
              <name>TAILR</name>
              <description>[31:0] GPTM A interval load register</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBILR</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>GPTM Timer B interval load
When the Timer is counting down, this register is used to load the starting count value into the Timer. When the Timer is counting up, this register sets the upper bound for the time-out event.
When a GPTM is configured to one of the 32-bit modes, the contents of bits [15:0] in this register are loaded into the upper 16 bits of the TAILR register. Reads from this register return the current value of Timer B and writes are ignored. In a 16-bit mode, bits [15:0] are used for the load value. Bits [31:16] are reserved in both cases.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TBILR</name>
              <description>[15:0] GPTM B interval load register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAMATCHR</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>GPTM Timer A match
This register is loaded with a match value. Interrupts can be generated when the Timer value is equal to the value in this register in one-shot or periodic mode.
When a GPTM is configured to one of the 32-bit modes, TAMATCHR appears as a 32-bit register (the upper 16-bits correspond to the contents of the GPTM Timer B match (GPTMTBMATCHR) register). In a 16-bit mode, the upper 16 bits of this register read as 0s and have no effect on the state of TBMATCHR.</description>
          <fields>
            <field>
              <name>TAMR</name>
              <description>[31:0] GPTM Timer A match register</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBMATCHR</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>PTM Timer B match
This register is loaded with a match value. Interrupts can be generated when the Timer value is equal to the value in this register in one-shot or periodic mode.
When a GPTM is configured to one of the 32-bit modes, the contents of bits [15:0] in this register are loaded into the upper 16 bits of the TAMATCHR register. Reads from this register return the current match value of Timer B and writes are ignored. In a 16-bit mode, bits [15:0] are used for the match value. Bits [31:16] are reserved in both cases.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TBMR</name>
              <description>[15:0] GPTM Timer B match register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPR</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>GPTM Timer A prescale
This register allows software to extend the range of the 16-bit Timers in periodic and one-shot modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSR</name>
              <description>[7:0] GPTM Timer A prescale</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPR</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>GPTM Timer B prescale
This register allows software to extend the range of the 16-bit Timers in periodic and one-shot modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSR</name>
              <description>[7:0] GPTM Timer B prescale</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPMR</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>GPTM Timer A prescale match
This register effectively extends the range of TAMATCHR to 24 bits when operating in 16-bit, one-shot or periodic mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSR</name>
              <description>[7:0] GPTM Timer A prescale match</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPMR</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>GPTM Timer B prescale match
This register effectively extends the range ofMTBMATCHR to 24 bits when operating in 16-bit, one-shot or periodic mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSR</name>
              <description>[7:0] GPTM Timer B prescale match</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAR</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>GPTM Timer A
This register shows the current value of the Timer A counter.
When a GPTM is configured to one of the 32-bit modes, TAR appears as a 32-bit register (the upper 16-bits correspond to the contents of the GPTM Timer B (TBR) register). In the16-bit Input edge count, input edge time, and PWM modes, bits [15:0] contain the value of the counter and bits 23:16 contain the value of the prescaler, which is the upper 8 bits of the count. Bits [31:24] always read as 0. To read the value of the prescaler in 16-bit, one-shot and periodic modes, read bits [23:16] in the TAV register.</description>
          <fields>
            <field>
              <name>TAR</name>
              <description>[31:0] GPTM Timer A register</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBR</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>GPTM Timer B
This register shows the current value of the Timer B counter.
When a GPTM is configured to one of the 32-bit modes, the contents of bits [15:0] in this register are loaded into the upper 16 bits of the TAR register. Reads from this register return the current value of Timer B. In a 16-bit mode, bits 15:0 contain the value of the counter and bits [23:16] contain the value of the prescaler in Input edge count, input edge time, and PWM modes, which is the upper 8 bits of the count. Bits [31:24] always read as 0. To read the value of the prescaler in 16-bit, one-shot and periodic modes, read bits [23:16] in the TBV register.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TBR</name>
              <description>[15:0] GPTM Timer B register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAV</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>GPTM Timer A value
When read, this register shows the current, free-running value of Timer A in all modes. Software can use this value to determine the time elapsed between an interrupt and the ISR entry when using the snapshot feature with the periodic operating mode. When written, the value written into this register is loaded into the TAR register on the next clock cycle.
When a GPTM is configured to one of the 32-bit modes, TAV appears as a 32-bit register (the upper 16-bits correspond to the contents of the GPTM Timer B Value (TBV) register). In a 16-bit mode, bits [15:0] contain the value of the counter and bits [23:16] contain the current, free-running value of the prescaler, which is the upper 8 bits of the count in input edge count, input edge time, PWM and one-shot or periodic up count modes. In one-shot or periodic down count modes, the prescaler stored in [23:16] is a true prescaler, meaning bits [23:16] count down before decrementing the value in bits [15:0]. The prescaler its [31:24] always read as 0.</description>
          <fields>
            <field>
              <name>TAV</name>
              <description>[31:0] GPTM Timer A register</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBV</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>GPTM Timer B value
When read, this register shows the current, free-running value of Timer B in all modes. Software can use this value to determine the time elapsed between an interrupt and the ISR entry. When written, the value written into this register is loaded into the TBR register on the next clock cycle.
When a GPTM is configured to one of the 32-bit modes, the contents of bits 15:0 in this register are loaded into the upper 16 bits of the TAV register. Reads from this register return the current free-running value of Timer B. In a 16-bit mode, bits [15:0] contain the value of the counter and bits [23:16] contain the current, free-running value of the prescaler, which is the upper 8 bits of the count in input edge count, input edge time, PWM and one-shot or periodic up count modes. In one-shot or periodic down count modes, the prescaler stored in [23:16] is a true prescaler, meaning bits [23:16] count down before decrementing the value in bits [15:0]. The prescaler its [31:24] always read as 0.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:24] GPTM Timer B register</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PRE</name>
              <description>[23:16] GPTM Timer B prescale register (16-bit mode)</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TBV</name>
              <description>[15:0] GPTM Timer B register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPS</name>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <description>GPTM Timer A prescale snapshot
For the 32-bit wide GPTM, this register shows the current value of the Timer A prescaler in the 32-bit modes. This register is ununsed in 16-bit GPTM mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PSS</name>
              <description>[15:0] GPTM Timer A prescaler</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPS</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>GPTM Timer B prescale snapshot
For the 32-bit wide GPTM, this register shows the current value of the Timer B prescaler in the 32-bit modes. This register is ununsed in 16-bit GPTM mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PSS</name>
              <description>[15:0] GPTM Timer B prescaler</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPV</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>GPTM Timer A prescale value
For the 32-bit wide GPTM, this register shows the current free-running value of the Timer A prescaler in the 32-bit modes. Software can use this value in conjunction with the TAV register to determine the time elapsed between an interrupt and the ISR entry. This register is ununsed in 16- or 32-bit GPTM mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PSV</name>
              <description>[15:0] GPTM Timer A prescaler value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPV</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>GPTM Timer B prescale value
For the 32-bit wide GPTM, this register shows the current free-running value of the Timer B prescaler in the 32-bit modes. Software can use this value in conjunction with the TBV register to determine the time elapsed between an interrupt and the ISR entry. This register is ununsed in 16- or 32-bit GPTM mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PSV</name>
              <description>[15:0] GPTM Timer B prescaler value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PP</name>
          <addressOffset>0xfc0</addressOffset>
          <size>32</size>
          <description>GPTM peripheral properties
The PP register provides information regarding the properties of the general-purpose Timer module.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:7] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>ALTCLK</name>
              <description>[6:6] Alternate clock source
0: Timer is not capable of using an alternate clock.
1: Timer is capable of using an alternate clock.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SYNCNT</name>
              <description>[5:5] Synchronized start
0: Timer is not capable of synchronizing the count value with other timers.
1: Timer is capable of synchronizing the count value with other timers.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>CHAIN</name>
              <description>[4:4] Chain with other timers
0: Timer is not capable of chaining with previously numbered Timers.
1: Timer is capable of chaining with previously numbered timers.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SIZE</name>
              <description>[3:0] Timer size
0: Timer A and Timer B are 16 bits wide with 8-bit prescale.
1: Timer A and Timer B are 32 bits wide with 16-bit prescale.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPTIMER2</name>
      <baseAddress>0x40032000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00001000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>CFG</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>GPTM configuration
This register configures the global operation of the GPTM. The value written to this register determines whether the GPTM is in 32-bit mode (concatenated timers) or in 16-bit mode (individual, split timers).</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>GPTMCFG</name>
              <description>[2:0] GPTM configuration
The GPTMCFG values are defined as follows:
0x0: 32-bit timer configuration.
0x1: 32-bit real-time clock
0x2: Reserved
0x3: Reserved
0x4: 16-bit timer configuration.
The function is controlled by bits [1:0] of GPTMTAMR and GPTMTBMR.
0x5-0x7: Reserved</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAMR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>GPTM Timer A mode
This register configures the GPTM based on the configuration selected in the CFG register.
This register controls the modes for Timer A when it is used individually. When Timer A and Timer B are concatenated, this register controls the modes for both Timer A and Timer B, and the contents of TBMR are ignored.</description>
          <fields>
            <field>
              <name>Reserved12</name>
              <description>[31:12] Reserved</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TAPLO</name>
              <description>[11:11] Legacy PWM operation
0: Legacy operation
1: CCP is set to 1 on time-out.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>TAMRSU</name>
              <description>[10:10] Timer A match register update mode
0: Update GPTMAMATCHR and GPTMAPR if used on the next cycle.
1: Update GPTMAMATCHR and GPTMAPR if used on the next
time-out. If the timer is disabled (TAEN is clear) when this bit is set, GPTMTAMATCHR and GPTMTAPR are updated when the timer is
enabled. If the timer is stalled (TASTALL is set), GPTMTAMATCHR and GPTMTAPR are updated according to the configuration of this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>TAPWMIE</name>
              <description>[9:9] GPTM Timer A PWM interrupt enable
This bit enables interrupts in PWM mode on rising, falling, or both edges of the CCP output.
0: Interrupt is disabled.
1: Interrupt is enabled.
This bit is valid only in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TAILD</name>
              <description>[8:8] GPTM Timer A PWM interval load write
0: Update the GPTMTAR register with the value in the GPTMTAILR register on the next cycle. If the prescaler is used, update the GPTMTAPS register with the value in the GPTMTAPR register on the next cycle.
1: Update the GPTMTAR register with the value in the GPTMTAILR register on the next cycle. If the prescaler is used, update the GPTMTAPS register with the value in the GPTMTAPR register on the next time-out.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TASNAPS</name>
              <description>[7:7] GPTM Timer A snap-shot mode
0: Snap-shot mode is disabled.
1: If Timer A is configured in periodic mode, the actual free-running value of Timer A is loaded at the time-out event into the GPTM Timer A (GPTMTAR) register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TAWOT</name>
              <description>[6:6] GPTM Timer A wait-on-trigger
0: Timer A begins counting as soon as it is enabled.
1: If Timer A is enabled (TAEN is set in the GPTMCTL register), Timer A does not begin counting until it receives a trigger from the Timer in the previous position in the daisy-chain. This bit must be clear for GP Timer module 0, Timer A.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TAMIE</name>
              <description>[5:5] GPTM Timer A match interrupt enable
0: The match interrupt is disabled.
1: An interrupt is generated when the match value in the GPTMTAMATCHR register is reached in the one-shot and periodic
modes.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TACDIR</name>
              <description>[4:4] GPTM Timer A count direction
0: The timer counts down.
1: The timer counts up. When counting up, the timer starts from a value of 0x0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TAAMS</name>
              <description>[3:3] GPTM Timer A alternate mode
0: Capture mode is enabled.
1: PWM mode is enabled.
Note: To enable PWM mode, the TACM bit must be cleared and the TAMR field must be configured to 0x2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>TACMR</name>
              <description>[2:2] GPTM Timer A capture mode
0: Edge-count mode
1: Edge-time mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TAMR</name>
              <description>[1:0] GPTM Timer A mode
0x0: Reserved
0x1: One-shot mode
0x2: Periodic mode
0x3: Capture mode
The timer mode is based on the timer configuration defined by bits [2:0] in the GPTMCFG register.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBMR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>GPTM Timer B mode
This register configures the GPTM based on the configuration selected in the CFG register.
This register controls the modes for Timer B when it is used individually. When Timer A and Timer B are concatenated, this register is ignored and TBMR controls the modes for both Timer A and Timer B.</description>
          <fields>
            <field>
              <name>Reserved12</name>
              <description>[31:12] Reserved</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBPLO</name>
              <description>[11:11] Legacy PWM operation
0: Legacy operation
1: CCP is set to 1 on time-out.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>TBMRSU</name>
              <description>[10:10] Timer B match register update mode
0: Update the GPTMBMATCHR and the GPTMBPR, if used on the next cycle.
1: Update the GPTMBMATCHR and the GPTMBPR, if used on the next time-out. If the timer is disabled (TAEN is clear) when this bit is set, GPTMTBMATCHR and GPTMTBPR are updated when the timer is enabled. If the timer is stalled (TBSTALL is set), GPTMTBMATCHR and GPTMTBPR are updated according to the configuration of this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>TBPWMIE</name>
              <description>[9:9] GPTM Timer B PWM interrupt enable
This bit enables interrupts in PWM mode on rising, falling, or both edges of the CCP output.
0: Interrupt is disabled.
1: Interrupt is enabled.
This bit is valid only in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBILD</name>
              <description>[8:8] GPTM Timer B PWM interval load write
0: Update the GPTMTBR register with the value in the GPTMTBILR register on the next cycle. If the prescaler is used, update the GPTMTBPS register with the value in the GPTMTBPR register on the next cycle.
1: Update the GPTMTBR register with the value in the GPTMTBILR register on the next cycle. If the prescaler is used, update the GPTMTBPS register with the value in the GPTMTBPR register on the next time-out.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBSNAPS</name>
              <description>[7:7] GPTM Timer B snap-shot mode
0: Snap-shot mode is disabled.
1: If Timer B is configured in the periodic mode, the actual free-running value of Timer A is loaded into the GPTM Timer B (GPTMTBR) register at the time-out event.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TBWOT</name>
              <description>[6:6] GPTM Timer B wait-on-trigger
0: Timer B begins counting as soon as it is enabled.
1: If Timer B is enabled (TBEN is set in the GPTMCTL register), Timer B does not begin counting until it receives a trigger from the timer in the previous position in the daisy-chain.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TBMIE</name>
              <description>[5:5] GPTM Timer B match interrupt enable
0: The match interrupt is disabled.
1: An interrupt is generated when the match value in the GPTMTBMATCHR register is reached in the one-shot and periodic
modes.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TBCDIR</name>
              <description>[4:4] GPTM Timer B count direction
0: The timer counts down.
1: The timer counts up. When counting up, the timer starts from a value of 0x0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TBAMS</name>
              <description>[3:3] GPTM Timer B alternate mode
0: Capture mode is enabled.
1: PWM mode is enabled.
Note: To enable PWM mode, the TBCM bit must be cleared and the
TBMR field must be configured to 0x2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>TBCMR</name>
              <description>[2:2] GPTM Timer B capture mode
0: Edge-count mode
1: Edge-time mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TBMR</name>
              <description>[1:0] GPTM Timer B mode
0x0: Reserved
0x1: One-shot timer mode
0x2: Periodic timer mode
0x3: Capture mode
The timer mode is based on the timer configuration defined by bits [2:0] in the GPTMCFG register.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>GPTM control
This register is used alongside the CFG and TnMR registers to fine-tune the timer configuration, and to enable other features such as timer stall.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:15] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>17</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>TBPWML</name>
              <description>[14:14] GPTM Timer B PWM output level
0: Output is unaffected.
1: Output is inverted.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>TBOTE</name>
              <description>[13:13] GPTM Timer B output trigger enable
0: The ADC trigger of output Timer B is disabled.
1: The ADC trigger of output Timer B is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>Reserved13</name>
              <description>[12:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBEVENT</name>
              <description>[11:10] GPTM Timer B event mode
0x0: Positive edge
0x1: Negative edge
0x2: Reserved
0x3: Both edges</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>TBSTALL</name>
              <description>[9:9] GPTM Timer B stall enable
0: Timer B continues counting while the processor is halted by the debugger.
1: Timer B freezes counting while the processor is halted by the debugger.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBEN</name>
              <description>[8:8] GPTM Timer B enable
0: Timer B is disabled.
1: Timer B is enabled and begins counting or the capture logic is enabled based on the GPTMCFG register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:7] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TAPWML</name>
              <description>[6:6] GPTM Timer A PWM output level
0: Output is unaffected.
1: Output is inverted.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TAOTE</name>
              <description>[5:5] GPTM Timer A output trigger enable
0: The ADC trigger of output Timer A is disabled.
1: The ADC trigger of output Timer A is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>Reserved4</name>
              <description>[4:4] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TAEVENT</name>
              <description>[3:2] GPTM Timer A event mode
0x0: Positive edge
0x1: Negative edge
0x2: Reserved
0x3: Both edges</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TASTALL</name>
              <description>[1:1] GPTM Timer A stall enable
0: Timer A continues counting while the processor is halted by the debugger.
1: Timer A freezes counting while the processor is halted by the debugger.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TAEN</name>
              <description>[0:0] GPTM Timer A enable
0: Timer A is disabled.
1: Timer A is enabled and begins counting or the capture logic is enabled based on the GPTMCFG register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYNC</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>GPTM synchronize
Note: This register is implemented on GPTM 0 base address only.
This register does however, allow software to synchronize a number of timers.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SYNC3</name>
              <description>[7:6] Synchronize GPTM3
0x0: GPTM3 is not affected.
0x1: A time-out event for Timer A of GPTM3 is triggered.
0x2: A time-out event for Timer B of GPTM3 is triggered.
0x3: A time-out event for Timer A and Timer B of GPTM3 is triggered.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SYNC2</name>
              <description>[5:4] Synchronize GPTM2
0x0: GPTM2 is not affected.
0x1: A time-out event for Timer A of GPTM2 is triggered.
0x2: A time-out event for Timer B of GPTM2 is triggered.
0x3: A time-out event for Timer A and Timer B of GPTM2 is triggered.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SYNC1</name>
              <description>[3:2] Synchronize GPTM1
0x0: GPTM1 is not affected.
0x1: A time-out event for Timer A of GPTM1 is triggered.
0x2: A time-out event for Timer B of GPTM1 is triggered.
0x3: A time-out event for Timer A and Timer B of GPTM1 is triggered.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SYNC0</name>
              <description>[1:0] Synchronize GPTM0
0x0: GPTM0 is not affected.
0x1: A time-out event for Timer A of GPTM0 is triggered.
0x2: A time-out event for Timer B of GPTM0 is triggered.
0x3: A time-out event for Timer A and Timer B of GPTM0 is triggered.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IMR</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>GPTM interrupt mask
This register allows software to enable and disable GPTM controller-level interrupts. Setting a bit enables the corresponding interrupt, while clearing a bit disables it.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMIM</name>
              <description>[11:11] GPTM Timer B match interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBEIM</name>
              <description>[10:10] GPTM Timer B capture event interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMIM</name>
              <description>[9:9] GPTM Timer B capture match interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTOIM</name>
              <description>[8:8] GPTM Timer B time-out interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:5] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMIM</name>
              <description>[4:4] GPTM Timer A match interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAEIM</name>
              <description>[2:2] GPTM Timer A capture event interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMIM</name>
              <description>[1:1] GPTM Timer A capture match interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATOIM</name>
              <description>[0:0] GPTM Timer A time-out interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>GPTM raw interrupt status
This register shows the state of the GPTM internal interrupt signal. These bits are set whether or not the interrupt is masked in the IMR register. Each bit can be cleared by writing 1 to its corresponding bit in ICR.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMRIS</name>
              <description>[11:11] GPTM Timer B match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBERIS</name>
              <description>[10:10] GPTM Timer B capture event raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMRIS</name>
              <description>[9:9] GPTM Timer B capture match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTORIS</name>
              <description>[8:8] GPTM Timer B time-out raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:5] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMRIS</name>
              <description>[4:4] GPTM Timer A match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:3] Reserved</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAERIS</name>
              <description>[2:2] GPTM Timer A capture event raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMRIS</name>
              <description>[1:1] GPTM Timer A capture match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATORIS</name>
              <description>[0:0] GPTM Timer A time-out raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>GPTM masked interrupt status
This register shows the state of the GPTM controller-level interrupt. If an interrupt is unmasked in IMR, and there is an event that causes the interrupt to be asserted, the corresponding bit is set in this register. All bits are cleared by writing 1 to the corresponding bit in ICR.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMMIS</name>
              <description>[11:11] GPTM Timer B match masked interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBEMIS</name>
              <description>[10:10] GPTM Timer B capture event masked interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMMIS</name>
              <description>[9:9] GPTM Timer B capture match masked interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTOMIS</name>
              <description>[8:8] GPTM Timer B time-out masked interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:5] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMRIS</name>
              <description>[4:4] GPTM Timer A match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:3] Reserved</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAEMIS</name>
              <description>[2:2] GPTM Timer A capture event raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMMIS</name>
              <description>[1:1] GPTM Timer A capture match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATOMIS</name>
              <description>[0:0] GPTM Timer A time-out raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>GPTM interrupt clear
This register is used to clear the status bits in the RIS and MIS registers. Writing 1 to a bit clears the corresponding bit in the RIS and MIS registers.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:17] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>15</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>WUECINT</name>
              <description>[16:16] GPTM write update error interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved16</name>
              <description>[15:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMCINT</name>
              <description>[11:11] GPTM Timer B match interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBECINT</name>
              <description>[10:10] GPTM Timer B capture event Interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMCINT</name>
              <description>[9:9] GPTM Timer B capture match interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTOCINT</name>
              <description>[8:8] GPTM Timer B time-out interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:5] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMCINT</name>
              <description>[4:4] GPTM Timer A match interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAECINT</name>
              <description>[2:2] GPTM Timer A capture event Interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMCINT</name>
              <description>[1:1] GPTM Timer A capture match interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATOCINT</name>
              <description>[0:0] GPTM Timer A time-out interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAILR</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>GPTM Timer A interval load
When the Timer is counting down, this register is used to load the starting count value into the Timer. When the Timer is counting up, this register sets the upper bound for the timeout event.
When a GPTM is configured to one of the 32-bit modes, TAILR appears as a 32-bit register (the upper 16-bits correspond to the contents of the GPTM Timer B Interval Load (TBILR) register). In a 16-bit mode, the upper 16 bits of this register read as 0s and have no effect on the state of TBILR.</description>
          <fields>
            <field>
              <name>TAILR</name>
              <description>[31:0] GPTM A interval load register</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBILR</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>GPTM Timer B interval load
When the Timer is counting down, this register is used to load the starting count value into the Timer. When the Timer is counting up, this register sets the upper bound for the time-out event.
When a GPTM is configured to one of the 32-bit modes, the contents of bits [15:0] in this register are loaded into the upper 16 bits of the TAILR register. Reads from this register return the current value of Timer B and writes are ignored. In a 16-bit mode, bits [15:0] are used for the load value. Bits [31:16] are reserved in both cases.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TBILR</name>
              <description>[15:0] GPTM B interval load register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAMATCHR</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>GPTM Timer A match
This register is loaded with a match value. Interrupts can be generated when the Timer value is equal to the value in this register in one-shot or periodic mode.
When a GPTM is configured to one of the 32-bit modes, TAMATCHR appears as a 32-bit register (the upper 16-bits correspond to the contents of the GPTM Timer B match (GPTMTBMATCHR) register). In a 16-bit mode, the upper 16 bits of this register read as 0s and have no effect on the state of TBMATCHR.</description>
          <fields>
            <field>
              <name>TAMR</name>
              <description>[31:0] GPTM Timer A match register</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBMATCHR</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>PTM Timer B match
This register is loaded with a match value. Interrupts can be generated when the Timer value is equal to the value in this register in one-shot or periodic mode.
When a GPTM is configured to one of the 32-bit modes, the contents of bits [15:0] in this register are loaded into the upper 16 bits of the TAMATCHR register. Reads from this register return the current match value of Timer B and writes are ignored. In a 16-bit mode, bits [15:0] are used for the match value. Bits [31:16] are reserved in both cases.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TBMR</name>
              <description>[15:0] GPTM Timer B match register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPR</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>GPTM Timer A prescale
This register allows software to extend the range of the 16-bit Timers in periodic and one-shot modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSR</name>
              <description>[7:0] GPTM Timer A prescale</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPR</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>GPTM Timer B prescale
This register allows software to extend the range of the 16-bit Timers in periodic and one-shot modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSR</name>
              <description>[7:0] GPTM Timer B prescale</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPMR</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>GPTM Timer A prescale match
This register effectively extends the range of TAMATCHR to 24 bits when operating in 16-bit, one-shot or periodic mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSR</name>
              <description>[7:0] GPTM Timer A prescale match</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPMR</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>GPTM Timer B prescale match
This register effectively extends the range ofMTBMATCHR to 24 bits when operating in 16-bit, one-shot or periodic mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSR</name>
              <description>[7:0] GPTM Timer B prescale match</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAR</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>GPTM Timer A
This register shows the current value of the Timer A counter.
When a GPTM is configured to one of the 32-bit modes, TAR appears as a 32-bit register (the upper 16-bits correspond to the contents of the GPTM Timer B (TBR) register). In the16-bit Input edge count, input edge time, and PWM modes, bits [15:0] contain the value of the counter and bits 23:16 contain the value of the prescaler, which is the upper 8 bits of the count. Bits [31:24] always read as 0. To read the value of the prescaler in 16-bit, one-shot and periodic modes, read bits [23:16] in the TAV register.</description>
          <fields>
            <field>
              <name>TAR</name>
              <description>[31:0] GPTM Timer A register</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBR</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>GPTM Timer B
This register shows the current value of the Timer B counter.
When a GPTM is configured to one of the 32-bit modes, the contents of bits [15:0] in this register are loaded into the upper 16 bits of the TAR register. Reads from this register return the current value of Timer B. In a 16-bit mode, bits 15:0 contain the value of the counter and bits [23:16] contain the value of the prescaler in Input edge count, input edge time, and PWM modes, which is the upper 8 bits of the count. Bits [31:24] always read as 0. To read the value of the prescaler in 16-bit, one-shot and periodic modes, read bits [23:16] in the TBV register.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TBR</name>
              <description>[15:0] GPTM Timer B register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAV</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>GPTM Timer A value
When read, this register shows the current, free-running value of Timer A in all modes. Software can use this value to determine the time elapsed between an interrupt and the ISR entry when using the snapshot feature with the periodic operating mode. When written, the value written into this register is loaded into the TAR register on the next clock cycle.
When a GPTM is configured to one of the 32-bit modes, TAV appears as a 32-bit register (the upper 16-bits correspond to the contents of the GPTM Timer B Value (TBV) register). In a 16-bit mode, bits [15:0] contain the value of the counter and bits [23:16] contain the current, free-running value of the prescaler, which is the upper 8 bits of the count in input edge count, input edge time, PWM and one-shot or periodic up count modes. In one-shot or periodic down count modes, the prescaler stored in [23:16] is a true prescaler, meaning bits [23:16] count down before decrementing the value in bits [15:0]. The prescaler its [31:24] always read as 0.</description>
          <fields>
            <field>
              <name>TAV</name>
              <description>[31:0] GPTM Timer A register</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBV</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>GPTM Timer B value
When read, this register shows the current, free-running value of Timer B in all modes. Software can use this value to determine the time elapsed between an interrupt and the ISR entry. When written, the value written into this register is loaded into the TBR register on the next clock cycle.
When a GPTM is configured to one of the 32-bit modes, the contents of bits 15:0 in this register are loaded into the upper 16 bits of the TAV register. Reads from this register return the current free-running value of Timer B. In a 16-bit mode, bits [15:0] contain the value of the counter and bits [23:16] contain the current, free-running value of the prescaler, which is the upper 8 bits of the count in input edge count, input edge time, PWM and one-shot or periodic up count modes. In one-shot or periodic down count modes, the prescaler stored in [23:16] is a true prescaler, meaning bits [23:16] count down before decrementing the value in bits [15:0]. The prescaler its [31:24] always read as 0.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:24] GPTM Timer B register</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PRE</name>
              <description>[23:16] GPTM Timer B prescale register (16-bit mode)</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TBV</name>
              <description>[15:0] GPTM Timer B register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPS</name>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <description>GPTM Timer A prescale snapshot
For the 32-bit wide GPTM, this register shows the current value of the Timer A prescaler in the 32-bit modes. This register is ununsed in 16-bit GPTM mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PSS</name>
              <description>[15:0] GPTM Timer A prescaler</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPS</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>GPTM Timer B prescale snapshot
For the 32-bit wide GPTM, this register shows the current value of the Timer B prescaler in the 32-bit modes. This register is ununsed in 16-bit GPTM mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PSS</name>
              <description>[15:0] GPTM Timer B prescaler</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPV</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>GPTM Timer A prescale value
For the 32-bit wide GPTM, this register shows the current free-running value of the Timer A prescaler in the 32-bit modes. Software can use this value in conjunction with the TAV register to determine the time elapsed between an interrupt and the ISR entry. This register is ununsed in 16- or 32-bit GPTM mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PSV</name>
              <description>[15:0] GPTM Timer A prescaler value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPV</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>GPTM Timer B prescale value
For the 32-bit wide GPTM, this register shows the current free-running value of the Timer B prescaler in the 32-bit modes. Software can use this value in conjunction with the TBV register to determine the time elapsed between an interrupt and the ISR entry. This register is ununsed in 16- or 32-bit GPTM mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PSV</name>
              <description>[15:0] GPTM Timer B prescaler value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PP</name>
          <addressOffset>0xfc0</addressOffset>
          <size>32</size>
          <description>GPTM peripheral properties
The PP register provides information regarding the properties of the general-purpose Timer module.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:7] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>ALTCLK</name>
              <description>[6:6] Alternate clock source
0: Timer is not capable of using an alternate clock.
1: Timer is capable of using an alternate clock.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SYNCNT</name>
              <description>[5:5] Synchronized start
0: Timer is not capable of synchronizing the count value with other timers.
1: Timer is capable of synchronizing the count value with other timers.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>CHAIN</name>
              <description>[4:4] Chain with other timers
0: Timer is not capable of chaining with previously numbered Timers.
1: Timer is capable of chaining with previously numbered timers.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SIZE</name>
              <description>[3:0] Timer size
0: Timer A and Timer B are 16 bits wide with 8-bit prescale.
1: Timer A and Timer B are 32 bits wide with 16-bit prescale.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPTIMER3</name>
      <baseAddress>0x40033000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00001000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>CFG</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>GPTM configuration
This register configures the global operation of the GPTM. The value written to this register determines whether the GPTM is in 32-bit mode (concatenated timers) or in 16-bit mode (individual, split timers).</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>GPTMCFG</name>
              <description>[2:0] GPTM configuration
The GPTMCFG values are defined as follows:
0x0: 32-bit timer configuration.
0x1: 32-bit real-time clock
0x2: Reserved
0x3: Reserved
0x4: 16-bit timer configuration.
The function is controlled by bits [1:0] of GPTMTAMR and GPTMTBMR.
0x5-0x7: Reserved</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAMR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>GPTM Timer A mode
This register configures the GPTM based on the configuration selected in the CFG register.
This register controls the modes for Timer A when it is used individually. When Timer A and Timer B are concatenated, this register controls the modes for both Timer A and Timer B, and the contents of TBMR are ignored.</description>
          <fields>
            <field>
              <name>Reserved12</name>
              <description>[31:12] Reserved</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TAPLO</name>
              <description>[11:11] Legacy PWM operation
0: Legacy operation
1: CCP is set to 1 on time-out.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>TAMRSU</name>
              <description>[10:10] Timer A match register update mode
0: Update GPTMAMATCHR and GPTMAPR if used on the next cycle.
1: Update GPTMAMATCHR and GPTMAPR if used on the next
time-out. If the timer is disabled (TAEN is clear) when this bit is set, GPTMTAMATCHR and GPTMTAPR are updated when the timer is
enabled. If the timer is stalled (TASTALL is set), GPTMTAMATCHR and GPTMTAPR are updated according to the configuration of this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>TAPWMIE</name>
              <description>[9:9] GPTM Timer A PWM interrupt enable
This bit enables interrupts in PWM mode on rising, falling, or both edges of the CCP output.
0: Interrupt is disabled.
1: Interrupt is enabled.
This bit is valid only in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TAILD</name>
              <description>[8:8] GPTM Timer A PWM interval load write
0: Update the GPTMTAR register with the value in the GPTMTAILR register on the next cycle. If the prescaler is used, update the GPTMTAPS register with the value in the GPTMTAPR register on the next cycle.
1: Update the GPTMTAR register with the value in the GPTMTAILR register on the next cycle. If the prescaler is used, update the GPTMTAPS register with the value in the GPTMTAPR register on the next time-out.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TASNAPS</name>
              <description>[7:7] GPTM Timer A snap-shot mode
0: Snap-shot mode is disabled.
1: If Timer A is configured in periodic mode, the actual free-running value of Timer A is loaded at the time-out event into the GPTM Timer A (GPTMTAR) register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TAWOT</name>
              <description>[6:6] GPTM Timer A wait-on-trigger
0: Timer A begins counting as soon as it is enabled.
1: If Timer A is enabled (TAEN is set in the GPTMCTL register), Timer A does not begin counting until it receives a trigger from the Timer in the previous position in the daisy-chain. This bit must be clear for GP Timer module 0, Timer A.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TAMIE</name>
              <description>[5:5] GPTM Timer A match interrupt enable
0: The match interrupt is disabled.
1: An interrupt is generated when the match value in the GPTMTAMATCHR register is reached in the one-shot and periodic
modes.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TACDIR</name>
              <description>[4:4] GPTM Timer A count direction
0: The timer counts down.
1: The timer counts up. When counting up, the timer starts from a value of 0x0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TAAMS</name>
              <description>[3:3] GPTM Timer A alternate mode
0: Capture mode is enabled.
1: PWM mode is enabled.
Note: To enable PWM mode, the TACM bit must be cleared and the TAMR field must be configured to 0x2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>TACMR</name>
              <description>[2:2] GPTM Timer A capture mode
0: Edge-count mode
1: Edge-time mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TAMR</name>
              <description>[1:0] GPTM Timer A mode
0x0: Reserved
0x1: One-shot mode
0x2: Periodic mode
0x3: Capture mode
The timer mode is based on the timer configuration defined by bits [2:0] in the GPTMCFG register.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBMR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>GPTM Timer B mode
This register configures the GPTM based on the configuration selected in the CFG register.
This register controls the modes for Timer B when it is used individually. When Timer A and Timer B are concatenated, this register is ignored and TBMR controls the modes for both Timer A and Timer B.</description>
          <fields>
            <field>
              <name>Reserved12</name>
              <description>[31:12] Reserved</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBPLO</name>
              <description>[11:11] Legacy PWM operation
0: Legacy operation
1: CCP is set to 1 on time-out.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>TBMRSU</name>
              <description>[10:10] Timer B match register update mode
0: Update the GPTMBMATCHR and the GPTMBPR, if used on the next cycle.
1: Update the GPTMBMATCHR and the GPTMBPR, if used on the next time-out. If the timer is disabled (TAEN is clear) when this bit is set, GPTMTBMATCHR and GPTMTBPR are updated when the timer is enabled. If the timer is stalled (TBSTALL is set), GPTMTBMATCHR and GPTMTBPR are updated according to the configuration of this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>TBPWMIE</name>
              <description>[9:9] GPTM Timer B PWM interrupt enable
This bit enables interrupts in PWM mode on rising, falling, or both edges of the CCP output.
0: Interrupt is disabled.
1: Interrupt is enabled.
This bit is valid only in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBILD</name>
              <description>[8:8] GPTM Timer B PWM interval load write
0: Update the GPTMTBR register with the value in the GPTMTBILR register on the next cycle. If the prescaler is used, update the GPTMTBPS register with the value in the GPTMTBPR register on the next cycle.
1: Update the GPTMTBR register with the value in the GPTMTBILR register on the next cycle. If the prescaler is used, update the GPTMTBPS register with the value in the GPTMTBPR register on the next time-out.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBSNAPS</name>
              <description>[7:7] GPTM Timer B snap-shot mode
0: Snap-shot mode is disabled.
1: If Timer B is configured in the periodic mode, the actual free-running value of Timer A is loaded into the GPTM Timer B (GPTMTBR) register at the time-out event.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TBWOT</name>
              <description>[6:6] GPTM Timer B wait-on-trigger
0: Timer B begins counting as soon as it is enabled.
1: If Timer B is enabled (TBEN is set in the GPTMCTL register), Timer B does not begin counting until it receives a trigger from the timer in the previous position in the daisy-chain.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TBMIE</name>
              <description>[5:5] GPTM Timer B match interrupt enable
0: The match interrupt is disabled.
1: An interrupt is generated when the match value in the GPTMTBMATCHR register is reached in the one-shot and periodic
modes.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TBCDIR</name>
              <description>[4:4] GPTM Timer B count direction
0: The timer counts down.
1: The timer counts up. When counting up, the timer starts from a value of 0x0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TBAMS</name>
              <description>[3:3] GPTM Timer B alternate mode
0: Capture mode is enabled.
1: PWM mode is enabled.
Note: To enable PWM mode, the TBCM bit must be cleared and the
TBMR field must be configured to 0x2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>TBCMR</name>
              <description>[2:2] GPTM Timer B capture mode
0: Edge-count mode
1: Edge-time mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TBMR</name>
              <description>[1:0] GPTM Timer B mode
0x0: Reserved
0x1: One-shot timer mode
0x2: Periodic timer mode
0x3: Capture mode
The timer mode is based on the timer configuration defined by bits [2:0] in the GPTMCFG register.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>GPTM control
This register is used alongside the CFG and TnMR registers to fine-tune the timer configuration, and to enable other features such as timer stall.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:15] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>17</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>TBPWML</name>
              <description>[14:14] GPTM Timer B PWM output level
0: Output is unaffected.
1: Output is inverted.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>TBOTE</name>
              <description>[13:13] GPTM Timer B output trigger enable
0: The ADC trigger of output Timer B is disabled.
1: The ADC trigger of output Timer B is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>Reserved13</name>
              <description>[12:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBEVENT</name>
              <description>[11:10] GPTM Timer B event mode
0x0: Positive edge
0x1: Negative edge
0x2: Reserved
0x3: Both edges</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>TBSTALL</name>
              <description>[9:9] GPTM Timer B stall enable
0: Timer B continues counting while the processor is halted by the debugger.
1: Timer B freezes counting while the processor is halted by the debugger.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBEN</name>
              <description>[8:8] GPTM Timer B enable
0: Timer B is disabled.
1: Timer B is enabled and begins counting or the capture logic is enabled based on the GPTMCFG register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:7] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TAPWML</name>
              <description>[6:6] GPTM Timer A PWM output level
0: Output is unaffected.
1: Output is inverted.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TAOTE</name>
              <description>[5:5] GPTM Timer A output trigger enable
0: The ADC trigger of output Timer A is disabled.
1: The ADC trigger of output Timer A is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>Reserved4</name>
              <description>[4:4] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TAEVENT</name>
              <description>[3:2] GPTM Timer A event mode
0x0: Positive edge
0x1: Negative edge
0x2: Reserved
0x3: Both edges</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TASTALL</name>
              <description>[1:1] GPTM Timer A stall enable
0: Timer A continues counting while the processor is halted by the debugger.
1: Timer A freezes counting while the processor is halted by the debugger.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TAEN</name>
              <description>[0:0] GPTM Timer A enable
0: Timer A is disabled.
1: Timer A is enabled and begins counting or the capture logic is enabled based on the GPTMCFG register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SYNC</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>GPTM synchronize
Note: This register is implemented on GPTM 0 base address only.
This register does however, allow software to synchronize a number of timers.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SYNC3</name>
              <description>[7:6] Synchronize GPTM3
0x0: GPTM3 is not affected.
0x1: A time-out event for Timer A of GPTM3 is triggered.
0x2: A time-out event for Timer B of GPTM3 is triggered.
0x3: A time-out event for Timer A and Timer B of GPTM3 is triggered.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SYNC2</name>
              <description>[5:4] Synchronize GPTM2
0x0: GPTM2 is not affected.
0x1: A time-out event for Timer A of GPTM2 is triggered.
0x2: A time-out event for Timer B of GPTM2 is triggered.
0x3: A time-out event for Timer A and Timer B of GPTM2 is triggered.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SYNC1</name>
              <description>[3:2] Synchronize GPTM1
0x0: GPTM1 is not affected.
0x1: A time-out event for Timer A of GPTM1 is triggered.
0x2: A time-out event for Timer B of GPTM1 is triggered.
0x3: A time-out event for Timer A and Timer B of GPTM1 is triggered.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SYNC0</name>
              <description>[1:0] Synchronize GPTM0
0x0: GPTM0 is not affected.
0x1: A time-out event for Timer A of GPTM0 is triggered.
0x2: A time-out event for Timer B of GPTM0 is triggered.
0x3: A time-out event for Timer A and Timer B of GPTM0 is triggered.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IMR</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>GPTM interrupt mask
This register allows software to enable and disable GPTM controller-level interrupts. Setting a bit enables the corresponding interrupt, while clearing a bit disables it.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMIM</name>
              <description>[11:11] GPTM Timer B match interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBEIM</name>
              <description>[10:10] GPTM Timer B capture event interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMIM</name>
              <description>[9:9] GPTM Timer B capture match interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTOIM</name>
              <description>[8:8] GPTM Timer B time-out interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:5] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMIM</name>
              <description>[4:4] GPTM Timer A match interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAEIM</name>
              <description>[2:2] GPTM Timer A capture event interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMIM</name>
              <description>[1:1] GPTM Timer A capture match interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATOIM</name>
              <description>[0:0] GPTM Timer A time-out interrupt mask
0: Interrupt is disabled.
1: Interrupt is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>GPTM raw interrupt status
This register shows the state of the GPTM internal interrupt signal. These bits are set whether or not the interrupt is masked in the IMR register. Each bit can be cleared by writing 1 to its corresponding bit in ICR.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMRIS</name>
              <description>[11:11] GPTM Timer B match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBERIS</name>
              <description>[10:10] GPTM Timer B capture event raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMRIS</name>
              <description>[9:9] GPTM Timer B capture match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTORIS</name>
              <description>[8:8] GPTM Timer B time-out raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:5] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMRIS</name>
              <description>[4:4] GPTM Timer A match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:3] Reserved</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAERIS</name>
              <description>[2:2] GPTM Timer A capture event raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMRIS</name>
              <description>[1:1] GPTM Timer A capture match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATORIS</name>
              <description>[0:0] GPTM Timer A time-out raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>GPTM masked interrupt status
This register shows the state of the GPTM controller-level interrupt. If an interrupt is unmasked in IMR, and there is an event that causes the interrupt to be asserted, the corresponding bit is set in this register. All bits are cleared by writing 1 to the corresponding bit in ICR.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMMIS</name>
              <description>[11:11] GPTM Timer B match masked interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBEMIS</name>
              <description>[10:10] GPTM Timer B capture event masked interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMMIS</name>
              <description>[9:9] GPTM Timer B capture match masked interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTOMIS</name>
              <description>[8:8] GPTM Timer B time-out masked interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:5] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMRIS</name>
              <description>[4:4] GPTM Timer A match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:3] Reserved</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAEMIS</name>
              <description>[2:2] GPTM Timer A capture event raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMMIS</name>
              <description>[1:1] GPTM Timer A capture match raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATOMIS</name>
              <description>[0:0] GPTM Timer A time-out raw interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>GPTM interrupt clear
This register is used to clear the status bits in the RIS and MIS registers. Writing 1 to a bit clears the corresponding bit in the RIS and MIS registers.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:17] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>15</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>WUECINT</name>
              <description>[16:16] GPTM write update error interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved16</name>
              <description>[15:12] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMCINT</name>
              <description>[11:11] GPTM Timer B match interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBECINT</name>
              <description>[10:10] GPTM Timer B capture event Interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMCINT</name>
              <description>[9:9] GPTM Timer B capture match interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTOCINT</name>
              <description>[8:8] GPTM Timer B time-out interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:5] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMCINT</name>
              <description>[4:4] GPTM Timer A match interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAECINT</name>
              <description>[2:2] GPTM Timer A capture event Interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMCINT</name>
              <description>[1:1] GPTM Timer A capture match interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATOCINT</name>
              <description>[0:0] GPTM Timer A time-out interrupt clear</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAILR</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>GPTM Timer A interval load
When the Timer is counting down, this register is used to load the starting count value into the Timer. When the Timer is counting up, this register sets the upper bound for the timeout event.
When a GPTM is configured to one of the 32-bit modes, TAILR appears as a 32-bit register (the upper 16-bits correspond to the contents of the GPTM Timer B Interval Load (TBILR) register). In a 16-bit mode, the upper 16 bits of this register read as 0s and have no effect on the state of TBILR.</description>
          <fields>
            <field>
              <name>TAILR</name>
              <description>[31:0] GPTM A interval load register</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBILR</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>GPTM Timer B interval load
When the Timer is counting down, this register is used to load the starting count value into the Timer. When the Timer is counting up, this register sets the upper bound for the time-out event.
When a GPTM is configured to one of the 32-bit modes, the contents of bits [15:0] in this register are loaded into the upper 16 bits of the TAILR register. Reads from this register return the current value of Timer B and writes are ignored. In a 16-bit mode, bits [15:0] are used for the load value. Bits [31:16] are reserved in both cases.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TBILR</name>
              <description>[15:0] GPTM B interval load register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAMATCHR</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>GPTM Timer A match
This register is loaded with a match value. Interrupts can be generated when the Timer value is equal to the value in this register in one-shot or periodic mode.
When a GPTM is configured to one of the 32-bit modes, TAMATCHR appears as a 32-bit register (the upper 16-bits correspond to the contents of the GPTM Timer B match (GPTMTBMATCHR) register). In a 16-bit mode, the upper 16 bits of this register read as 0s and have no effect on the state of TBMATCHR.</description>
          <fields>
            <field>
              <name>TAMR</name>
              <description>[31:0] GPTM Timer A match register</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBMATCHR</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>PTM Timer B match
This register is loaded with a match value. Interrupts can be generated when the Timer value is equal to the value in this register in one-shot or periodic mode.
When a GPTM is configured to one of the 32-bit modes, the contents of bits [15:0] in this register are loaded into the upper 16 bits of the TAMATCHR register. Reads from this register return the current match value of Timer B and writes are ignored. In a 16-bit mode, bits [15:0] are used for the match value. Bits [31:16] are reserved in both cases.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TBMR</name>
              <description>[15:0] GPTM Timer B match register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPR</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>GPTM Timer A prescale
This register allows software to extend the range of the 16-bit Timers in periodic and one-shot modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSR</name>
              <description>[7:0] GPTM Timer A prescale</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPR</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>GPTM Timer B prescale
This register allows software to extend the range of the 16-bit Timers in periodic and one-shot modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSR</name>
              <description>[7:0] GPTM Timer B prescale</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPMR</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>GPTM Timer A prescale match
This register effectively extends the range of TAMATCHR to 24 bits when operating in 16-bit, one-shot or periodic mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSR</name>
              <description>[7:0] GPTM Timer A prescale match</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPMR</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>GPTM Timer B prescale match
This register effectively extends the range ofMTBMATCHR to 24 bits when operating in 16-bit, one-shot or periodic mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSR</name>
              <description>[7:0] GPTM Timer B prescale match</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAR</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>GPTM Timer A
This register shows the current value of the Timer A counter.
When a GPTM is configured to one of the 32-bit modes, TAR appears as a 32-bit register (the upper 16-bits correspond to the contents of the GPTM Timer B (TBR) register). In the16-bit Input edge count, input edge time, and PWM modes, bits [15:0] contain the value of the counter and bits 23:16 contain the value of the prescaler, which is the upper 8 bits of the count. Bits [31:24] always read as 0. To read the value of the prescaler in 16-bit, one-shot and periodic modes, read bits [23:16] in the TAV register.</description>
          <fields>
            <field>
              <name>TAR</name>
              <description>[31:0] GPTM Timer A register</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBR</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>GPTM Timer B
This register shows the current value of the Timer B counter.
When a GPTM is configured to one of the 32-bit modes, the contents of bits [15:0] in this register are loaded into the upper 16 bits of the TAR register. Reads from this register return the current value of Timer B. In a 16-bit mode, bits 15:0 contain the value of the counter and bits [23:16] contain the value of the prescaler in Input edge count, input edge time, and PWM modes, which is the upper 8 bits of the count. Bits [31:24] always read as 0. To read the value of the prescaler in 16-bit, one-shot and periodic modes, read bits [23:16] in the TBV register.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TBR</name>
              <description>[15:0] GPTM Timer B register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAV</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>GPTM Timer A value
When read, this register shows the current, free-running value of Timer A in all modes. Software can use this value to determine the time elapsed between an interrupt and the ISR entry when using the snapshot feature with the periodic operating mode. When written, the value written into this register is loaded into the TAR register on the next clock cycle.
When a GPTM is configured to one of the 32-bit modes, TAV appears as a 32-bit register (the upper 16-bits correspond to the contents of the GPTM Timer B Value (TBV) register). In a 16-bit mode, bits [15:0] contain the value of the counter and bits [23:16] contain the current, free-running value of the prescaler, which is the upper 8 bits of the count in input edge count, input edge time, PWM and one-shot or periodic up count modes. In one-shot or periodic down count modes, the prescaler stored in [23:16] is a true prescaler, meaning bits [23:16] count down before decrementing the value in bits [15:0]. The prescaler its [31:24] always read as 0.</description>
          <fields>
            <field>
              <name>TAV</name>
              <description>[31:0] GPTM Timer A register</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBV</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>GPTM Timer B value
When read, this register shows the current, free-running value of Timer B in all modes. Software can use this value to determine the time elapsed between an interrupt and the ISR entry. When written, the value written into this register is loaded into the TBR register on the next clock cycle.
When a GPTM is configured to one of the 32-bit modes, the contents of bits 15:0 in this register are loaded into the upper 16 bits of the TAV register. Reads from this register return the current free-running value of Timer B. In a 16-bit mode, bits [15:0] contain the value of the counter and bits [23:16] contain the current, free-running value of the prescaler, which is the upper 8 bits of the count in input edge count, input edge time, PWM and one-shot or periodic up count modes. In one-shot or periodic down count modes, the prescaler stored in [23:16] is a true prescaler, meaning bits [23:16] count down before decrementing the value in bits [15:0]. The prescaler its [31:24] always read as 0.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:24] GPTM Timer B register</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PRE</name>
              <description>[23:16] GPTM Timer B prescale register (16-bit mode)</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TBV</name>
              <description>[15:0] GPTM Timer B register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPS</name>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <description>GPTM Timer A prescale snapshot
For the 32-bit wide GPTM, this register shows the current value of the Timer A prescaler in the 32-bit modes. This register is ununsed in 16-bit GPTM mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PSS</name>
              <description>[15:0] GPTM Timer A prescaler</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPS</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>GPTM Timer B prescale snapshot
For the 32-bit wide GPTM, this register shows the current value of the Timer B prescaler in the 32-bit modes. This register is ununsed in 16-bit GPTM mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PSS</name>
              <description>[15:0] GPTM Timer B prescaler</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TAPV</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>GPTM Timer A prescale value
For the 32-bit wide GPTM, this register shows the current free-running value of the Timer A prescaler in the 32-bit modes. Software can use this value in conjunction with the TAV register to determine the time elapsed between an interrupt and the ISR entry. This register is ununsed in 16- or 32-bit GPTM mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PSV</name>
              <description>[15:0] GPTM Timer A prescaler value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TBPV</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>GPTM Timer B prescale value
For the 32-bit wide GPTM, this register shows the current free-running value of the Timer B prescaler in the 32-bit modes. Software can use this value in conjunction with the TBV register to determine the time elapsed between an interrupt and the ISR entry. This register is ununsed in 16- or 32-bit GPTM mode.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PSV</name>
              <description>[15:0] GPTM Timer B prescaler value</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PP</name>
          <addressOffset>0xfc0</addressOffset>
          <size>32</size>
          <description>GPTM peripheral properties
The PP register provides information regarding the properties of the general-purpose Timer module.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:7] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>ALTCLK</name>
              <description>[6:6] Alternate clock source
0: Timer is not capable of using an alternate clock.
1: Timer is capable of using an alternate clock.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SYNCNT</name>
              <description>[5:5] Synchronized start
0: Timer is not capable of synchronizing the count value with other timers.
1: Timer is capable of synchronizing the count value with other timers.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>CHAIN</name>
              <description>[4:4] Chain with other timers
0: Timer is not capable of chaining with previously numbered Timers.
1: Timer is capable of chaining with previously numbered timers.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SIZE</name>
              <description>[3:0] Timer size
0: Timer A and Timer B are 16 bits wide with 8-bit prescale.
1: Timer A and Timer B are 32 bits wide with 16-bit prescale.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RFCORE_FFSM</name>
      <baseAddress>0x40088500</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00000100</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>SRCRESMASK0</name>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <description>Source address matching result
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SRCRESMASK0</name>
              <description>[7:0] Extended address matching
When there is a match on entry ext_n, bits 2n and 2n + 1 are set in SRCRESMASK.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRCRESMASK1</name>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <description>Source address matching result
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SRCRESMASK1</name>
              <description>[7:0] Short address matching
When there is a match on entry panid_n + short_n, bit n is set in SRCRESMASK.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRCRESMASK2</name>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <description>Source address matching result
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SRCRESMASK2</name>
              <description>[7:0] 24-bit mask that indicates source address match for each individual entry in the source address table</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRCRESINDEX</name>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <description>Source address matching result
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SRCRESINDEX</name>
              <description>[7:0] The bit index of the least-significant entry (0-23 for short addresses or 0-11 for extended addresses) in SRCRESMASK, or 0x3F when there is no source match
On a match, bit 5 is 0 when the match is on a short address and 1 when it is on an extended address.
On a match, bit 6 is 1 when the conditions for automatic pending bit in acknowledgment have been met (see the description of SRCMATCH.AUTOPEND).
The bit does not indicate if the acknowledgment is actually transmitted, and does not consider the PENDING_OR register bit and the SACK/SACKPEND/SNACK strobes.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRCEXTPENDEN0</name>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <description>Source address matching control
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SRCEXTPENDEN0</name>
              <description>[7:0] 8 LSBs of the 24-bit mask that enables or disables automatic pending for each of the 12 extended addresses. Entry n is mapped to SRCEXTPENDEN[2n]. All SRCEXTPENDEN[2n + 1] bits are don't care.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRCEXTPENDEN1</name>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <description>Source address matching control
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SRCEXTPENDEN1</name>
              <description>[7:0] 8 middle bits of the 24-bit mask that enables or disables automatic pending for each of the 12 extended addresses
Entry n is mapped to SRCEXTPENDEN[2n]. All SRCEXTPENDEN[2n + 1] bits are don't care.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRCEXTPENDEN2</name>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <description>Source address matching control
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SRCEXTPENDEN2</name>
              <description>[7:0] 8 MSBs of the 24-bit mask that enables or disables automatic pending for each of the 12 extended addresses
Entry n is mapped to SRCEXTPENDEN[2n]. All SRCEXTPENDEN[2n + 1] bits are don't care.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRCSHORTPENDEN0</name>
          <addressOffset>0x9c</addressOffset>
          <size>32</size>
          <description>Source address matching control
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SRCSHORTPENDEN0</name>
              <description>[7:0] 8 LSBs of the 24-bit mask that enables or disables automatic pending for each of the 24 short addresses</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRCSHORTPENDEN1</name>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <description>Source address matching control
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SRCSHORTPENDEN1</name>
              <description>[7:0] 8 middle bits of the 24-bit mask that enables or disables automatic pending for each of the 24 short addresses</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRCSHORTPENDEN2</name>
          <addressOffset>0xa4</addressOffset>
          <size>32</size>
          <description>Source address matching control
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SRCSHORTPENDEN2</name>
              <description>[7:0] 8 MSBs of the 24-bit mask that enables or disables automatic pending for each of the 24 short addresses</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EXT_ADDR0</name>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <description>Local address information
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EXT_ADDR0</name>
              <description>[7:0] EXT_ADDR[7:0]
The IEEE extended address used during destination address filtering</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EXT_ADDR1</name>
          <addressOffset>0xac</addressOffset>
          <size>32</size>
          <description>Local address information
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EXT_ADDR1</name>
              <description>[7:0] EXT_ADDR[15:8]
The IEEE extended address used during destination address filtering</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EXT_ADDR2</name>
          <addressOffset>0xb0</addressOffset>
          <size>32</size>
          <description>Local address information
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EXT_ADDR2</name>
              <description>[7:0] EXT_ADDR[23:16]
The IEEE extended address used during destination address filtering</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EXT_ADDR3</name>
          <addressOffset>0xb4</addressOffset>
          <size>32</size>
          <description>Local address information
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EXT_ADDR3</name>
              <description>[7:0] EXT_ADDR[31:24]
The IEEE extended address used during destination address filtering</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EXT_ADDR4</name>
          <addressOffset>0xb8</addressOffset>
          <size>32</size>
          <description>Local address information
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EXT_ADDR4</name>
              <description>[7:0] EXT_ADDR[39:32]
The IEEE extended address used during destination address filtering</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EXT_ADDR5</name>
          <addressOffset>0xbc</addressOffset>
          <size>32</size>
          <description>Local address information
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EXT_ADDR5</name>
              <description>[7:0] EXT_ADDR[47:40]
The IEEE extended address used during destination address filtering</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EXT_ADDR6</name>
          <addressOffset>0xc0</addressOffset>
          <size>32</size>
          <description>Local address information
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EXT_ADDR6</name>
              <description>[7:0] EXT_ADDR[55:48]
The IEEE extended address used during destination address filtering</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EXT_ADDR7</name>
          <addressOffset>0xc4</addressOffset>
          <size>32</size>
          <description>Local address information
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EXT_ADDR7</name>
              <description>[7:0] EXT_ADDR[63:56]
The IEEE extended address used during destination address filtering</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PAN_ID0</name>
          <addressOffset>0xc8</addressOffset>
          <size>32</size>
          <description>Local address information
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PAN_ID0</name>
              <description>[7:0] PAN_ID[7:0]
The PAN ID used during destination address filtering</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PAN_ID1</name>
          <addressOffset>0xcc</addressOffset>
          <size>32</size>
          <description>Local address information
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PAN_ID1</name>
              <description>[7:0] PAN_ID[15:8]
The PAN ID used during destination address filtering</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SHORT_ADDR0</name>
          <addressOffset>0xd0</addressOffset>
          <size>32</size>
          <description>Local address information
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SHORT_ADDR0</name>
              <description>[7:0] SHORT_ADDR[7:0]
The short address used during destination address filtering</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SHORT_ADDR1</name>
          <addressOffset>0xd4</addressOffset>
          <size>32</size>
          <description>Local address information
This register is stored in RAM; the reset value is undefined.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved. Always write 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SHORT_ADDR1</name>
              <description>[7:0] SHORT_ADDR[15:8]
The short address used during destination address filtering</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RFCORE_XREG</name>
      <baseAddress>0x40088600</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00000200</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>FRMFILT0</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>The frame filtering function rejects unintended frames as specified by IEEE 802.15.4, section 7.5.6.2, third filtering
level. In addition, it provides filtering on:
- The eight different frame types (see the FRMFILT1 register)
- The reserved bits in the frame control field (FCF)
The function is controlled by:
- The FRMFILT0 and FRMFILT1 registers
- The PAN_ID, SHORT_ADDR, and EXT_ADDR values in RAM</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:7] Reserved. Always read 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>FCF_RESERVED_MASK</name>
              <description>[6:4] Used for filtering on the reserved part of the frame control field (FCF)
FCF_RESERVED_MASK[2:0] is ANDed with FCF[9:7]. If the result is nonzero and frame filtering is enabled, the frame is rejected.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MAX_FRAME_VERSION</name>
              <description>[3:2] Used for filtering on the frame version field of the frame control field (FCF)
If FCF[13:12] (the frame version subfield) is higher than MAX_FRAME_VERSION[1:0] and frame filtering is enabled, the frame is rejected.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PAN_COORDINATOR</name>
              <description>[1:1] Should be set high when the device is a PAN coordinator, to accept frames with no destination address (as specified in Section 7.5.6.2 in IEEE 802.15.4)
0: Device is not a PAN coordinator
1: Device is a PAN coordinator</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>FRAME_FILTER_EN</name>
              <description>[0:0] Enables frame filtering
When this bit is set, the radio performs frame filtering as specified in
section 7.5.6.2 of IEEE 802.15.4(b), third filtering level. FRMFILT0[6:1]
and FRMFILT1[7:1], together with the local address information, define
the behavior of the filtering algorithm.
0: Frame filtering off. (FRMFILT0[6:1], FRMFILT1[7:1] and
SRCMATCH[2:0] are don't care.)
1: Frame filtering on.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FRMFILT1</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>The frame filtering function rejects unintended frames as specified by IEEE 802.15.4, section 7.5.6.2, third filtering
level. In addition, it provides filtering on:
- The eight different frame types (see the FRMFILT1 register)
- The reserved bits in the frame control field (FCF)
The function is controlled by:
- The FRMFILT0 and FRMFILT1 registers
- The PAN_ID, SHORT_ADDR, and EXT_ADDR values in RAM</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ACCEPT_FT_4TO7_RESERVED</name>
              <description>[7:7] Defines whether reserved frames are accepted or not. Reserved frames have frame type = 100, 101, 110, or 111.
0: Reject
1: Accept</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>ACCEPT_FT_3_MAC_CMD</name>
              <description>[6:6] Defines whether MAC command frames are accepted or not. MAC
command frames have frame type = 011.
0: Reject
1: Accept</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>ACCEPT_FT_2_ACK</name>
              <description>[5:5] Defines whether acknowledgment frames are accepted or not.
Acknowledgement frames have frame type = 010.
0: Reject
1: Accept</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>ACCEPT_FT_1_DATA</name>
              <description>[4:4] Defines whether data frames are accepted or not. Data frames have
frame type = 001.
0: Reject
1: Accept</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>ACCEPT_FT_0_BEACON</name>
              <description>[3:3] Defines whether beacon frames are accepted or not. Beacon frames have frame type = 000.
0: Reject
1: Accept</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MODIFY_FT_FILTER</name>
              <description>[2:1] These bits are used to modify the frame type field of a received frame before frame type filtering is performed. The modification does not influence the frame that is written to the RX FIFO.
00: Leave the frame type as it is.
01: Invert MSB of the frame type.
10: Set MSB of the frame type to 0.
11: Set MSB of the frame type to 1.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>FRM_RESERVED</name>
              <description>[0:0] Reserved. Always write 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRCMATCH</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Source address matching and pending bits</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:3] Reserved. Always read 0.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PEND_DATAREQ_ONLY</name>
              <description>[2:2] When this bit is set, the AUTOPEND function also requires that the received frame is a DATA REQUEST MAC command frame.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>AUTOPEND</name>
              <description>[1:1] Automatic acknowledgment pending flag enable
When a frame is received, the pending bit in the (possibly) returned acknowledgment is set automatically when the following conditions are met:
- FRMFILT.FRAME_FILTER_EN is set.
- SRCMATCH.SRC_MATCH_EN is set.
- SRCMATCH.AUTOPEND is set.
- The received frame matches the current SRCMATCH.PEND_DATAREQ_ONLY setting.
- The received source address matches at least one source match table entry, which is enabled in SHORT_ADDR_EN and SHORT_PEND_EN or in EXT_ADDR_EN and EXT_PEND_EN.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SRC_MATCH_EN</name>
              <description>[0:0] Source address matching enable (requires that FRMFILT.FRAME_FILTER_EN = 1)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRCSHORTEN0</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Short address matching</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SHORT_ADDR_EN</name>
              <description>[7:0] 7:0 part of the 24-bit word SHORT_ADDR_EN that enables or disables source address matching for each of the 24 short address table entries
Optional safety feature: To ensure that an entry in the source matching table is not used while it is being updated, set the corresponding SHORT_ADDR_EN bit to 0 while updating.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRCSHORTEN1</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Short address matching</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SHORT_ADDR_EN</name>
              <description>[7:0] 15:8 part of the 24-bit word SHORT_ADDR_EN
See description of SRCSHORTEN0.SHORT_ADDR_EN.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRCSHORTEN2</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Short address matching</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SHORT_ADDR_EN</name>
              <description>[7:0] 23:16 part of the 24-bit word SHORT_ADDR_EN
See description of SRCSHORTEN0.SHORT_ADDR_EN.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRCEXTEN0</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Extended address matching</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EXT_ADDR_EN</name>
              <description>[7:0] 7:0 part of the 24-bit word EXT_ADDR_EN that enables or disables source address matching for each of the 12 extended address table entries
Write access: Extended address enable for table entry n (0 to 11) is mapped to EXT_ADDR_EN[2n]. All EXT_ADDR_EN[2n + 1] bits are read only.
Read access: Extended address enable for table entry n (0 to 11) is mapped to EXT_ADDR_EN[2n] and EXT_ADDR_EN[2n + 1].
Optional safety feature: To ensure that an entry in the source matching table is not used while it is being updated, set the corresponding EXT_ADDR_EN bit to 0 while updating.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRCEXTEN1</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Extended address matching</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EXT_ADDR_EN</name>
              <description>[7:0] 15:8 part of the 24-bit word EXT_ADDR_EN
See description of SRCEXTEN0.EXT_ADDR_EN.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRCEXTEN2</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Extended address matching</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EXT_ADDR_EN</name>
              <description>[7:0] 23:16 part of the 24-bit word EXT_ADDR_EN
See description of SRCEXTEN0.EXT_ADDR_EN.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FRMCTRL0</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Frame handling</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>APPEND_DATA_MODE</name>
              <description>[7:7] When AUTOCRC = 0: Don't care
When AUTOCRC = 1:
0: RSSI + The CRC_OK bit and the 7-bit correlation value are
appended at the end of each received frame
1: RSSI + The CRC_OK bit and the 7-bit SRCRESINDEX are
appended at the end of each received frame.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>AUTOCRC</name>
              <description>[6:6] In TX
1: A CRC-16 (ITU-T) is generated in hardware and appended to the
transmitted frame. There is no need to write the last 2 bytes to TXBUF.
0: No CRC-16 is appended to the frame. The last 2 bytes of the frame must be generated manually and written to TXBUF (if not,
TX_UNDERFLOW occurs).
In RX
1: The CRC-16 is checked in hardware, and replaced in the RXFIFO
by a 16-bit status word which contains a CRC OK bit. The status
word is controllable through APPEND_DATA_MODE.
0: The last 2 bytes of the frame (CRC-16 field) are stored in the
RX FIFO. The CRC (if any) must be done manually.
This setting does not influence acknowledgment transmission (including AUTOACK).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>AUTOACK</name>
              <description>[5:5] Defines whether the radio automatically transmits acknowledge frames or not. When autoack is enabled, all frames that are accepted by address filtering, have the acknowledge request flag set, and have a valid CRC are automatically acknowledged 12 symbol periods after being received.
0: Autoack disabled
1: Autoack enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>ENERGY_SCAN</name>
              <description>[4:4] Defines whether the RSSI register contains the most-recent signal
strength or the peak signal strength since the energy scan was enabled.
0: Most-recent signal strength
1: Peak signal strength</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RX_MODE</name>
              <description>[3:2] Set RX modes.
00: Normal operation, use RX FIFO
01: Receive serial mode, output received data on to IOC; infinite RX
10: RX FIFO looping ignore overflow in RX FIFO; infinite reception
11: Same as normal operation except that symbol search is disabled. Can be used for RSSI or CCA measurements when finding symbol is not desired.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TX_MODE</name>
              <description>[1:0] Set test modes for TX.
00: Normal operation, transmit TX FIFO
01: Reserved, should not be used
10: TX FIFO looping ignore underflow in TX FIFO and read cyclic; infinite transmission
11: Send random data from CRC; infinite transmission</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FRMCTRL1</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Frame handling</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:3] Reserved. Read as 0.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PENDING_OR</name>
              <description>[2:2] Defines whether the pending data bit in outgoing acknowledgment frames is always set to 1 or controlled by the main FSM and the address filtering
0: Pending data bit is controlled by main FSM and address filtering.
1: Pending data bit is always 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>IGNORE_TX_UNDERF</name>
              <description>[1:1] Defines whether or not TX underflow should be ignored
0: Normal TX operation. TX underflow is detected and TX is aborted if underflow occurs.
1: Ignore TX underflow. Transmit the number of bytes given by the
frame-length field.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SET_RXENMASK_ON_TX</name>
              <description>[0:0] Defines whether STXON sets bit 6 in the RXENABLE register or leaves it unchanged
0: Does not affect RXENABLE
1: Sets bit 6 in RXENABLE. Used for backward compatibility with the CC2420.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXENABLE</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>RX enabling</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RXENMASK</name>
              <description>[7:0] RXENABLE enables the receiver. A nonzero value in this register causes FFCTRL to enable the receiver when in idle, after transmission and after acknowledgement transmission. 

The following strobes can modify RXENMASK:
SRXON: Set bit 7 in RXENMASK.
STXON: Set bit 6 in RXENMASK if SET_RXENMASK_ON_TX = 1.
SRFOFF: Clears all bits in RXENMASK.
SRXMASKBITSET: Set bit 5 in RXENMASK.
SRXMASKBITCLR: Clear bit 5 in RXENMASK.

There could be conflicts between the CSP and xreg_bus write operations if both operations try to modify RXENMASK simultaneously. To handle the case of simultaneous access to RXENMASK the following rules apply:
- If the two sources agree (they modify different parts of the register) both of their requests to modify RXENMASK are processed.
- If both operations try to modify the mask simultaneously, bus write operations to RXMASKSET and RXMASKCLR have priority over the CSP. This situation must be avoided.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXMASKSET</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>RX enabling</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RXENMASKSET</name>
              <description>[7:0] When written, the written data is ORed with the RXENMASK and stored in RXENMASK.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXMASKCLR</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>RX disabling</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RXENMASKCLR</name>
              <description>[7:0] When written, the written data is inverted and ANDed with the RXENMASK and stored in RXENMASK.
For example, if 1 is written to one or more bit positions in this register, the corresponding bits are cleared in RXENMASK.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FREQTUNE</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Crystal oscillator frequency tuning</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:4] Reserved. Always read 0.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>XOSC32M_TUNE</name>
              <description>[3:0] Tune crystal oscillator
The default setting 1111 leaves the XOSC untuned. Changing the setting from the default setting (1111) switches in extra capacitance to the oscillator, effectively lowering the XOSC frequency.  Hence, a higher setting gives a higher frequency.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FREQCTRL</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>Controls the RF frequency</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:7] Reserved. Always read 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>FREQ</name>
              <description>[6:0] Frequency control word
The frequency word in FREQ[6:0] is an offset value from 2394 (fRF = FREQ[6 0] + 2394). The RF-frequency is specified from 2405 to 2480 MHz in 1-MHz steps; hence, the only valid settings for FREQ[6:0] are 11 to 86 (11 + 2394 = 2405 and 86 + 2394 = 2480).  The device supports the frequency range from 2394 to 2507 MHz. Consequently, the usable settings for FREQ[6:0] are 0 to 113. Settings outside of  the usable range (114 to 127) give a frequency of 2507 MHz. 
IEEE 802.15.4-2006 specifies a frequency range from 2405 MHz to 2480 MHz with 16 channels 5 MHz apart. The channels are numbered 11 through 26. For an IEEE 802.15.4-2006 compliant system, the only valid settings are thus
FREQ[6:0] = 11 + 5 (channel number - 11).</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXPOWER</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>Controls the output power</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PA_POWER</name>
              <description>[7:4] PA power control</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PA_BIAS</name>
              <description>[3:0] PA bias control</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXCTRL</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>Controls the TX settings</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:7] Reserved. Always read 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>DAC_CURR</name>
              <description>[6:4] Change the current in the DAC.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DAC_DC</name>
              <description>[3:2] Adjusts the DC level to the TX mixer.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TXMIX_CURRENT</name>
              <description>[1:0] Transmit mixers core current
Current increases with increasing setting.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FSMSTAT0</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>Radio status register</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CAL_DONE</name>
              <description>[7:7] Frequency synthesis calibration has been performed since the last time the FS was turned on.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>CAL_RUNNING</name>
              <description>[6:6] Frequency synthesis calibration status
0: Calibration is complete or not started.
1: Calibration is in progress.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>FSM_FFCTRL_STATE</name>
              <description>[5:0] Gives the current state of the FIFO and frame control (FFCTRL) finite state-machine.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FSMSTAT1</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>Radio status register</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>FIFO</name>
              <description>[7:7] FIFO is high when there is data in the RX FIFO.
FIFO is low during RX FIFO overflow.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>FIFOP</name>
              <description>[6:6] FIFOP is set high when there are at more than FIFOP_THR bytes of data in the RX FIFO that has passed frame filtering.
FIFOP is set high when there is at least one complete frame in the RX FIFO.
FIFOP is high during RX FIFO overflow.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SFD</name>
              <description>[5:5] In TX
0: When a complete frame with SFD was sent or no SFD was sent
1: SFD was sent.
In RX
0: When a complete frame was received or no SFD was received
1: SFD was received.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>CCA</name>
              <description>[4:4] Clear channel assessment
Dependent on CCA_MODE settings. See CCACTRL1 for details.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SAMPLED_CCA</name>
              <description>[3:3] Contains a sampled value of the CCA
The value is updated when a SSAMPLECCA or STXONCCA strobe is issued.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>LOCK_STATUS</name>
              <description>[2:2] 1 when PLL is in lock; otherwise 0</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TX_ACTIVE</name>
              <description>[1:1] Status signal
Active when FFC is in one of the transmit states</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RX_ACTIVE</name>
              <description>[0:0] Status signal
Active when FFC is in one of the receive states</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FIFOPCTRL</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>FIFOP threshold</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:7] Reserved. Always read 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>FIFOP_THR</name>
              <description>[6:0] Threshold used when generating FIFOP signal</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FSMCTRL</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>FSM options</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:2] Reserved. Always read 0.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SLOTTED_ACK</name>
              <description>[1:1] Controls timing of transmission of acknowledge frames
0: The acknowledge frame is sent 12 symbol periods after the end
of the received frame which requests the aknowledge.
1: The acknowledge frame is sent at the first backoff-slot boundary
more than 12 symbol periods after the end of the received frame
which requests the aknowledge.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RX2RX_TIME_OFF</name>
              <description>[0:0] Defines whether or not a 12-symbol time-out should be used after frame
reception has ended.
0: No time-out
1: 12-symbol-period time-out</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CCACTRL0</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>CCA threshold</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CCA_THR</name>
              <description>[7:0] Clear-channel-assessment threshold value, signed 2's-complement
number for comparison with the RSSI.
The unit is 1 dB, offset is 73dB 

The CCA signal goes high when the received signal is below this value. The CCA signal is available on the CCA pin and in the FSMSTAT1 register.
The value must never be set lower than CCA_HYST - 128 to avoid erroneous behavior of the CCA signal.
Note: The reset value translates to an input level of approximately
-32 - 73 = -105 dBm, which is well below the sensitivity limit. This means that the CCA signal never indicates a clear channel.
This register should be updated to 0xF8, which translates to an input
level of about -8 - 73 = -81 dBm.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CCACTRL1</name>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <description>Other CCA Options</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:5] Reserved. Always read 0.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>CCA_MODE</name>
              <description>[4:3] 00: CCA always set to 1
01: CCA = 1 when RSSI &lt; CCA_THR - CCA_HYST; CCA = 0 when
RSSI >= CCA_THR
10: CCA = 1 when not receiving a frame, else CCA = 0
11: CCA = 1 when RSSI &lt; CCA_THR - CCA_HYST and not
receiving a frame; CCA = 0 when RSSI >= CCA_THR or when
receiving a frame</description>
              <bitWidth>2</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CCA_HYST</name>
              <description>[2:0] Sets the level of CCA hysteresis. Unsigned values given in dB</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RSSI</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>RSSI status register</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RSSI_VAL</name>
              <description>[7:0] RSSI estimate on a logarithmic scale, signed number on 2's complement
Unit is 1 dB, offset is 73dB.

The RSSI value is averaged over eight symbol periods. The RSSI_VALID status bit should be checked before reading RSSI_VAL for the first time.
The reset value of -128 also indicates that the RSSI value is invalid.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RSSISTAT</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>RSSI valid status register</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:1] Reserved. Always read 0.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RSSI_VALID</name>
              <description>[0:0] RSSI value is valid.
Occurs eight symbol periods after entering RX.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXFIRST</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>First byte in RX FIFO</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DATA</name>
              <description>[7:0] First byte of the RX FIFO
Note: Reading this register does not modify the contents of the FIFO.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXFIFOCNT</name>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <description>Number of bytes in RX FIFO</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RXFIFOCNT</name>
              <description>[7:0] Number of bytes in the RX FIFO (unsigned integer)</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXFIFOCNT</name>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <description>Number of bytes in TX FIFO</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TXFIFOCNT</name>
              <description>[7:0] Number of bytes in the TX FIFO (unsigned integer)</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXFIRST_PTR</name>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <description>RX FIFO pointer</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RXFIRST_PTR</name>
              <description>[7:0] RAM address offset of the first byte in the RX FIFO</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXLAST_PTR</name>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <description>RX FIFO pointer</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RXLAST_PTR</name>
              <description>[7:0] RAM address offset of the last byte + 1 byte in the RX FIFO</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXP1_PTR</name>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <description>RX FIFO pointer</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RXP1_PTR</name>
              <description>[7:0] RAM address offset of the first byte of the first frame in the RX FIFO</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXFIRST_PTR</name>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <description>TX FIFO pointer</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TXFIRST_PTR</name>
              <description>[7:0] RAM address offset of the next byte to be transmitted from the TX FIFO</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXLAST_PTR</name>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <description>TX FIFO pointer</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TXLAST_PTR</name>
              <description>[7:0] RAM address offset of the last byte + 1 byte of the TX FIFO</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RFIRQM0</name>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <description>RF interrupt masks</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RFIRQM</name>
              <description>[7:0] Bit mask is masking out interrupt sources.
Bit position:
7: RXMASKZERO
6: RXPKTDONE
5: FRAME_ACCEPTED
4: SRC_MATCH_FOUND
3: SRC_MATCH_DONE
2: FIFOP
1: SFD
0: ACT_UNUSED</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RFIRQM1</name>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <description>RF interrupt masks</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:6] 7: Reserved
6: Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>RFIRQM</name>
              <description>[5:0] Bit mask is masking out interrupt sources.
Bit position:
5: CSP_WAIT
4: CSP_STOP
3: CSP_MANINT
2: RF_IDLE
1: TXDONE
0: TXACKDONE</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RFERRM</name>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <description>RF error interrupt mask</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:7] 7: Reserved</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RFERRM</name>
              <description>[6:0] Bit mask is masking out interrupt sources.
Bit position:
6: STROBE_ERR
5: TXUNDERF
4: TXOVERF
3: RXUNDERF
2: RXOVERF
1: RXABO
0: NLOCK</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RFRND</name>
          <addressOffset>0x9c</addressOffset>
          <size>32</size>
          <description>Random data</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:2] Reserved. Always read 0.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>QRND</name>
              <description>[1:1] Random bit from the Q channel of the receiver</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>IRND</name>
              <description>[0:0] Random bit from the I channel of the receiver</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MDMCTRL0</name>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <description>Controls modem</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DEM_NUM_ZEROS</name>
              <description>[7:6] Sets how many zero symbols must be detected before the sync word when searching for sync. Only one zero symbol is required to have a correlation value above the correlation threshold set in the MDMCTRL1 register.
00: Reserved
01: 1 zero symbol
10: 2 zero symbols
11: 3 zero symbols</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DEMOD_AVG_MODE</name>
              <description>[5:5] Defines the behavior or the frequency offset averaging filter.
0: Lock average level after preamble match. Restart frequency offset
calibration when searching for the next frame.
1: Continuously update average level.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PREAMBLE_LENGTH</name>
              <description>[4:1] The number of preamble bytes (two zero-symbols) to be sent in TX mode before the SFD, encoded in steps of 2 symbols (1 byte). The reset value of 2 is compliant with IEEE 802.15.4.
0000: 2 leading-zero bytes
0001: 3 leading-zero bytes
0010: 4 leading-zero bytes
...
1111: 17 leading-zero bytes</description>
              <bitWidth>4</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TX_FILTER</name>
              <description>[0:0] Defines the kind of TX filter that is used. The normal TX filter is as defined by the IEEE 802.15.4 standard. Extra filtering may be applied to lower the out-of-band emissions.
0: Normal TX filtering
1: Enable extra filtering</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MDMCTRL1</name>
          <addressOffset>0xa4</addressOffset>
          <size>32</size>
          <description>Controls modem</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:6] Reserved. Always read 0.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>CORR_THR_SFD</name>
              <description>[5:5] Defines requirements for SFD detection:
0: The correlation value of one of the zero symbols of the preamble must be above the correlation threshold.
1: The correlation value of one zero symbol of the preamble and both
symbols in the SFD must be above the correlation threshold.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>CORR_THR</name>
              <description>[4:0] Demodulator correlator threshold value, required before SFD search. Threshold value adjusts how the receiver synchronizes to data from the radio. If the threshold is set too low, sync can more easily be found on noise. If set too high, the sensitivity is reduced, but sync is not likely to be found on noise. In combination with DEM_NUM_ZEROS, the system can be tuned so sensitivity is high with less sync found on noise.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FREQEST</name>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <description>Estimated RF frequency offset</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>FREQEST</name>
              <description>[7:0] Signed 2's-complement value. Contains an estimate of the frequency offset between carrier and the receiver LO. The offset frequency is FREQEST x 7800 Hz. DEM_AVG_MODE controls when this estimate is updated. If DEM_AVG_MODE = 0, it is updated until sync is found. Then the frequency offset estimate is frozen until the end of the received frame. If DEM_AVG_MODE = 1, it is updated as long as the demodulator is enabled. To calculate the correct value, one must use an offset (FREQEST_offset), which can be found in the device data sheet. Real FREQEST value = FREQEST - FREQEST_offset.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RXCTRL</name>
          <addressOffset>0xac</addressOffset>
          <size>32</size>
          <description>Tune receive section</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:6] Reserved. Always read 0.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>GBIAS_LNA2_REF</name>
              <description>[5:4] Adjusts front-end LNA2/mixer PTAT current output (from M = 3 to M = 6), default: M = 5</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>GBIAS_LNA_REF</name>
              <description>[3:2] Adjusts front-end LNA PTAT current output (from M = 3 to M = 6), default: M = 5</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>MIX_CURRENT</name>
              <description>[1:0] Control of the output current from the receiver mixers 
The current increases with increasing setting set.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FSCTRL</name>
          <addressOffset>0xb0</addressOffset>
          <size>32</size>
          <description>Tune frequency synthesizer</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PRE_CURRENT</name>
              <description>[7:6] Prescaler current setting</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>LODIV_BUF_CURRENT_TX</name>
              <description>[5:4] Adjusts current in mixer and PA buffers
Used when TX_ACTIVE = 1</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>LODIV_BUF_CURRENT_RX</name>
              <description>[3:2] Adjusts current in mixer and PA buffers
Used when TX_ACTIVE = 0</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>LODIV_CURRENT</name>
              <description>[1:0] Adjusts divider currents, except mixer and PA buffers</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FSCAL0</name>
          <addressOffset>0xb4</addressOffset>
          <size>32</size>
          <description>Tune frequency calibration</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>VCO_CURR_COMP_EN_OV</name>
              <description>[7:7] Force on the current comparator in the VCO. This signal is ORed with the signal coming from the calibration module.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>CHP_DISABLE</name>
              <description>[6:6] Set this bit to manually disable charge pump by masking the up and down pulses from the phase detector.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>CHP_CURRENT</name>
              <description>[5:2] Digital bit vector defining the charge-pump output current on an exponential scale

If FFC_BW_BOOST = 0, the read value is the value stored in CHP_CURRENT.
If FFC_BW_BOOST = 1, the read value is CHP_CURRENT + 4.

If the addition causes overflow, the signal is saturated.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>BW_BOOST_MODE</name>
              <description>[1:0] Control signal
Defines the synthesizer boost mode
00: No BW_BOOST
01: BW_BOOST is high during calibration and approximately 30 us into the settling.
10: BW_BOOST is always on (or high).
11: Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FSCAL1</name>
          <addressOffset>0xb8</addressOffset>
          <size>32</size>
          <description>Tune frequency calibration</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>VCO_CURR_CAL_OE</name>
              <description>[7:7] Override current calibration</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>VCO_CURR_CAL</name>
              <description>[6:2] Calibration result
Override value if VCO_CURR_CAL_OE = 1</description>
              <bitWidth>5</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>VCO_CURR</name>
              <description>[1:0] Defines current in VCO core
Sets the multiplier between calibrated current and VCO current.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FSCAL2</name>
          <addressOffset>0xbc</addressOffset>
          <size>32</size>
          <description>Tune frequency calibration</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:7] Reserved. Always read 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>VCO_CAPARR_OE</name>
              <description>[6:6] Override the calibration result with the value from VCO_CAPARR[5:0].</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>VCO_CAPARR</name>
              <description>[5:0] VCO capacitor array setting
Programmed during calibration
Override value when VCO_CAPARR_OE = 1</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FSCAL3</name>
          <addressOffset>0xc0</addressOffset>
          <size>32</size>
          <description>Tune frequency calibration</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:7] Reserved. Always read 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>VCO_DAC_EN_OV</name>
              <description>[6:6] Enables the VCO DAC when 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>VCO_VC_DAC</name>
              <description>[5:2] Bit vector for programming varactor control voltage from VC DAC</description>
              <bitWidth>4</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>VCO_CAPARR_CAL_CTRL</name>
              <description>[1:0] Calibration accuracy setting for the cap_array calibration part of the calibration
00: 80 XOSC periods
01: 100 XOSC periods 
10: 125 XOSC periods 
11: 250 XOSC periods</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AGCCTRL0</name>
          <addressOffset>0xc4</addressOffset>
          <size>32</size>
          <description>AGC dynamic range control</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:7] Reserved. Always read 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>AGC_DR_XTND_EN</name>
              <description>[6:6] 0: The AGC performs no adjustment of attenuation in the AAF.
1: The AGC adjusts the gain in the AAF to achieve extra dynamic range for the receiver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>AGC_DR_XTND_THR</name>
              <description>[5:0] If the measured error between the AGC reference magnitude and the actual magnitude in dB is larger than this threshold, the extra attenuation is enabled in the front end. This threshold must be set higher than 0x0C.
This feature is enabled by AGC_DR_XTND_EN.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AGCCTRL1</name>
          <addressOffset>0xc8</addressOffset>
          <size>32</size>
          <description>AGC reference level</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:6] Reserved. Always read 0.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>AGC_REF</name>
              <description>[5:0] Target value for the AGC control loop, given in 1-dB steps</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AGCCTRL2</name>
          <addressOffset>0xcc</addressOffset>
          <size>32</size>
          <description>AGC gain override</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>LNA1_CURRENT</name>
              <description>[7:6] Overrride value for LNA 1
Used only when LNA_CURRENT_OE = 1
When read, this register returns the current applied gain setting.
00: 0-dB gain (reference level)
01: 3-dB gain
10: Reserved
11: 6-dB gain</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>LNA2_CURRENT</name>
              <description>[5:3] Overrride value for LNA 2
Used only when LNA_CURRENT_OE = 1
When read, this register returns the current applied gain setting.
000: 0-dB gain (reference level)
001: 3-dB gain
010: 6-dB gain
011: 9-dB gain
100: 12-dB gain
101: 15-dB gain
110: 18-dB gain
111: 21-dB gain</description>
              <bitWidth>3</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>LNA3_CURRENT</name>
              <description>[2:1] Overrride value for LNA 3
Used only when LNA_CURRENT_OE = 1
When read, this register returns the current applied gain setting.
00: 0-dB gain (reference level)
01: 3-dB gain
10: 6-dB gain
11: 9-dB gain</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>LNA_CURRENT_OE</name>
              <description>[0:0] Write 1 to override the AGC LNA current setting with the values above
(LNA1_CURRENT, LNA2_CURRENT, and LNA3_CURRENT).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AGCCTRL3</name>
          <addressOffset>0xd0</addressOffset>
          <size>32</size>
          <description>AGC control</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:7] Reserved. Always read 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>AGC_SETTLE_WAIT</name>
              <description>[6:5] Timing for AGC to wait for analog gain to settle after a gain change.
During this period, the energy measurement in the AGC is paused.
00: 15 periods
01: 20 periods
10: 25 periods
11: 30 periods</description>
              <bitWidth>2</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>AGC_WIN_SIZE</name>
              <description>[4:3] Window size for the accumulate-and-dump function in the AGC.
00: 16 samples
01: 32 samples
10: 64 samples
11: 128 samples</description>
              <bitWidth>2</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>AAF_RP</name>
              <description>[2:1] Overrides the control signals of the AGC to AAF when AAF_RP_OE = 1.
When read, it returns the applied signal to the AAF.
00: 9-dB attenuation in AAF
01: 6-dB attenuation in AAF
10: 3-dB attenuation in AAF
11: 0-dB attenuation in AAF (reference level)</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>AAF_RP_OE</name>
              <description>[0:0] Override the AAF control signals of the AGC with the values stored in AAF_RP.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ADCTEST0</name>
          <addressOffset>0xd4</addressOffset>
          <size>32</size>
          <description>ADC tuning</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ADC_VREF_ADJ</name>
              <description>[7:6] Quantizer threshold control for test and debug</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>ADC_QUANT_ADJ</name>
              <description>[5:4] Quantizer threshold control for test and debug</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>ADC_GM_ADJ</name>
              <description>[3:1] Gm-control for test and debug</description>
              <bitWidth>3</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ADC_DAC2_EN</name>
              <description>[0:0] Enables DAC2 for enhanced ADC stability</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ADCTEST1</name>
          <addressOffset>0xd8</addressOffset>
          <size>32</size>
          <description>ADC tuning</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ADC_TEST_CTRL</name>
              <description>[7:4] ADC test mode selector</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>ADC_C2_ADJ</name>
              <description>[3:2] Used to adjust capacitor values in ADC</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>ADC_C3_ADJ</name>
              <description>[1:0] Used to adjust capacitor values in ADC</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ADCTEST2</name>
          <addressOffset>0xdc</addressOffset>
          <size>32</size>
          <description>ADC tuning</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:7] Reserved. Always read 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>ADC_TEST_MODE</name>
              <description>[6:5] Test mode to enable output of ADC data from demodulator. When enabled, raw ADC data is clocked out on the GPIO pins.
00: Test mode disabled
01: Data from the I and Q ADCs are output (data rate 76 MHz)
10: Data from the I ADC is output. Two and two ADC samples grouped (data rate 38 MHz)
11: Data from the Q ADC is output. Two and two ADC samples grouped (data rate 38 MHz)</description>
              <bitWidth>2</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>AAF_RS</name>
              <description>[4:3] Controls series resistance of AAF</description>
              <bitWidth>2</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>ADC_FF_ADJ</name>
              <description>[2:1] Adjust feed forward</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ADC_DAC_ROT</name>
              <description>[0:0] Control of DAC DWA scheme
0 = DWA (scrambling) disabled
1 = DWA enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MDMTEST0</name>
          <addressOffset>0xe0</addressOffset>
          <size>32</size>
          <description>Test register for modem</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TX_TONE</name>
              <description>[7:4] Enables the possibility to transmit a baseband tone by picking samples from the sine tables with a controllable phase step between the samples.
The step size is controlled by TX_TONE. If MDMTEST1.MOD_IF is 0, the tone is superpositioned on the modulated data, effectively giving modulation with an IF. If MDMTEST1.MOD_IF is 1, only the tone is transmitted.
0000: -6 MHz 
0001: -4 MHz
0010: -3 MHz
0011: -2 MHz
0100: -1 MHz
0101: -500 kHz
0110: -4 kHz
0111: 0
1000: 4 kHz
1001: 500 kHz
1010: 1 MHz
1011: 2 MHz
1100: 3 MHz
1101: 4 MHz
1110: 6 MHz
Others: Reserved</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DC_WIN_SIZE</name>
              <description>[3:2] Controls the numbers of samples to be accumulated between each dump of the accumulate-and-dump filter used in DC removal
00: 32 samples
01: 64 samples
10: 128 samples
11: 256 samples</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DC_BLOCK_MODE</name>
              <description>[1:0] Selects the mode of operation
00: The input signal to the DC blocker is passed to the output without any attempt to remove DC.
01: Enable DC cancellation. Normal operation
10: Freeze estimates of DC when sync is found. Resume estimating DC when searching for the next frame.
11: Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MDMTEST1</name>
          <addressOffset>0xe4</addressOffset>
          <size>32</size>
          <description>Test Register for Modem</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:6] Reserved. Always read 0.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>USEMIRROR_IF</name>
              <description>[5:5] 0: Use the normal IF frequency (MDMTEST0.TX_TONE) for automatic IF compensation of channel frequency on TX.
1: Use mirror IF frequency for automatic compensation of channel frequency on TX.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>MOD_IF</name>
              <description>[4:4] 0: Modulation is performed at an IF set by MDMTEST0.TX_TONE. The tone set by MDMTEST0.TX_TONE is superimposed on the data.
1: Modulate a tone set by MDMTEST0.TX_TONE.  A tone is transmitted with frequency set by MDMTEST0.TX_TONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RAMP_AMP</name>
              <description>[3:3] 1: Enable ramping of DAC output amplitude during startup and finish.
0: Disable ramping of DAC output amplitude.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RFC_SNIFF_EN</name>
              <description>[2:2] 0: Packet sniffer module disabled
1: Packet sniffer module enabled. The received and transmitted data can be observed on GPIO pins.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>Reserved</name>
              <description>[1:1] Must be written as 0 for correct operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>LOOPBACK_EN</name>
              <description>[0:0] Enables loopback of modulated data into the receiver chain
0: An STXCAL instruction calibrates for TX. Use STXON to continue to active TX.
1: An STXCAL instruction enables the loopback mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DACTEST0</name>
          <addressOffset>0xe8</addressOffset>
          <size>32</size>
          <description>DAC override value</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DAC_Q_O</name>
              <description>[7:0] Q-branch DAC override value when DAC_SRC = 001

If DAC_SRC is set to be ADC data, CORDIC magnitude, or channel filtered data, then DAC_Q_O controls the part of the word in question that is actually multiplexed to the DAC, as described below.
000111: Bits 7:0
001000: Bits 8:1
001001: Bits 9:2
...

If an invalid setting is chosen, the DAC outputs only zeros (minimum value).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DACTEST1</name>
          <addressOffset>0xec</addressOffset>
          <size>32</size>
          <description>DAC override value</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DAC_I_O</name>
              <description>[7:0] I-branch DAC override value when DAC_SRC = 001

If DAC_SRC is set  to be ADC data, CORDIC magnitude, channel filtered data, or DC filtered data, then DAC_I_O controls the part of the word in question that is actually multiplexed to the DAC as described below.
000111: Bits 7:0
001000: Bits 8:1
001001: Bits 9:2
...

If an invalid setting is chosen, then the DAC outputs only zeros (minimum value).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DACTEST2</name>
          <addressOffset>0xf0</addressOffset>
          <size>32</size>
          <description>DAC test setting</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:6] Reserved. Always read 0.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DAC_DEM_EN</name>
              <description>[5:5] Enable and disable dynamic element matching
Drives RFR_DAC_DEM_EN</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>DAC_CASC_CTRL</name>
              <description>[4:3] Adjustment of output stage
Drives RFR_DAC_CASC_CTRL</description>
              <bitWidth>2</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>DAC_SRC</name>
              <description>[2:0] The TX DACs data source is selected by DAC_SRC according to:
000: Normal operation (from modulator)
001: The DAC_I_O and DAC_Q_O override values
010: ADC data after decimation, magnitude controlled by DAC_I_O and DAC_Q_O
011: I/Q after decimation, channel and DC filtering, magnitude controlled by DAC_I_O and DAC_Q_O
100: CORDIC magnitude output and front-end gain is output,  magnitude controlled by DAC_I_O and DAC_Q_O
101: RSSI I output on the I DAC
111: Reserved</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ATEST</name>
          <addressOffset>0xf4</addressOffset>
          <size>32</size>
          <description>Analog test control</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:6] Reserved. Always read 0.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>ATEST_CTRL</name>
              <description>[5:0] Controls the analog test mode:
00 0000: Disabled
00 0001: Enables the temperature sensor (see also the CCTEST_TR0 register description).
Other values reserved.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PTEST0</name>
          <addressOffset>0xf8</addressOffset>
          <size>32</size>
          <description>Override power-down register</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PRE_PD</name>
              <description>[7:7] Prescaler power-down signal
When PD_OVERRIDE = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>CHP_PD</name>
              <description>[6:6] Charge pump power-down signal
When PD_OVERRIDE = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>ADC_PD</name>
              <description>[5:5] ADC power-down signal
When PD_OVERRIDE = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>DAC_PD</name>
              <description>[4:4] DAC power-down signal
When PD_OVERRIDE = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>LNA_PD</name>
              <description>[3:2] Low-noise amplifier power-down signal
Defines LNA/mixer power-down modes:
00: Power up 
01: LNA off, mixer/regulator on
10: LNA/mixer off, regulator on
11: PD
 When PD_OVERRIDE = 1</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TXMIX_PD</name>
              <description>[1:1] Transmit mixer power-down signal
When PD_OVERRIDE = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>AAF_PD</name>
              <description>[0:0] Antialiasing filter power-down signal
When PD_OVERRIDE = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PTEST1</name>
          <addressOffset>0xfc</addressOffset>
          <size>32</size>
          <description>Override power-down register</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:4] Reserved. Always read 0.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PD_OVERRIDE</name>
              <description>[3:3] Override enabling and disabling of various modules (for debug and testing only)
It is impossible to override hard-coded BIAS_PD[1:0] depenancy.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PA_PD</name>
              <description>[2:2] Power amplifier power-down signal
When PD_OVERRIDE = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>VCO_PD</name>
              <description>[1:1] VCO power-down signal
When PD_OVERRIDE = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>LODIV_PD</name>
              <description>[0:0] LO power-down signal
When PD_OVERRIDE = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_0</name>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_1</name>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_2</name>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_3</name>
          <addressOffset>0x10c</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_4</name>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_5</name>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_6</name>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_7</name>
          <addressOffset>0x11c</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_8</name>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_9</name>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_10</name>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_11</name>
          <addressOffset>0x12c</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_12</name>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_13</name>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_14</name>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_15</name>
          <addressOffset>0x13c</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_16</name>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_17</name>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_18</name>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_19</name>
          <addressOffset>0x14c</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_20</name>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_21</name>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_22</name>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPPROG_23</name>
          <addressOffset>0x15c</addressOffset>
          <size>32</size>
          <description>CSP program</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSP_INSTR</name>
              <description>[7:0] Byte N of the CSP program memory</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPCTRL</name>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <description>CSP control bit</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:1] Reserved. Always read 0.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>MCU_CTRL</name>
              <description>[0:0] CSP MCU control input</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPSTAT</name>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <description>CSP status register</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:6] Reserved. Always read 0.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>CSP_RUNNING</name>
              <description>[5:5] 1: CSP is running.
0: CSP is idle.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>CSP_PC</name>
              <description>[4:0] CSP program counter</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPX</name>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <description>CSP X data register</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSPX</name>
              <description>[7:0] Used by CSP instructions WAITX, RANDXY, INCX, DECX,
and conditional instructions.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPY</name>
          <addressOffset>0x18c</addressOffset>
          <size>32</size>
          <description>CSP Y data register</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSPY</name>
              <description>[7:0] Used by CSP instructions RANDXY, INCY, DECY, and conditional instructions.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPZ</name>
          <addressOffset>0x190</addressOffset>
          <size>32</size>
          <description>CSP Z data register</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSPZ</name>
              <description>[7:0] Used by CSP instructions INCZ, DECZ, and conditional instructions.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSPT</name>
          <addressOffset>0x194</addressOffset>
          <size>32</size>
          <description>CSP T data register</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CSPT</name>
              <description>[7:0] Content is decremented each time the MAC Timer overflows while the CSP program is running. The SCP program stops when decremented to 0. Setting CSPT = 0xFF prevents the register from being decremented.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RFC_OBS_CTRL0</name>
          <addressOffset>0x1ac</addressOffset>
          <size>32</size>
          <description>RF observation mux control</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:7] Reserved. Always read 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RFC_OBS_POL0</name>
              <description>[6:6] The signal chosen by RFC_OBS_MUX0 is XORed with this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>RFC_OBS_MUX0</name>
              <description>[5:0] Controls which observable signal from RF Core is to be muxed out to rfc_obs_sigs[0].
00 0000: 0 - Constant value
00 0001: 1 - Constant value
00 1000: rfc_sniff_data - Data from packet sniffer. Sample data on rising edges of sniff_clk.
00 1001: rfc_sniff_clk - 250kHz clock for packet sniffer data.
00 1100: rssi_valid - Pin is high when the RSSI value has been updated at least once since RX was started. Cleared when leaving RX.
00 1101: demod_cca - Clear channel assessment. See FSMSTAT1 register for details on how to configure the behavior of this signal.
00 1110: sampled_cca - A sampled version of the CCA bit from demodulator. The value is updated whenever a SSAMPLECCA or STXONCCA strobe is issued.
00 1111: sfd_sync - Pin is high when a SFD has been received or transmitted. Cleared when leaving RX/TX respectively. Not to be confused with the SFD exception.
01 0000: tx_active - Indicates that FFCTRL is in one of the TX states. Active-high.
Note: This signal might have glitches, because it has no output flip-flop and is based
on the current state register of the FFCTRL FSM.
01 0001: rx_active - Indicates that FFCTRL is in one of the RX states. Active-high.
Note: This signal might have glitches, because it has no output flip-flop and is based
on the current state register of the FFCTRL FSM.
01 0010: ffctrl_fifo - Pin is high when one or more bytes are in the RXFIFO. Low during RXFIFO overflow.
01 0011: ffctrl_fifop - Pin is high when the number of bytes in the RXFIFO exceeds the programmable threshold or at least one complete frame is in the RXFIFO. Also high
during RXFIFO overflow. Not to be confused with the FIFOP exception.
01 0100: packet_done - A complete frame has been received. I.e., the number of bytes set by the frame-length field has been received.
01 0110: rfc_xor_rand_i_q - XOR between I and Q random outputs. Updated at 8 MHz.
01 0111: rfc_rand_q - Random data output from the Q channel of the receiver. Updated at 8 MHz.
01 1000: rfc_rand_i - Random data output from the I channel of the receiver. Updated at 8 MHz
01 1001: lock_status - 1 when PLL is in lock, otherwise 0
10 1000: pa_pd - Power amplifier power-down signal
10 1010: lna_pd - LNA power-down signal
Others: Reserved</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RFC_OBS_CTRL1</name>
          <addressOffset>0x1b0</addressOffset>
          <size>32</size>
          <description>RF observation mux control</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:7] Reserved. Always read 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RFC_OBS_POL1</name>
              <description>[6:6] The signal chosen by RFC_OBS_MUX1 is XORed with this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>RFC_OBS_MUX1</name>
              <description>[5:0] Controls which observable signal from RF Core is to be muxed out to rfc_obs_sigs[1].
See description of RFC_OBS_CTRL0 for details.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RFC_OBS_CTRL2</name>
          <addressOffset>0x1b4</addressOffset>
          <size>32</size>
          <description>RF observation mux control</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:7] Reserved. Always read 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RFC_OBS_POL2</name>
              <description>[6:6] The signal chosen by RFC_OBS_MUX2 is XORed with this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>RFC_OBS_MUX2</name>
              <description>[5:0] Controls which observable signal from RF Core is to be muxed out to rfc_obs_sigs[2].
See description of RFC_OBS_CTRL0 for details.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TXFILTCFG</name>
          <addressOffset>0x1e8</addressOffset>
          <size>32</size>
          <description>TX filter configuration</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:4] Reserved. Always read 0.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>FC</name>
              <description>[3:0] Drives signal rfr_txfilt_fc</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RFCORE_SFR</name>
      <baseAddress>0x40088800</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00000100</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>MTCSPCFG</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>MAC Timer event configuration</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:7] Reserved. Always read 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>MACTIMER_EVENMT_CFG</name>
              <description>[6:4] Selects the event that triggers an MT_EVENT2 pulse
000: MT_per_event
001: MT_cmp1_event
010: MT_cmp2_event
011: MTovf_per_event
100: MTovf_cmp1_event
101: MTovf_cmp2_event
110: Reserved
111: No event</description>
              <bitWidth>3</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:3] Reserved. Always read 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MACTIMER_EVENT1_CFG</name>
              <description>[2:0] Selects the event that triggers an MT_EVENT1 pulse
000: MT_per_event
001: MT_cmp1_event
010: MT_cmp2_event
011: MTovf_per_event
100: MTovf_cmp1_event
101: MTovf_cmp2_event
110: Reserved
111: No event</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MTCTRL</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>MAC Timer control register</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:4] Reserved. Always read 0.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>LATCH_MODE</name>
              <description>[3:3] 0: Reading MTM0 with MTMSEL.MTMSEL = 000 latches the high byte of the timer, making it ready to be read from MTM1. Reading MTMOVF0 with MTMSEL.MTMOVFSEL = 000 latches the two most-significant bytes of the overflow counter, making it possible to read these from MTMOVF1 and MTMOVF2.
1: Reading MTM0 with MTMSEL.MTMSEL = 000 latches the high byte of the timer and the entire overflow counter at once, making it possible to read the values from MTM1, MTMOVF0, MTMOVF1, and MTMOVF2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>STATE</name>
              <description>[2:2] State of MAC Timer
0: Timer idle
1: Timer running</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SYNC</name>
              <description>[1:1] 0: Starting and stopping of timer is immediate; that is, synchronous with clk_rf_32m.
1: Starting and stopping of timer occurs at the first positive edge of the 32-kHz clock. For more details regarding timer start and stop, see Section 22.4.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RUN</name>
              <description>[0:0] Write 1 to start timer, write 0 to stop timer. When read, it returns the last written value.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MTIRQM</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>MAC Timer interrupt mask</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:6] Reserved. Always read 0.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>MACTIMER_OVF_COMPARE2M</name>
              <description>[5:5] Enables the MACTIMER_OVF_COMPARE2 interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>MACTIMER_OVF_COMPARE1M</name>
              <description>[4:4] Enables the MACTIMER_OVF_COMPARE1 interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MACTIMER_OVF_PERM</name>
              <description>[3:3] Enables the MACTIMER_OVF_PER interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MACTIMER_COMPARE2M</name>
              <description>[2:2] Enables the MACTIMER_COMPARE2 interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>MACTIMER_COMPARE1M</name>
              <description>[1:1] Enables the MACTIMER_COMPARE1 interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>MACTIMER_PERM</name>
              <description>[0:0] Enables the MACTIMER_PER interrupt</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MTIRQF</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>MAC Timer interrupt flags</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:6] Reserved. Always read 0.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>MACTIMER_OVF_COMPARE2F</name>
              <description>[5:5] Set when the MAC Timer overflow counter counts to the value set at MTovf_cmp2</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>MACTIMER_OVF_COMPARE1F</name>
              <description>[4:4] Set when the MAC Timer overflow counter counts to the value set at Timer 2 MTovf_cmp1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MACTIMER_OVF_PERF</name>
              <description>[3:3] Set when the MAC Timer overflow counter would have counted to a value equal to MTovf_per, but instead wraps to 0</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MACTIMER_COMPARE2F</name>
              <description>[2:2] Set when the MAC Timer counter counts to the value set at MT_cmp2</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>MACTIMER_COMPARE1F</name>
              <description>[1:1] Set when the MAC Timer counter counts to the value set at MT_cmp1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>MACTIMER_PERF</name>
              <description>[0:0] Set when the MAC Timer counter would have counted to a value equal to MT_per, but instead wraps to 0</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MTMSEL</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>MAC Timer multiplex select</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:7] Reserved. Always read 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>MTMOVFSEL</name>
              <description>[6:4] The value of this register selects the internal registers that are modified or read when accessing MTMOVF0, MTMOVF1, and MTMOVF2.
000: MTovf (overflow counter)
001: MTovf_cap (overflow capture)
010: MTovf_per (overflow period)
011: MTovf_cmp1 (overflow compare 1)
100: MTovf_cmp2 (overflow compare 2)
101 to 111: Reserved</description>
              <bitWidth>3</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:3] Reserved. Read as 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MTMSEL</name>
              <description>[2:0] The value of this register selects the internal registers that are modified or read when accessing MTM0 and MTM1.
000: MTtim (timer count value)
001: MT_cap (timer capture)
010: MT_per (timer period)
011: MT_cmp1 (timer compare 1)
100: MT_cmp2 (timer compare 2)
101 to 111: Reserved
MTM0</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MTM0</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>MAC Timer multiplexed register 0</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MTM0</name>
              <description>[7:0] Indirectly returns and modifies bits [7:0] of an internal register depending on the value of MTMSEL.MTMSEL.
When reading the MTM0 register with MTMSEL.MTMSEL set to 000 and MTCTRL.LATCH_MODE set to 0, the timer (MTtim) value is latched.
When reading the MTM0 register with MTMSEL.MTMSEL set to 000 and MTCTRL.LATCH_MODE set to 1, the timer (MTtim) and overflow counter (MTovf) values are latched.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MTM1</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>MAC Timer multiplexed register 1</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MTM1</name>
              <description>[7:0] Indirectly returns and modifies bits [15:8] of an internal register, depending on the value of MTMSEL.MTMSEL.
When reading the MTM0 register with MTMSEL.MTMSEL set to 000, the timer (MTtim) value is latched.
Reading this register with MTMSEL.MTMSEL set to 000 returns the latched value of MTtim[15:8].</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MTMOVF2</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>MAC Timer multiplexed overflow register 2</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MTMOVF2</name>
              <description>[7:0] Indirectly returns and modifies bits [23:16] of an internal register, depending on the value of MTMSEL.MTMOVFSEL.
Reading this register with MTMSEL.MTMOVFSEL set to 000 returns the latched value of MTovf[23:16].</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MTMOVF1</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>MAC Timer multiplexed overflow register 1</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MTMOVF1</name>
              <description>[7:0] Indirectly returns and modifies bits [15:8] of an internal register, depending on the value of MTMSEL.MTMSEL.
Reading this register with MTMSEL.MTMOVFSEL set to 000 returns the latched value of MTovf[15:8].</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MTMOVF0</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>MAC Timer multiplexed overflow register 0</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MTMOVF0</name>
              <description>[7:0] Indirectly returns and modifies bits [7:0] of an internal register, depending on the value of MTMSEL.MTMOVFSEL.
When reading the MTMOVF0 register with MTMSEL.MTMOVFSEL set to 000 and MTCTRL.LATCH_MODE set to 0, the overflow counter value (MTovf) is latched.
When reading the MTM0 register with MTMSEL.MTMOVFSEL set to 000 and MTCTRL.LATCH_MODE set to 1, the overflow counter value (MTovf) is latched.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RFDATA</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>The TX FIFO and RX FIFO may be accessed through this register. Data is written to the TX FIFO when writing to the RFD register. Data is read from the RX FIFO when the RFD register is read. The XREG registers RXFIFOCNT and TXFIFOCNT provide information on the amount of data in the FIFOs. The FIFO contents can be cleared by issuing SFLUSHRX and SFLUSHTX.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RFD</name>
              <description>[7:0] Data written to the register is written to the TX FIFO. When reading this register, data from the RX FIFO is read.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RFERRF</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>RF error interrupt flags</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved</name>
              <description>[7:7] Reserved. Read as 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>STROBEERR</name>
              <description>[6:6] A command strobe was issued when it could not be processed.
Triggered if trying to disable the radio when it is already disabled, or when trying to do a SACK, SACKPEND, or SNACK command when not in active RX.
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TXUNDERF</name>
              <description>[5:5] TX FIFO underflowed.
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TXOVERF</name>
              <description>[4:4] TX FIFO overflowed.
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RXUNDERF</name>
              <description>[3:3] RX FIFO underflowed.
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RXOVERF</name>
              <description>[2:2] RX FIFO overflowed.
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RXABO</name>
              <description>[1:1] Reception of a frame was aborted.
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>NLOCK</name>
              <description>[0:0] The frequency synthesizer failed to achieve lock after time-out, or lock is lost during reception. The receiver must be restarted to clear this error situation.
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RFIRQF1</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>RF interrupt flags</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved</name>
              <description>[7:6] Reserved. Read as 0.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>CSP_WAIT</name>
              <description>[5:5] Execution continued after a wait instruction in CSP.
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>CSP_STOP</name>
              <description>[4:4] CSP has stopped program execution.
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>CSP_MANINT</name>
              <description>[3:3] Manual interrupt generated from CSP
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RFIDLE</name>
              <description>[2:2] Radio state-machine has entered the IDLE state.
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TXDONE</name>
              <description>[1:1] A complete frame has been transmitted.
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TXACKDONE</name>
              <description>[0:0] An acknowledgement frame has been completely transmitted.
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RFIRQF0</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>RF interrupt flags</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RXMASKZERO</name>
              <description>[7:7] The RXENABLE register has gone from a nonzero state to an all-zero state.
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RXPKTDONE</name>
              <description>[6:6] A complete frame has been received.
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>FRAME_ACCEPTED</name>
              <description>[5:5] Frame has passed frame filtering.
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>SRC_MATCH_FOUND</name>
              <description>[4:4] Source match is found.
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SRC_MATCH_DONE</name>
              <description>[3:3] Source matching is complete.
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>FIFOP</name>
              <description>[2:2] The number of bytes in the RX FIFO is greater than the threshold. Also raised when a complete frame is received, and when a packet is read out completely and more complete packets are available.
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SFD</name>
              <description>[1:1] SFD has been received or transmitted.
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ACT_UNUSED</name>
              <description>[0:0] Reserved
0: No interrupt pending
1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RFST</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>RF CSMA-CA/strobe processor</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>INSTR</name>
              <description>[7:0] Data written to this register is written to the CSP instruction memory. Reading this register returns the CSP instruction currently being executed.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USB</name>
      <baseAddress>0x40089000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00000100</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>ADDR</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Function address</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>UPDATE</name>
              <description>[7:7] This bit is set by hardware when writing to this register, and is cleared by hardware when the new address becomes effective.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>USBADDR</name>
              <description>[6:0] Device address. 
The address shall be updated upon successful completion of the status stage of the SET_ADDRESS request.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>POW</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Power management and control register</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ISOWAITSOF</name>
              <description>[7:7] For isochronous mode IN endpoints:
When set,  the USB controller will wait for an SOF token from the time USB_CSIL.INPKTRDY is set before sending the packet. If an IN token is received before an SOF token, then a zero length data
packet will be sent.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>Reserved7</name>
              <description>[6:4] Reserved</description>
              <bitWidth>3</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RST</name>
              <description>[3:3] Indicates that reset signaling is present on the bus</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RESUME</name>
              <description>[2:2] Drives resume signaling for remote wakeup
According to the USB Specification, the resume signal must be held active for at least 1 ms and no more than 15 ms. It is recommended to keep this bit set for approximately 10 ms.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SUSPEND</name>
              <description>[1:1] Indicates entry into suspend mode
Suspend mode must be enabled by setting USB_POW.SUSPENDEN
Software clears this bit by reading the USB_CIF register or by asserting USB_POW.RESUME</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SUSPENDEN</name>
              <description>[0:0] Enables detection of and entry into suspend mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IIF</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Interrupt flags for endpoint 0 and IN endpoints 1-5</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:6] Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>INEP5IF</name>
              <description>[5:5] Interrupt flag for IN endpoint 5
Cleared by hardware when read</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INEP4IF</name>
              <description>[4:4] Interrupt flag for IN endpoint 4
Cleared by hardware when read</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>INEP3IF</name>
              <description>[3:3] Interrupt flag for IN endpoint 3
Cleared by hardware when read</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>INEP2IF</name>
              <description>[2:2] Interrupt flag for IN endpoint 2
Cleared by hardware when read</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>INEP1IF</name>
              <description>[1:1] Interrupt flag for IN endpoint 1
Cleared by hardware when read</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>EP0IF</name>
              <description>[0:0] Interrupt flag for endpoint 0
Cleared by hardware when read</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>OIF</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Interrupt flags for OUT endpoints 1-5</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:6] Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>OUTEP5IF</name>
              <description>[5:5] Interrupt flag for OUT endpoint 5
Cleared by hardware when read</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>OUTEP4IF</name>
              <description>[4:4] Interrupt flag for OUT endpoint 4
Cleared by hardware when read</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>OUTEP3IF</name>
              <description>[3:3] Interrupt flag for OUT endpoint 3
Cleared by hardware when read</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>OUTEP2IF</name>
              <description>[2:2] Interrupt flag for OUT endpoint 2
Cleared by hardware when read</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>OUTEP1IF</name>
              <description>[1:1] Interrupt flag for OUT endpoint 1
Cleared by hardware when read</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[0:0] Reserved</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CIF</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Common USB interrupt flags</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:4] Reserved</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SOFIF</name>
              <description>[3:3] Start-of-frame interrupt flag
Cleared by hardware when read</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RSTIF</name>
              <description>[2:2] Reset interrupt flag
Cleared by hardware when read</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RESUMEIF</name>
              <description>[1:1] Resume interrupt flag
Cleared by hardware when read</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SUSPENDIF</name>
              <description>[0:0] Suspend interrupt flag
Cleared by hardware when read</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IIE</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Interrupt enable mask for IN endpoints 1-5 and endpoint 0</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:6] Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>INEP5IE</name>
              <description>[5:5] Interrupt enable for IN endpoint 5
0: Interrupt disabled
1: Interrupt enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INEP4IE</name>
              <description>[4:4] Interrupt enable for IN endpoint 4
0: Interrupt disabled
1: Interrupt enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>INEP3IE</name>
              <description>[3:3] Interrupt enable for IN endpoint 3
0: Interrupt disabled
1: Interrupt enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>INEP2IE</name>
              <description>[2:2] Interrupt enable for IN endpoint 2
0: Interrupt disabled
1: Interrupt enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>INEP1IE</name>
              <description>[1:1] Interrupt enable for IN endpoint 1
0: Interrupt disabled
1: Interrupt enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>EP0IE</name>
              <description>[0:0] Interrupt enable for endpoint 0
0: Interrupt disabled
1: Interrupt enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>OIE</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Interrupt enable mask for OUT endpoints 1-5</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>reserved8</name>
              <description>[7:6] Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>OUTEP5IE</name>
              <description>[5:5] Interrupt enable for OUT endpoint 5
0: Interrupt disabled
1: Interrupt enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>OUTEP4IE</name>
              <description>[4:4] Interrupt enable for OUT endpoint 4
0: Interrupt disabled
1: Interrupt enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>OUTEP3IE</name>
              <description>[3:3] Interrupt enable for OUT endpoint 3
0: Interrupt disabled
1: Interrupt enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>OUTEP2IE</name>
              <description>[2:2] Interrupt enable for OUT endpoint 2
0: Interrupt disabled
1: Interrupt enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>OUTEP1IE</name>
              <description>[1:1] Interrupt enable for OUT endpoint 1
0: Interrupt disabled
1: Interrupt enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[0:0] Reserved</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CIE</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>Common USB interrupt enable mask</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:4] Reserved</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SOFIE</name>
              <description>[3:3] Start-of-frame interrupt enable
0: Interrupt disabled
1: Interrupt enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RSTIE</name>
              <description>[2:2] Reset interrupt enable
0: Interrupt disabled
1: Interrupt enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RESUMEIE</name>
              <description>[1:1] Resume interrupt enable
0: Interrupt disabled
1: Interrupt enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SUSPENDIE</name>
              <description>[0:0] Suspend interrupt enable
0: Interrupt disabled
1: Interrupt enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FRML</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>Frame number (low byte)</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>FRAMEL</name>
              <description>[7:0] Bits 7:0 of the 11-bit frame number
The frame number is only updated upon successful reception of SOF tokens</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FRMH</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Frame number (high byte)</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:3] Reserved</description>
              <bitWidth>5</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>FRAMEH</name>
              <description>[2:0] Bits 10:8 of the 11-bit frame number
The frame number is only updated upon successful reception of SOF tokens</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>INDEX</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Index register for selecting the endpoint status and control registers</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:4] Reserved</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>USBINDEX</name>
              <description>[3:0] Index of the currently selected endpoint
The index is set to 0 to enable access to endpoint 0 control and status registers
The index is set to 1, 2, 3, 4 or 5 to enable access to IN/OUT endpoint 1, 2, 3, 4 or 5 control and status registers, respectively</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTRL</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>USB peripheral control register</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PLLLOCKED</name>
              <description>[7:7] PLL lock status. The PLL is locked when USB_CTRL.PLLLOCKED is 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>Reserved7</name>
              <description>[6:3] Reserved</description>
              <bitWidth>4</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[2:2] Reserved.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PLLEN</name>
              <description>[1:1] 48 MHz USB PLL enable
When this bit is set, the 48 MHz PLL is started. Software must avoid access to other USB registers before the PLL has locked; that is, USB_CTRL.PLLLOCKED is 1. This bit can be set only when USB_CTRL.USBEN is 1.
The PLL must be disabled before entering PM1 when suspended, and must be re-enabled when resuming operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>USBEN</name>
              <description>[0:0] USB enable
The USB controller is reset when this bit is cleared</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MAXI</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>Indexed register:
For USB_INDEX = 1-5: Maximum packet size for IN endpoint {1-5}</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>USBMAXI</name>
              <description>[7:0] Maximum packet size, in units of 8 bytes, for the selected IN endpoint
The value of this register should match the wMaxPacketSize field in the standard endpoint descriptor for the endpoint. The value must not exceed the available memory.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CS0_CSIL</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>Indexed register:
For USB_INDEX = 0: Endpoint 0 control and status
For USB_INDEX = 1-5: IN endpoint {1-5} control and status (low byte)</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CLRSETUPEND_or_Reserved8</name>
              <description>[7:7] USB_CS0.CLRSETUPEND [RW]:
Software sets this bit to clear the USB_CS0.SETUPEND bit. It is cleared automatically.

USB_CSIL.Reserved [RO]:
Reserved</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>CLROUTPKTRDY_or_CLRDATATOG</name>
              <description>[6:6] USB_CS0.CLROUTPKTRDY [RW]:
Software sets this bit to clear the USB_CS0.OUTPKTRDY bit. It is cleared automatically.

USB_CSIL.CLRDATATOG [RW]:
Software sets this bit to reset the IN endpoint data toggle to 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SENDSTALL_or_SENTSTALL</name>
              <description>[5:5] USB_CS0.SENDSTALL [RW]:
Software sets this bit to terminate the current transaction with a STALL handshake. The bit is cleared automatically when the STALL handshake has been transmitted.

USB_CSIL.SENTSTALL [RW]:
For bulk/interrupt mode IN endpoints:
This bit is set when a STALL handshake is transmitted. The FIFO is flushed and the USB_CSIL.INPKTRDY bit cleared. Software should clear this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>SETUPEND_or_SENDSTALL</name>
              <description>[4:4] USB_CS0.SETUPEND [RO]:
This bit is set when a control transaction ends before the USB_CS0.DATAEND bit has been set. An interrupt is generated and the FIFO flushed at this time. Software clears this bit by setting USB_CS0.CLRSETUPEND.

CSIL.SENDSTALL [RW]:
For bulk/interrupt mode IN endpoints: 
Software sets this bit to issue a STALL handshake. 
Software clears this bit to terminate the stall condition.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DATAEND_or_FLUSHPACKET</name>
              <description>[3:3] USB_CS0.DATAEND [RW]:
This bit is used to signal the end of the data stage, and must be set:
1. When the last data packet is loaded and USB_CS0.INPKTRDY is set.
2. When the last data packet is unloaded and USB_CS0.CLROUTPKTRDY is set.
3. When USB_CS0.INPKTRDY is set to send a zero-length packet.
The USB controller clears this bit automatically.

USB_CSIL.FLUSHPACKET [RW]:
Software sets this bit to flush the next packet to be transmitted from the IN endpoint FIFO. The FIFO pointer is reset and the USB_CSIL.INPKTRDY bit is cleared. 
Note: If the FIFO contains two packets, USB_CSIL.FLUSHPACKET will need to be set twice to completely clear the FIFO.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>SENTSTALL_or_UNDERRUN</name>
              <description>[2:2] USB_CS0.SENTSTALL [RW]: 
This bit is set when a STALL handshake is sent. An interrupt is generated is generated when this bit is set. Software must clear this bit.

USB_CSIL.UNDERRUN [RW]: 
In isochronous mode, this bit is set when a zero length data packet is sent after receiving an IN token with USB_CSIL.INPKTRDY not set. 
In bulk/interrupt mode, this bit is set when a NAK is returned in
response to an IN token. Software should clear this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>INPKTRDY_or_PKTPRESENT</name>
              <description>[1:1] USB_CS0. INPKTRDY [RW]: 
Software sets this bit after loading a data packet into the endpoint 0 FIFO. It is cleared automatically when the data packet has been transmitted. An interrupt is generated when the bit is cleared.

USB_CSIL.PKTPRESENT [RO]:
This bit is set when there is at least one packet in the IN endpoint FIFO.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>OUTPKTRDY_or_INPKTRDY</name>
              <description>[0:0] USB_CS0.OUTPKTRDY [RO]:
Endpoint 0 data packet received
An interrupt request (EP0) is generated if the interrupt is enabled. Software must read the endpoint 0 FIFO empty, and clear this bit by setting USB_CS0.CLROUTPKTRDY

USB_CSIL.INPKTRDY [RW]:
IN endpoint {1-5} packet transfer pending
Software sets this bit after loading a data packet into the FIFO. It is cleared automatically when a data packet has been transmitted. An interrupt is generated (if enabled) when the bit is cleared.
When using double-buffering, the bit is cleared immediately if the other FIFO is empty.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSIH</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>Indexed register:
For USB_INDEX = 1-5: IN endpoint {1-5} control and status (high byte)</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>AUTISET</name>
              <description>[7:7] If set by software, the USB_CSIL.INPKTRDY bit is automatically set when a data packet of maximum size (specified by USBMAXI) is loaded into the IN endpoint FIFO. If a packet of less than the maximum packet size is loaded, then USB_CSIL.INPKTRDY will have to be set manually.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>ISO</name>
              <description>[6:6] Selects IN endpoint type:
0: Bulk/interrupt
1: Isochronous</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>Reserved5</name>
              <description>[5:5] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>Reserved4</name>
              <description>[4:4] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>FORCEDATATOG</name>
              <description>[3:3] Software sets this bit to force the IN endpoint's data toggle to switch after each data packet is sent regardless of whether an ACK was received. This can be used by interrupt IN endpoints which are
used to communicate rate feedback for isochronous endpoints.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>Reserved2</name>
              <description>[2:1] Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>INDBLBUF</name>
              <description>[0:0] IN endpoint FIFO double-buffering enable:
0: Double buffering disabled
1: Double buffering enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MAXO</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>Indexed register:
For USB_INDEX = 1-5: Maximum packet size for OUT endpoint {1-5}</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>USBMAXO</name>
              <description>[7:0] Maximum packet size, in units of 8 bytes, for the selected OUT endpoint
The value of this register should match the wMaxPacketSize field in the standard endpoint descriptor for the endpoint. The value must not exceed the available memory.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSOL</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>Indexed register:
For USB_INDEX = 1-5: OUT endpoint {1-5} control and status (low byte)</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CLRDATATOG</name>
              <description>[7:7] Software sets this bit to reset the endpoint data toggle to 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SENTSTALL</name>
              <description>[6:6] This bit is set when a STALL handshake is transmitted. An interrupt is generated when this bit is set. Software should clear this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SENDSTALL</name>
              <description>[5:5] For bulk/interrupt mode OUT endpoints:
Software sets this bit to issue a STALL handshake. 
Software clears this bit to terminate the stall condition.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>FLUSHPACKET</name>
              <description>[4:4] Software sets this bit to flush the next packet to be read from the endpoint OUT FIFO.
Note: If the FIFO contains two packets, USB_CSOL.FLUSHPACKET will need to be set twice to completely clear the FIFO.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DATAERROR</name>
              <description>[3:3] For isochronous mode OUT endpoints:
This bit is set when USB_CSOL.OUTPKTRDY is set if the data packet has a CRC or bit-stuff error. It is cleared automatically when USB_CSOL.OUTPKTRDY is cleared.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>OVERRUN</name>
              <description>[2:2] For isochronous mode OUT endpoints:
This bit is set when an OUT packet cannot be loaded into the OUT endpoint FIFO. Firmware should clear this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>FIFOFULL</name>
              <description>[1:1] This bit is set when no more packets can be loaded into the OUT endpoint FIFO.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>OUTPKTRDY</name>
              <description>[0:0] This bit is set when a data packet has been received. Software should clear this bit when the packet has been unloaded from the OUT endpoint FIFO. An interrupt is generated when the bit is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CSOH</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>Indexed register:
For USB_INDEX = 1-5: OUT endpoint {1-5} control and status (high byte)</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>AUTOCLEAR</name>
              <description>[7:7] If software sets this bit, the USB_CSOL.OUTPKTRDY bit will be automatically cleared when a packet of maximum size (specified by USB_MAXO) has been unloaded from the OUT FIFO. When packets of less than the maximum packet size are unloaded, USB_CSOL.OUTPKTRDY will have to be cleared manually.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>ISO</name>
              <description>[6:6] Selects OUT endpoint type:
0: Bulk/interrupt
1: Isochronous</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>Reserved5</name>
              <description>[5:5] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>Reserved4</name>
              <description>[4:4] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[3:1] Reserved</description>
              <bitWidth>3</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>OUTDBLBUF</name>
              <description>[0:0] OUT endpoint FIFO double-buffering enable:
0: Double buffering disabled
1: Double buffering enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CNT0_CNTL</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>Indexed register:
For USB_INDEX = 0: Number of received bytes in the endpoint 0 FIFO 
For USB_INDEX = 1-5: Number of received bytes in the OUT endpoint {1-5} FIFO (low byte)</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>FIFOCNT_or_FIFOCNTL</name>
              <description>[7:0] USB_CS0.FIFOCNT (USBINDEX = 0) [RO]:
Number of bytes received in the packet in the endpoint 0 FIFO
Valid only when USB_CS0.OUTPKTRDY is set

USB_CSIL.FIFOCNTL (USBINDEX = 1 to 5) [RW]:
Bits 7:0 of the of the number of bytes received in the packet in the OUT endpoint {1-5} FIFO
Valid only when USB_CSOL.OUTPKTRDY is set</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CNTH</name>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <description>Indexed register:
For USB_INDEX = 1-5: Number of received in the OUT endpoint {1-5} FIFO (high byte)</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:3] Reserved</description>
              <bitWidth>5</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>FIFOCNTH</name>
              <description>[2:0] Bits 10:8 of the of the number of bytes received in the packet in the OUT endpoint {1-5} FIFO
Valid only when USB_CSOL.OUTPKTRDY is set</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>F0</name>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <description>Endpoint 0 FIFO</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>USBF0</name>
              <description>[7:0] Endpoint 0 FIFO
Reading this register unloads one byte from the endpoint 0 FIFO.
Writing to this register loads one byte into the endpoint 0 FIFO.
The FIFO memory for EP0 is used for incoming and outgoing data packets.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>F1</name>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <description>IN/OUT endpoint 1 FIFO</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>USBF1</name>
              <description>[7:0] Endpoint 1 FIFO register
Reading this register unloads one byte from the EP1 OUT FIFO. Writing to this register loads one byte into the EP1 IN FIFO.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>F2</name>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <description>IN/OUT endpoint 2 FIFO</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>USBF2</name>
              <description>[7:0] Endpoint 2 FIFO register
Reading this register unloads one byte from the EP2 OUT FIFO. Writing to this register loads one byte into the EP2 IN FIFO.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>F3</name>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <description>IN/OUT endpoint 3 FIFO</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>USBF3</name>
              <description>[7:0] Endpoint 3 FIFO register
Reading this register unloads one byte from the EP3 OUT FIFO. Writing to this register loads one byte into the EP3 IN FIFO.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>F4</name>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <description>IN/OUT endpoint 4 FIFO</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>USBF4</name>
              <description>[7:0] Endpoint 4 FIFO register
Reading this register unloads one byte from the EP4 OUT FIFO. Writing to this register loads one byte into the EP4 IN FIFO.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>F5</name>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <description>IN/OUT endpoint 5 FIFO</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>USBF5</name>
              <description>[7:0] Endpoint 5 FIFO register
Reading this register unloads one byte from the EP5 OUT FIFO. Writing to this register loads one byte into the EP5 IN FIFO.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AES</name>
      <baseAddress>0x4008B000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00001000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>DMAC_CH0_CTRL</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Channel control
This register is used for channel enabling and priority selection. When a channel is disabled, it becomes inactive only when all ongoing requests are finished.</description>
          <fields>
            <field>
              <name>Reserved30</name>
              <description>[31:2] Should be written with 0s and ignored on read</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PRIO</name>
              <description>[1:1] Channel priority
0: Low
1: High
If both channels have the same priority, access of the channels to the external port is arbitrated using the round robin scheme. If one channel has a high priority and another one low, the channel with the high priority is served first, in case of simultaneous access requests.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[0:0] Channel enable
0: Disabled
1: Enable
Note: Disabling an active channel interrupts the DMA operation. The ongoing block transfer completes, but no new transfers are requested.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMAC_CH0_EXTADDR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Channel external address</description>
          <fields>
            <field>
              <name>ADDR</name>
              <description>[31:0] Channel external address value
When read during operation, it holds the last updated external address after being sent to the master interface.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMAC_CH0_DMALENGTH</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Channel DMA length</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Should be written with 0s and ignored on read</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DMALEN</name>
              <description>[15:0] Channel DMA length in bytes
During configuration, this register contains the DMA transfer length in bytes. During operation, it contains the last updated value of the DMA transfer length after being sent to the master interface.
Note: Setting this register to a nonzero value starts the transfer if the channel is enabled. Therefore, this register must be written last when setting up a DMA channel.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMAC_STATUS</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>DMAC status
This register provides the actual state of each DMA channel. It also reports port errors in case these were received by the master interface module during the data transfer.</description>
          <fields>
            <field>
              <name>Reserved14</name>
              <description>[31:18] Bits should be ignored on read.</description>
              <bitWidth>14</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>PORT_ERR</name>
              <description>[17:17] Reflects possible transfer errors on the AHB port.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>Reserved15</name>
              <description>[16:2] Bits should be ignored on read.</description>
              <bitWidth>15</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CH1_ACT</name>
              <description>[1:1] A value of 1 indicates that channel 1 is active (DMA transfer on-going).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CH0_ACT</name>
              <description>[0:0] A value of 1 indicates that channel 0 is active (DMA transfer on-going).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMAC_SWRES</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>DMAC software reset register
Software reset is used to reset the DMAC to stop all transfers and clears the port error status register. After the software reset is performed, all the channels are disabled and no new requests are performed by the channels. The DMAC waits for the existing (active) requests to finish and accordingly sets the DMAC status registers.</description>
          <fields>
            <field>
              <name>Reserved31</name>
              <description>[31:1] Bits should be written with a value of 0.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SWRES</name>
              <description>[0:0] Software reset enable
0 = Disabled
1 = Enabled (self-cleared to 0)
Completion of the software reset must be checked through the DMAC_STATUS register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMAC_CH1_CTRL</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Channel control
This register is used for channel enabling and priority selection. When a channel is disabled, it becomes inactive only when all ongoing requests are finished.</description>
          <fields>
            <field>
              <name>Reserved30</name>
              <description>[31:2] Should be written with 0s and ignored on read</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PRIO</name>
              <description>[1:1] Channel priority
0: Low
1: High
If both channels have the same priority, access of the channels to the external port is arbitrated using the round robin scheme. If one channel has a high priority and another one low, the channel with the high priority is served first, in case of simultaneous access requests.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[0:0] Channel enable
0: Disabled
1: Enable
Note: Disabling an active channel interrupts the DMA operation. The ongoing block transfer completes, but no new transfers are requested.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMAC_CH1_EXTADDR</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Channel external address</description>
          <fields>
            <field>
              <name>ADDR</name>
              <description>[31:0] Channel external address value.
When read during operation, it holds the last updated external address after being sent to the master interface.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMAC_CH1_DMALENGTH</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>Channel DMA length</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Should be written with 0s and ignored on read</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DMALEN</name>
              <description>[15:0] Channel DMA length in bytes.
During configuration, this register contains the DMA transfer length in bytes. During operation, it contains the last updated value of the DMA transfer length after being sent to the master interface.
Note: Setting this register to a nonzero value starts the transfer if the channel is enabled. Therefore, this register must be written last when setting up a DMA channel.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMAC_MST_RUNPARAMS</name>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <description>DMAC master run-time parameters
This register defines all the run-time parameters for the AHB master interface port. These parameters are required for the proper functioning of the EIP-101m AHB master adapter.</description>
          <fields>
            <field>
              <name>Reserved16</name>
              <description>[31:16] Should be written with 0s and ignored on read</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>AHB_MST1_BURST_SIZE</name>
              <description>[15:12] Maximum burst size that can be performed on the AHB bus
0010b = 4 bytes (default)
0011b = 8 bytes
0100b = 16 bytes
0101b = 32 bytes
0110b = 64 bytes
Others = Reserved</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>AHB_MST1_IDLE_EN</name>
              <description>[11:11] Idle insertion between consecutive burst transfers on AHB
0: No Idle insertion
1: Idle insertion</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>AHB_MST1_INCR_EN</name>
              <description>[10:10] Burst length type of AHB transfer
0: Unspecified length burst transfers
1: Fixed length burst or single transfers</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>AHB_MST1_LOCK_EN</name>
              <description>[9:9] Locked transform on AHB
0: Transfers are not locked
1: Transfers are locked</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>AHB_MST1_BIGEND</name>
              <description>[8:8] Endianess for the AHB master
0: Little endian
1: Big endian</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:0] Should be written with 0s and ignored on read</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMAC_PERSR</name>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <description>DMAC port error raw status register
This register provides the actual status of individual port errors. It also indicates which channel is serviced by an external AHB port (which is frozen by a port error). A port error aborts operations on all serviced channels (channel enable bit is forced to 0) and prevents further transfers via that port until the error is cleared by writing to the DMAC_SWRES register.</description>
          <fields>
            <field>
              <name>Reserved19</name>
              <description>[31:13] Bits should be ignored on read</description>
              <bitWidth>19</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PORT1_AHB_ERROR</name>
              <description>[12:12] A value of 1 indicates that the EIP-101 has detected an AHB bus error</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>Reserved2</name>
              <description>[11:10] Bits should be ignored on read</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PORT1_CHANNEL</name>
              <description>[9:9] Indicates which channel has serviced last (channel 0 or channel 1) by AHB master port.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>Reserved9</name>
              <description>[8:0] Bits should be ignored on read</description>
              <bitWidth>9</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMAC_OPTIONS</name>
          <addressOffset>0xf8</addressOffset>
          <size>32</size>
          <description>DMAC options register
These registers contain information regarding the different options configured in this DMAC.</description>
          <fields>
            <field>
              <name>Reserved20</name>
              <description>[31:12] Bits should be ignored on read</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>NR_OF_CHANNELS</name>
              <description>[11:8] Number of channels implemented, value in the range 1-8.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved5</name>
              <description>[7:3] Bits should be ignored on read</description>
              <bitWidth>5</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>NR_OF_PORTS</name>
              <description>[2:0] Number of ports implemented, value in range 1-4.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DMAC_VERSION</name>
          <addressOffset>0xfc</addressOffset>
          <size>32</size>
          <description>DMAC version register
This register contains an indication (or signature) of the EIP type of this DMAC, as well as the hardware version/patch numbers.</description>
          <fields>
            <field>
              <name>Reserved4</name>
              <description>[31:28] Bits should be ignored on read</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>HW_MAJOR_VERSION</name>
              <description>[27:24] Major version number</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>HW_MINOR_VERSION</name>
              <description>[23:20] Minor version number</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>HW_PATCH_LEVEL</name>
              <description>[19:16] Patch level
Starts at 0 at first delivery of this version</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>EIP_NUMBER_COMPL</name>
              <description>[15:8] Bit-by-bit complement of the EIP_NUMBER field bits.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EIP_NUMBER</name>
              <description>[7:0] Binary encoding of the EIP-number of this DMA controller (209)</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY_STORE_WRITE_AREA</name>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <description>Key store write area register
This register defines where the keys should be written in the key store RAM. After writing this register, the key store module is ready to receive the keys through a DMA operation. In case the key data transfer triggered an error in the key store, the error will be available in the interrupt status register after the DMA is finished. The key store write-error is asserted when the programmed/selected area is not completely written. This error is also asserted when the DMA operation writes to ram areas that are not selected.
The key store RAM is divided into 8 areas of 128 bits.
192-bit keys written in the key store RAM should start on boundaries of 256 bits. This means that writing a 192-bit key to the key store RAM must be done by writing 256 bits of data with the 64 most-significant bits set to 0. These bits are ignored by the AES engine.</description>
          <fields>
            <field>
              <name>Reserved1</name>
              <description>[31:8] Write 0s and ignore on reading</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RAM_AREA7</name>
              <description>[7:7] Each RAM_AREAx represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written
0: RAM_AREA7 is not selected to be written.
1: RAM_AREA7 is selected to be written.
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RAM_AREA6</name>
              <description>[6:6] Each RAM_AREAx represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written
0: RAM_AREA6 is not selected to be written.
1: RAM_AREA6 is selected to be written.
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>RAM_AREA5</name>
              <description>[5:5] Each RAM_AREAx represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written
0: RAM_AREA5 is not selected to be written.
1: RAM_AREA5 is selected to be written.
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RAM_AREA4</name>
              <description>[4:4] Each RAM_AREAx represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written
0: RAM_AREA4 is not selected to be written.
1: RAM_AREA4 is selected to be written.
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RAM_AREA3</name>
              <description>[3:3] Each RAM_AREAx represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written
0: RAM_AREA3 is not selected to be written.
1: RAM_AREA3 is selected to be written.
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RAM_AREA2</name>
              <description>[2:2] Each RAM_AREAx represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written
0: RAM_AREA2 is not selected to be written.
1: RAM_AREA2 is selected to be written.
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RAM_AREA1</name>
              <description>[1:1] Each RAM_AREAx represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written
0: RAM_AREA1 is not selected to be written.
1: RAM_AREA1 is selected to be written.
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RAM_AREA0</name>
              <description>[0:0] Each RAM_AREAx represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written
0: RAM_AREA0 is not selected to be written.
1: RAM_AREA0 is selected to be written.
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY_STORE_WRITTEN_AREA</name>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <description>Key store written area register
This register shows which areas of the key store RAM contain valid written keys.
When a new key needs to be written to the key store, on a location that is already occupied by a valid key, this key area must be cleared first. This can be done by writing this register before the new key is written to the key store memory.
Attempting to write to a key area that already contains a valid key is not allowed and results in an error.</description>
          <fields>
            <field>
              <name>Reserved1</name>
              <description>[31:8] Write 0s and ignore on reading</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RAM_AREA_WRITTEN7</name>
              <description>[7:7] Read operation:
0: This RAM area is not written with valid key information.
1: This RAM area is written with valid key information.

Each individual ram_area_writtenx bit can be reset by writing 1.

Note: This register is reset on a soft reset from the master control module. After a soft reset, all keys must be rewritten to the key store memory.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RAM_AREA_WRITTEN6</name>
              <description>[6:6] Read operation:
0: This RAM area is not written with valid key information.
1: This RAM area is written with valid key information.

Each individual ram_area_writtenx bit can be reset by writing 1.

Note: This register is reset on a soft reset from the master control module. After a soft reset, all keys must be rewritten to the key store memory.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>RAM_AREA_WRITTEN5</name>
              <description>[5:5] Read operation:
0: This RAM area is not written with valid key information.
1: This RAM area is written with valid key information.

Each individual ram_area_writtenx bit can be reset by writing 1.

Note: This register is reset on a soft reset from the master control module. After a soft reset, all keys must be rewritten to the key store memory.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RAM_AREA_WRITTEN4</name>
              <description>[4:4] Read operation:
0: This RAM area is not written with valid key information.
1: This RAM area is written with valid key information.

Each individual ram_area_writtenx bit can be reset by writing 1.

Note: This register is reset on a soft reset from the master control module. After a soft reset, all keys must be rewritten to the key store memory.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RAM_AREA_WRITTEN3</name>
              <description>[3:3] Read operation:
0: This RAM area is not written with valid key information.
1: This RAM area is written with valid key information.

Each individual ram_area_writtenx bit can be reset by writing 1.

Note: This register is reset on a soft reset from the master control module. After a soft reset, all keys must be rewritten to the key store memory.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RAM_AREA_WRITTEN2</name>
              <description>[2:2] Read operation:
0: This RAM area is not written with valid key information.
1: This RAM area is written with valid key information.

Each individual ram_area_writtenx bit can be reset by writing 1.

Note: This register is reset on a soft reset from the master control module. After a soft reset, all keys must be rewritten to the key store memory.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RAM_AREA_WRITTEN1</name>
              <description>[1:1] Read operation:
0: This RAM area is not written with valid key information.
1: This RAM area is written with valid key information.

Each individual ram_area_writtenx bit can be reset by writing 1.

Note: This register is reset on a soft reset from the master control module. After a soft reset, all keys must be rewritten to the key store memory.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RAM_AREA_WRITTEN0</name>
              <description>[0:0] Read operation:
0: This RAM area is not written with valid key information.
1: This RAM area is written with valid key information.

Each individual ram_area_writtenx bit can be reset by writing 1.

Note: This register is reset on a soft reset from the master control module. After a soft reset, all keys must be rewritten to the key store memory.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY_STORE_SIZE</name>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <description>Key store size register
This register defines the size of the keys that are written with DMA. This register should be configured before writing to the KEY_STORE_WRITE_AREA register.</description>
          <fields>
            <field>
              <name>Reserved1</name>
              <description>[31:2] Write 0s and ignore on reading</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>KEY_SIZE</name>
              <description>[1:0] Key size:
00: Reserved
01: 128 bits
10: 192 bits
11: 256 bits
When writing this to this register, the KEY_STORE_WRITTEN_AREA register is reset.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>KEY_STORE_READ_AREA</name>
          <addressOffset>0x40c</addressOffset>
          <size>32</size>
          <description>Key store read area register
This register selects the key store RAM area from where the key needs to be read that will be used for an AES operation. The operation directly starts after writing this register. When the operation is finished, the status of the key store read operation is available in the interrupt status register. Key store read error is asserted when a RAM area is selected which does not contain valid written key.</description>
          <fields>
            <field>
              <name>BUSY</name>
              <description>[31:31] Key store operation busy status flag (read only):
0: Operation is complete.
1: Operation is not completed and the key store is busy.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[30:4] Write 0s and ignore on reading</description>
              <bitWidth>27</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RAM_AREA</name>
              <description>[3:0] Selects the area of the key store RAM from where the key needs to be read that will be writen to the AES engine
RAM_AREA:
0000: RAM_AREA0
0001: RAM_AREA1
0010: RAM_AREA2
0011: RAM_AREA3
0100: RAM_AREA4
0101: RAM_AREA5
0110: RAM_AREA6
0111: RAM_AREA7
1000: no RAM area selected
1001-1111:  Reserved
RAM areas RAM_AREA0, RAM_AREA2, RAM_AREA4 and RAM_AREA6 are the only valid read areas for 192 and 256 bits key sizes.
Only RAM areas that contain valid written keys can be selected.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_KEY2_0</name>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <description>AES_KEY2_0 / AES_GHASH_H_IN_0
Second Key / GHASH Key (internal, but clearable)
The following registers are not accessible through the host for reading and writing. They are used to store internally calculated key information and intermediate results. However, when the host performs a write to the any of the respective AES_KEY2_n or AES_KEY3_n addresses, respectively the whole 128-bit AES_KEY2_n or AES_KEY3_n register is cleared to 0s.
The AES_GHASH_H_IN_n registers (required for GHASH, which is part of GCM) are mapped to the AES_KEY2_n registers. The (intermediate) authentication result for GCM and CCM is stored in the AES_KEY3_n register.</description>
          <fields>
            <field>
              <name>AES_KEY2</name>
              <description>[31:0] AES_KEY2/AES_GHASH_H[31:0]

For GCM: 
-[127:0] - GHASH_H - The internally calculated GHASH key is stored in these registers. Only used for modes that use the GHASH function (GCM).
-[255:128] - This register is used to store intermediate values and is initialized with 0s when loading a new key.

For CCM:
-[255:0] - This register is used to store intermediate values.

For CBC-MAC:
-[255:0] - ZEROES - This register must remain 0.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_KEY2_1</name>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <description>AES_KEY2_1 / AES_GHASH_H_IN_1
Second Key / GHASH Key (internal, but clearable)
The following registers are not accessible through the host for reading and writing. They are used to store internally calculated key information and intermediate results. However, when the host performs a write to the any of the respective AES_KEY2_n or AES_KEY3_n addresses, respectively the whole 128-bit AES_KEY2_n or AES_KEY3_n register is cleared to 0s.
The AES_GHASH_H_IN_n registers (required for GHASH, which is part of GCM) are mapped to the AES_KEY2_n registers. The (intermediate) authentication result for GCM and CCM is stored in the AES_KEY3_n register.</description>
          <fields>
            <field>
              <name>AES_KEY2</name>
              <description>[31:0] AES_KEY2/AES_GHASH_H[63:32]

For GCM: 
-[127:0] - GHASH_H - The internally calculated GHASH key is stored in these registers. Only used for modes that use the GHASH function (GCM).
-[255:128] - This register is used to store intermediate values and is initialized with 0s when loading a new key.

For CCM:
-[255:0] - This register is used to store intermediate values.

For CBC-MAC:
-[255:0] - ZEROES - This register must remain 0.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_KEY2_2</name>
          <addressOffset>0x508</addressOffset>
          <size>32</size>
          <description>AES_KEY2_2 / AES_GHASH_H_IN_2
Second Key / GHASH Key (internal, but clearable)
The following registers are not accessible through the host for reading and writing. They are used to store internally calculated key information and intermediate results. However, when the host performs a write to the any of the respective AES_KEY2_n or AES_KEY3_n addresses, respectively the whole 128-bit AES_KEY2_n or AES_KEY3_n register is cleared to 0s.
The AES_GHASH_H_IN_n registers (required for GHASH, which is part of GCM) are mapped to the AES_KEY2_n registers. The (intermediate) authentication result for GCM and CCM is stored in the AES_KEY3_n register.</description>
          <fields>
            <field>
              <name>AES_KEY2</name>
              <description>[31:0] AES_KEY2/AES_GHASH_H[95:64]

For GCM: 
-[127:0] - GHASH_H - The internally calculated GHASH key is stored in these registers. Only used for modes that use the GHASH function (GCM).
-[255:128] - This register is used to store intermediate values and is initialized with 0s when loading a new key.

For CCM:
-[255:0] - This register is used to store intermediate values.

For CBC-MAC:
-[255:0] - ZEROES - This register must remain 0.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_KEY2_3</name>
          <addressOffset>0x50c</addressOffset>
          <size>32</size>
          <description>AES_KEY2_3 / AES_GHASH_H_IN_3
Second Key / GHASH Key (internal, but clearable)
The following registers are not accessible through the host for reading and writing. They are used to store internally calculated key information and intermediate results. However, when the host performs a write to the any of the respective AES_KEY2_n or AES_KEY3_n addresses, respectively the whole 128-bit AES_KEY2_n or AES_KEY3_n register is cleared to 0s.
The AES_GHASH_H_IN_n registers (required for GHASH, which is part of GCM) are mapped to the AES_KEY2_n registers. The (intermediate) authentication result for GCM and CCM is stored in the AES_KEY3_n register.</description>
          <fields>
            <field>
              <name>AES_KEY2</name>
              <description>[31:0] AES_KEY2/AES_GHASH_H[127:96]

For GCM: 
-[127:0] - GHASH_H - The internally calculated GHASH key is stored in these registers. Only used for modes that use the GHASH function (GCM).
-[255:128] - This register is used to store intermediate values and is initialized with 0s when loading a new key.

For CCM:
-[255:0] - This register is used to store intermediate values.

For CBC-MAC:
-[255:0] - ZEROES - This register must remain 0.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_KEY3_0</name>
          <addressOffset>0x510</addressOffset>
          <size>32</size>
          <description>AES_KEY3_0 / AES_KEY2_4
Third Key / Second Key (internal, but clearable)
The following registers are not accessible through the host for reading and writing. They are used to store internally calculated key information and intermediate results. However, when the host performs a write to the any of the respective AES_KEY2_n or AES_KEY3_n addresses, respectively the whole 128-bit AES_KEY2_n or AES_KEY3_n register is cleared to 0s.
The AES_GHASH_H_IN_n registers (required for GHASH, which is part of GCM) are mapped to the AES_KEY2_n registers. The (intermediate) authentication result for GCM and CCM is stored in the AES_KEY3_n register.</description>
          <fields>
            <field>
              <name>AES_KEY3</name>
              <description>[31:0] AES_KEY3[31:0]/AES_KEY2[159:128]

For GCM: 
-[127:0] - GHASH_H - The internally calculated GHASH key is stored in these registers. Only used for modes that use the GHASH function (GCM).
-[255:128] - This register is used to store intermediate values and is initialized with 0s when loading a new key.

For CCM:
-[255:0] - This register is used to store intermediate values.

For CBC-MAC:
-[255:0] - ZEROES - This register must remain 0.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_KEY3_1</name>
          <addressOffset>0x514</addressOffset>
          <size>32</size>
          <description>AES_KEY3_1 / AES_KEY2_5
Third Key / Second Key (internal, but clearable)
The following registers are not accessible through the host for reading and writing. They are used to store internally calculated key information and intermediate results. However, when the host performs a write to the any of the respective AES_KEY2_n or AES_KEY3_n addresses, respectively the whole 128-bit AES_KEY2_n or AES_KEY3_n register is cleared to 0s.
The AES_GHASH_H_IN_n registers (required for GHASH, which is part of GCM) are mapped to the AES_KEY2_n registers. The (intermediate) authentication result for GCM and CCM is stored in the AES_KEY3_n register.</description>
          <fields>
            <field>
              <name>AES_KEY3</name>
              <description>[31:0] AES_KEY3[63:32]/AES_KEY2[191:160]

For GCM: 
-[127:0] - GHASH_H - The internally calculated GHASH key is stored in these registers. Only used for modes that use the GHASH function (GCM).
-[255:128] - This register is used to store intermediate values and is initialized with 0s when loading a new key.

For CCM:
-[255:0] - This register is used to store intermediate values.

For CBC-MAC:
-[255:0] - ZEROES - This register must remain 0.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_KEY3_2</name>
          <addressOffset>0x518</addressOffset>
          <size>32</size>
          <description>AES_KEY3_2 / AES_KEY2_6
Third Key / Second Key (internal, but clearable)
The following registers are not accessible through the host for reading and writing. They are used to store internally calculated key information and intermediate results. However, when the host performs a write to the any of the respective AES_KEY2_n or AES_KEY3_n addresses, respectively the whole 128-bit AES_KEY2_n or AES_KEY3_n register is cleared to 0s.
The AES_GHASH_H_IN_n registers (required for GHASH, which is part of GCM) are mapped to the AES_KEY2_n registers. The (intermediate) authentication result for GCM and CCM is stored in the AES_KEY3_n register.</description>
          <fields>
            <field>
              <name>AES_KEY3</name>
              <description>[31:0] AES_KEY3[95:64]/AES_KEY2[223:192]

For GCM: 
-[127:0] - GHASH_H - The internally calculated GHASH key is stored in these registers. Only used for modes that use the GHASH function (GCM).
-[255:128] - This register is used to store intermediate values and is initialized with 0s when loading a new key.

For CCM:
-[255:0] - This register is used to store intermediate values.

For CBC-MAC:
-[255:0] - ZEROES - This register must remain 0.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_KEY3_3</name>
          <addressOffset>0x51c</addressOffset>
          <size>32</size>
          <description>AES_KEY3_3 / AES_KEY2_7
Third Key / Second Key (internal, but clearable)
The following registers are not accessible through the host for reading and writing. They are used to store internally calculated key information and intermediate results. However, when the host performs a write to the any of the respective AES_KEY2_n or AES_KEY3_n addresses, respectively the whole 128-bit AES_KEY2_n or AES_KEY3_n register is cleared to 0s.
The AES_GHASH_H_IN_n registers (required for GHASH, which is part of GCM) are mapped to the AES_KEY2_n registers. The (intermediate) authentication result for GCM and CCM is stored in the AES_KEY3_n register.</description>
          <fields>
            <field>
              <name>AES_KEY3</name>
              <description>[31:0] AES_KEY3[127:96]/AES_KEY2[255:224]

For GCM: 
-[127:0] - GHASH_H - The internally calculated GHASH key is stored in these registers. Only used for modes that use the GHASH function (GCM).
-[255:128] - This register is used to store intermediate values and is initialized with 0s when loading a new key.

For CCM:
-[255:0] - This register is used to store intermediate values.

For CBC-MAC:
-[255:0] - ZEROES - This register must remain 0.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_IV_0</name>
          <addressOffset>0x540</addressOffset>
          <size>32</size>
          <description>AES initialization vector registers
These registers are used to provide and read the IV from the AES engine.</description>
          <fields>
            <field>
              <name>AES_IV</name>
              <description>[31:0] AES_IV[31:0]

Initialization vector
Used for regular non-ECB modes (CBC/CTR):
-[127:0] - AES_IV - For regular AES operations (CBC and CTR) these registers must be written with a new 128-bit IV. After an operation, these registers contain the latest 128-bit result IV, generated by the EIP-120t. If CTR mode is selected, this value is incremented with 0x1: After first use - When a new data block is submitted to the engine

For GCM:
-[127:0] - AES_IV - For GCM operations, these registers must be written with a new 128-bit IV.
After an operation, these registers contain the updated 128-bit result IV, generated by the EIP-120t. Note that bits [127:96] of the IV represent the initial counter value (which is 1 for GCM) and must therefore be initialized to 0x01000000. This value is incremented with 0x1: After first use - When a new data block is submitted to the engine.

For CCM:
-[127:0] - A0: For CCM this field must be written with value A0, this value is the concatenation of: A0-flags (5-bits of 0 and 3-bits 'L'), Nonce and counter value. 'L' must be a copy from the 'L' value of the AES_CTRL register. This 'L' indicates the width of the Nonce and counter. The loaded counter must be initialized to 0. The total width of A0 is 128-bit.

For CBC-MAC:
-[127:0] - Zeroes - For CBC-MAC this register must be written with 0s at the start of each operation. After an operation, these registers contain the 128-bit TAG output, generated by the EIP-120t.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_IV_1</name>
          <addressOffset>0x544</addressOffset>
          <size>32</size>
          <description>AES initialization vector registers
These registers are used to provide and read the IV from the AES engine.</description>
          <fields>
            <field>
              <name>AES_IV</name>
              <description>[31:0] AES_IV[63:32]

Initialization vector
Used for regular non-ECB modes (CBC/CTR):
-[127:0] - AES_IV - For regular AES operations (CBC and CTR) these registers must be written with a new 128-bit IV. After an operation, these registers contain the latest 128-bit result IV, generated by the EIP-120t. If CTR mode is selected, this value is incremented with 0x1: After first use - When a new data block is submitted to the engine

For GCM:
-[127:0] - AES_IV - For GCM operations, these registers must be written with a new 128-bit IV.
After an operation, these registers contain the updated 128-bit result IV, generated by the EIP-120t. Note that bits [127:96] of the IV represent the initial counter value (which is 1 for GCM) and must therefore be initialized to 0x01000000. This value is incremented with 0x1: After first use - When a new data block is submitted to the engine.

For CCM:
-[127:0] - A0: For CCM this field must be written with value A0, this value is the concatenation of: A0-flags (5-bits of 0 and 3-bits 'L'), Nonce and counter value. 'L' must be a copy from the 'L' value of the AES_CTRL register. This 'L' indicates the width of the Nonce and counter. The loaded counter must be initialized to 0. The total width of A0 is 128-bit.

For CBC-MAC:
-[127:0] - Zeroes - For CBC-MAC this register must be written with 0s at the start of each operation. After an operation, these registers contain the 128-bit TAG output, generated by the EIP-120t.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_IV_2</name>
          <addressOffset>0x548</addressOffset>
          <size>32</size>
          <description>AES initialization vector registers
These registers are used to provide and read the IV from the AES engine.</description>
          <fields>
            <field>
              <name>AES_IV</name>
              <description>[31:0] AES_IV[95:64]

Initialization vector
Used for regular non-ECB modes (CBC/CTR):
-[127:0] - AES_IV - For regular AES operations (CBC and CTR) these registers must be written with a new 128-bit IV. After an operation, these registers contain the latest 128-bit result IV, generated by the EIP-120t. If CTR mode is selected, this value is incremented with 0x1: After first use - When a new data block is submitted to the engine

For GCM:
-[127:0] - AES_IV - For GCM operations, these registers must be written with a new 128-bit IV.
After an operation, these registers contain the updated 128-bit result IV, generated by the EIP-120t. Note that bits [127:96] of the IV represent the initial counter value (which is 1 for GCM) and must therefore be initialized to 0x01000000. This value is incremented with 0x1: After first use - When a new data block is submitted to the engine.

For CCM:
-[127:0] - A0: For CCM this field must be written with value A0, this value is the concatenation of: A0-flags (5-bits of 0 and 3-bits 'L'), Nonce and counter value. 'L' must be a copy from the 'L' value of the AES_CTRL register. This 'L' indicates the width of the Nonce and counter. The loaded counter must be initialized to 0. The total width of A0 is 128-bit.

For CBC-MAC:
-[127:0] - Zeroes - For CBC-MAC this register must be written with 0s at the start of each operation. After an operation, these registers contain the 128-bit TAG output, generated by the EIP-120t.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_IV_3</name>
          <addressOffset>0x54c</addressOffset>
          <size>32</size>
          <description>AES initialization vector registers
These registers are used to provide and read the IV from the AES engine.</description>
          <fields>
            <field>
              <name>AES_IV</name>
              <description>[31:0] AES_IV[127:96]

Initialization vector
Used for regular non-ECB modes (CBC/CTR):
-[127:0] - AES_IV - For regular AES operations (CBC and CTR) these registers must be written with a new 128-bit IV. After an operation, these registers contain the latest 128-bit result IV, generated by the EIP-120t. If CTR mode is selected, this value is incremented with 0x1: After first use - When a new data block is submitted to the engine

For GCM:
-[127:0] - AES_IV - For GCM operations, these registers must be written with a new 128-bit IV.
After an operation, these registers contain the updated 128-bit result IV, generated by the EIP-120t. Note that bits [127:96] of the IV represent the initial counter value (which is 1 for GCM) and must therefore be initialized to 0x01000000. This value is incremented with 0x1: After first use - When a new data block is submitted to the engine.

For CCM:
-[127:0] - A0: For CCM this field must be written with value A0, this value is the concatenation of: A0-flags (5-bits of 0 and 3-bits 'L'), Nonce and counter value. 'L' must be a copy from the 'L' value of the AES_CTRL register. This 'L' indicates the width of the Nonce and counter. The loaded counter must be initialized to 0. The total width of A0 is 128-bit.

For CBC-MAC:
-[127:0] - Zeroes - For CBC-MAC this register must be written with 0s at the start of each operation. After an operation, these registers contain the 128-bit TAG output, generated by the EIP-120t.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_CTRL</name>
          <addressOffset>0x550</addressOffset>
          <size>32</size>
          <description>AES input/output buffer control and mode register
This register specifies the AES mode of operation for the EIP-120t.
Electronic codebook (ECB) mode is automatically selected if bits [28:5] of this register are all 0.</description>
          <fields>
            <field>
              <name>context_ready</name>
              <description>[31:31] If 1, this read-only status bit indicates that the context data registers can be overwritten and the host is permitted to write the next context.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>saved_context_ready</name>
              <description>[30:30] If 1, this status bit indicates that an AES authentication TAG and/or IV block(s) is/are available for the host to retrieve. This bit is only asserted if the save_context bit is set to 1. The bit is mutual exclusive with the context_ready bit.
Writing one clears the bit to 0, indicating the AES core can start its next operation. This bit is also cleared when the 4th word of the output TAG and/or IV is read.
Note: All other mode bit writes are ignored when this mode bit is written with 1.
Note: This bit is controlled automatically by the EIP-120t for TAG read DMA operations.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>save_context</name>
              <description>[29:29] This bit indicates that an authentication TAG or result IV needs to be stored as a result context.
Typically this bit must be set for authentication modes returning a TAG (CBC-MAC, GCM and CCM), or for basic encryption modes that require future continuation with the current result IV.
If this bit is set, the engine retains its full context until the TAG and/or IV registers are read.
The TAG or IV must be read before the AES engine can start a new operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[28:25] Bits should be written with a value of 0. and ignored on a read.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>CCM_M</name>
              <description>[24:22] Defines M, which indicates the length of the authentication field for CCM operations; the authentication field length equals two times (the value of CCM-M plus one).
Note: The EIP-120t always returns a 128-bit authentication field, of which the M least significant bytes are valid. All values are supported.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>CCM_L</name>
              <description>[21:19] Defines L, which indicates the width of the length field for CCM operations; the length field in bytes equals the value of CMM-L plus one. All values are supported.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>CCM</name>
              <description>[18:18] If set to 1, AES-CCM is selected
AES-CCM is a combined mode, using AES for authentication and encryption.
Note: Selecting AES-CCM mode requires writing of the AAD length register after all other registers.
Note: The CTR mode bit in this register must also be set to 1 to enable AES-CTR; selecting other AES modes than CTR mode is invalid.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>GCM</name>
              <description>[17:16] Set these bits to 11 to select AES-GCM mode.
AES-GCM is a combined mode, using the Galois field multiplier GF(2 to the power of 128) for authentication and AES-CTR mode for encryption.
Note: The CTR mode bit in this register must also be set to 1 to enable AES-CTR
Bit combination description:
00 = No GCM mode
01 = Reserved, do not select
10 = Reserved, do not select
11 = Autonomous GHASH (both H- and Y0-encrypted calculated internally)
Note: The EIP-120t-1 configuration only supports mode 11 (autonomous GHASH), other GCM modes are not allowed.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CBC_MAC</name>
              <description>[15:15] Set to 1 to select AES-CBC MAC mode.
The direction bit must be set to 1 for this mode.
Selecting this mode requires writing the length register after all other registers.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>Reserved2</name>
              <description>[14:9] Bits should be written with a value of 0. and ignored on a read.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>ctr_width</name>
              <description>[8:7] Specifies the counter width for AES-CTR mode
00 = 32-bit counter
01 = 64-bit counter
10 = 96-bit counter
11 = 128-bit counter</description>
              <bitWidth>2</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>CTR</name>
              <description>[6:6] If set to 1, AES counter mode (CTR) is selected.
Note: This bit must also be set for GCM and CCM, when encryption/decryption is required.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>CBC</name>
              <description>[5:5] If set to 1, cipher-block-chaining (CBC) mode is selected.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>key_size</name>
              <description>[4:3] This read-only field specifies the key size.
The key size is automatically configured when a new key is loaded through the key store module.
00 = N/A - Reserved
01 = 128-bit
10 = 192-bit
11 = 256-bit</description>
              <bitWidth>2</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>direction</name>
              <description>[2:2] If set to 1 an encrypt operation is performed.
If set to 0 a decrypt operation is performed.
This bit must be written with a 1 when CBC-MAC is selected.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>input_ready</name>
              <description>[1:1] If 1, this status bit indicates that the 16-byte AES input buffer is empty. The host is permitted to write the next block of data.
Writing 0 clears the bit to 0 and indicates that the AES core can use the provided input data block.
Writing 1 to this bit is ignored.
Note: For DMA operations, this bit is automatically controlled by the EIP-120t.
After reset, this bit is 0. After writing a context, this bit becomes 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>output_ready</name>
              <description>[0:0] If 1, this status bit indicates that an AES output block is available to be retrieved by the host.
Writing 0 clears the bit to 0 and indicates that output data is read by the host. The AES core can provide a next output data block.
Writing 1 to this bit is ignored.
Note: For DMA operations, this bit is automatically controlled by the EIP-120t.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_C_LENGTH_0</name>
          <addressOffset>0x554</addressOffset>
          <size>32</size>
          <description>AES crypto length registers (LSW)
These registers are used to write the Length values to the EIP-120t. While processing, the length values decrement to 0. If both lengths are 0, the data stream is finished and a new context is requested. For basic AES modes (ECB, CBC, and CTR), a crypto length of 0 can be written if multiple streams need to be processed with the same key. Writing 0 length results in continued data requests until a new context is written. For the other modes (CBC-MAC, GCM, and CCM) no (new) data requests are done if the length decrements to or equals 0.
It is advised to write a new length per packet. If the length registers decrement to 0, no new data is processed until a new context or length value is written.
When writing a new mode without writing the length registers, the length register values from the previous context is reused.</description>
          <fields>
            <field>
              <name>C_LENGTH</name>
              <description>[31:0] C_LENGTH[31:0]
Bits [60:0] of the crypto length registers (LSW and MSW) store the cryptographic data length in bytes for all modes. Once processing with this context is started, this length decrements to 0. Data lengths up to (261: 1) bytes are allowed.
For GCM, any value up to 236 - 32 bytes can be used. This is because a 32-bit counter mode is used; the maximum number of 128-bit blocks is 232 - 2, resulting in a maximum number of bytes of 236 - 32.
A write to this register triggers the engine to start using this context. This is valid for all modes except GCM and CCM.
Note: For the combined modes (GCM and CCM), this length does not include the authentication only data; the authentication length is specified in the AES_AUTH_LENGTH register below.
All modes must have a length greater than 0. For the combined modes, it is allowed to have one of the lengths equal to 0.
For the basic encryption modes (ECB, CBC, and CTR) it is allowed to program zero to the length field; in that case the length is assumed infinite.
All data must be byte (8-bit) aligned for stream cipher modes; bit aligned data streams are not supported by the EIP-120t. For block cipher modes, the data length must be programmed in multiples of the block cipher size, 16 bytes.
For a host read operation, these registers return all-0s.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_C_LENGTH_1</name>
          <addressOffset>0x558</addressOffset>
          <size>32</size>
          <description>AES crypto length registers (MSW)
These registers are used to write the Length values to the EIP-120t. While processing, the length values decrement to 0. If both lengths are 0, the data stream is finished and a new context is requested. For basic AES modes (ECB, CBC, and CTR), a crypto length of 0 can be written if multiple streams need to be processed with the same key. Writing 0 length results in continued data requests until a new context is written. For the other modes (CBC-MAC, GCM and CCM) no (new) data requests are done if the length decrements to or equals 0.
It is advised to write a new length per packet. If the length registers decrement to 0, no new data is processed until a new context or length value is written.
When writing a new mode without writing the length registers, the length register values from the previous context is reused.</description>
          <fields>
            <field>
              <name>Reserved1</name>
              <description>[31:29] Bits should be written with a value of 0. and ignored on a read.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>C_LENGTH</name>
              <description>[28:0] C_LENGTH[60:32]
Bits [60:0] of the crypto length registers (LSW and MSW) store the cryptographic data length in bytes for all modes. Once processing with this context is started, this length decrements to 0. Data lengths up to (261: 1) bytes are allowed.
For GCM, any value up to 236 - 32 bytes can be used. This is because a 32-bit counter mode is used; the maximum number of 128-bit blocks is 232 - 2, resulting in a maximum number of bytes of 236 - 32.
A write to this register triggers the engine to start using this context. This is valid for all modes except GCM and CCM.
Note: For the combined modes (GCM and CCM), this length does not include the authentication only data; the authentication length is specified in the AES_AUTH_LENGTH register below.
All modes must have a length greater than 0. For the combined modes, it is allowed to have one of the lengths equal to 0.
For the basic encryption modes (ECB, CBC, and CTR) it is allowed to program zero to the length field; in that case the length is assumed infinite.
All data must be byte (8-bit) aligned for stream cipher modes; bit aligned data streams are not supported by the EIP-120t. For block cipher modes, the data length must be programmed in multiples of the block cipher size, 16 bytes.
For a host read operation, these registers return all-0s.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_AUTH_LENGTH</name>
          <addressOffset>0x55c</addressOffset>
          <size>32</size>
          <description>Authentication length register</description>
          <fields>
            <field>
              <name>AUTH_LENGTH</name>
              <description>[31:0] Bits [31:0] of the authentication length register store the authentication data length in bytes for combined modes only (GCM or CCM).
Supported AAD-lengths for CCM are from 0 to (2^16 - 2^8) bytes. For GCM any value up to (2^32 - 1) bytes can be used. Once processing with this context is started, this length decrements to 0.
A write to this register triggers the engine to start using this context for GCM and CCM.
For a host read operation, these registers return all-0s.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_DATA_IN_OUT_0</name>
          <addressOffset>0x560</addressOffset>
          <size>32</size>
          <description>Data input/output registers
The data registers are typically accessed through the DMA and not with host writes and/or reads. However, for debugging purposes the data input/output registers can be accessed via host write and read operations. The registers are used to buffer the input/output data blocks to/from the EIP-120t.
Note: The data input buffer (AES_DATA_IN_n) and data output buffer (AES_DATA_OUT_n) are mapped to the same address locations.
Writes (both DMA and host) to these addresses load the Input Buffer while reads pull from the Output Buffer. Therefore, for write access, the data input buffer is written; for read access, the data output buffer is read. The data input buffer must be written before starting an operation. The data output buffer contains valid data on completion of an operation. Therefore, any 128-bit data block can be split over multiple 32-bit word transfers; these can be mixed with other host transfers over the external interface.</description>
          <fields>
            <field>
              <name>AES_DATA_IN_OUT</name>
              <description>[31:0] AES input data[31:0] / AES output data[31:0]
Data registers for input/output block data to/from the EIP-120t.
For normal operations, this register is not used, since data input and output is transferred from and to the AES core via DMA. For a host write operation, these registers must be written with the 128-bit input block for the next AES operation. Writing at a word-aligned offset within this address range stores the word (4 bytes) of data into the corresponding position of 4-word deep (16 bytes = 128-bit AES block) data input buffer. This buffer is used for the next AES operation. If the last data block is not completely filled with valid data (see notes below), it is allowed to write only the words with valid data. Next AES operation is triggered by writing to the input_ready flag of the AES_CTRL register.
For a host read operation, these registers contain the 128-bit output block from the latest AES operation. Reading from a word-aligned offset within this address range reads one word (4 bytes) of data out the 4-word deep (16 bytes = 128-bits AES block) data output buffer. The words (4 words, one full block) should be read before the core will move the next block to the data output buffer. To empty the data output buffer, the output_ready flag of the AES_CTRL register must be written.
For the modes with authentication (CBC-MAC, GCM and CCM), the invalid (message) bytes/words can be written with any data.
Note: AES typically operates on 128 bits block multiple input data. The CTR, GCM and CCM modes form an exception. The last block of a CTR-mode message may contain less than 128 bits (refer to [NIST 800-38A]). For GCM/CCM, the last block of both AAD and message data may contain less than 128 bits (refer to [NIST 800-38D]). The EIP-120t automatically pads or masks misaligned ending data blocks with 0s for GCM, CCM and CBC-MAC. For CTR mode, the remaining data in an unaligned data block is ignored.
Note: The AAD / authentication only data is not copied to the output buffer but only used for authentication.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_DATA_IN_OUT_1</name>
          <addressOffset>0x564</addressOffset>
          <size>32</size>
          <description>Data Input/Output Registers
The data registers are typically accessed via DMA and not with host writes and/or reads. However, for debugging purposes the Data Input/Output Registers can be accessed via host write and read operations. The registers are used to buffer the input/output data blocks to/from the EIP-120t.
Note: The data input buffer (AES_DATA_IN_n) and data output buffer (AES_DATA_OUT_n) are mapped to the same address locations.
Writes (both DMA and host) to these addresses load the Input Buffer while reads pull from the Output Buffer. Therefore, for write access, the data input buffer is written; for read access, the data output buffer is read. The data input buffer must be written before starting an operation. The data output buffer contains valid data on completion of an operation. Therefore, any 128-bit data block can be split over multiple 32-bit word transfers; these can be mixed with other host transfers over the external interface.</description>
          <fields>
            <field>
              <name>AES_DATA_IN_OUT</name>
              <description>[31:0] AES input data[63:32] / AES output data[63:32]
Data registers for input/output block data to/from the EIP-120t.
For normal operations, this register is not used, since data input and output is transferred from and to the AES core via DMA. For a host write operation, these registers must be written with the 128-bit input block for the next AES operation. Writing at a word-aligned offset within this address range stores the word (4 bytes) of data into the corresponding position of 4-word deep (16 bytes = 128-bit AES block) data input buffer. This buffer is used for the next AES operation. If the last data block is not completely filled with valid data (see notes below), it is allowed to write only the words with valid data. Next AES operation is triggered by writing to the input_ready flag of the AES_CTRL register.
For a host read operation, these registers contain the 128-bit output block from the latest AES operation. Reading from a word-aligned offset within this address range reads one word (4 bytes) of data out the 4-word deep (16 bytes = 128-bits AES block) data output buffer. The words (4 words, one full block) should be read before the core will move the next block to the data output buffer. To empty the data output buffer, the output_ready flag of the AES_CTRL register must be written.
For the modes with authentication (CBC-MAC, GCM and CCM), the invalid (message) bytes/words can be written with any data.
Note: AES typically operates on 128 bits block multiple input data. The CTR, GCM and CCM modes form an exception. The last block of a CTR-mode message may contain less than 128 bits (refer to [NIST 800-38A]). For GCM/CCM, the last block of both AAD and message data may contain less than 128 bits (refer to [NIST 800-38D]). The EIP-120t automatically pads or masks misaligned ending data blocks with 0s for GCM, CCM and CBC-MAC. For CTR mode, the remaining data in an unaligned data block is ignored.
Note: The AAD / authentication only data is not copied to the output buffer but only used for authentication.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_DATA_IN_OUT_2</name>
          <addressOffset>0x568</addressOffset>
          <size>32</size>
          <description>Data Input/Output Registers
The data registers are typically accessed via DMA and not with host writes and/or reads. However, for debugging purposes the Data Input/Output Registers can be accessed via host write and read operations. The registers are used to buffer the input/output data blocks to/from the EIP-120t.
Note: The data input buffer (AES_DATA_IN_n) and data output buffer (AES_DATA_OUT_n) are mapped to the same address locations.
Writes (both DMA and host) to these addresses load the Input Buffer while reads pull from the Output Buffer. Therefore, for write access, the data input buffer is written; for read access, the data output buffer is read. The data input buffer must be written before starting an operation. The data output buffer contains valid data on completion of an operation. Therefore, any 128-bit data block can be split over multiple 32-bit word transfers; these can be mixed with other host transfers over the external interface.</description>
          <fields>
            <field>
              <name>AES_DATA_IN_OUT</name>
              <description>[31:0] AES input data[95:64] / AES output data[95:64]
Data registers for input/output block data to/from the EIP-120t.
For normal operations, this register is not used, since data input and output is transferred from and to the AES core via DMA. For a host write operation, these registers must be written with the 128-bit input block for the next AES operation. Writing at a word-aligned offset within this address range stores the word (4 bytes) of data into the corresponding position of 4-word deep (16 bytes = 128-bit AES block) data input buffer. This buffer is used for the next AES operation. If the last data block is not completely filled with valid data (see notes below), it is allowed to write only the words with valid data. Next AES operation is triggered by writing to the input_ready flag of the AES_CTRL register.
For a host read operation, these registers contain the 128-bit output block from the latest AES operation. Reading from a word-aligned offset within this address range reads one word (4 bytes) of data out the 4-word deep (16 bytes = 128-bits AES block) data output buffer. The words (4 words, one full block) should be read before the core will move the next block to the data output buffer. To empty the data output buffer, the output_ready flag of the AES_CTRL register must be written.
For the modes with authentication (CBC-MAC, GCM and CCM), the invalid (message) bytes/words can be written with any data.
Note: AES typically operates on 128 bits block multiple input data. The CTR, GCM and CCM modes form an exception. The last block of a CTR-mode message may contain less than 128 bits (refer to [NIST 800-38A]). For GCM/CCM, the last block of both AAD and message data may contain less than 128 bits (refer to [NIST 800-38D]). The EIP-120t automatically pads or masks misaligned ending data blocks with 0s for GCM, CCM and CBC-MAC. For CTR mode, the remaining data in an unaligned data block is ignored.
Note: The AAD / authentication only data is not copied to the output buffer but only used for authentication.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_DATA_IN_OUT_3</name>
          <addressOffset>0x56c</addressOffset>
          <size>32</size>
          <description>Data Input/Output Registers
The data registers are typically accessed via DMA and not with host writes and/or reads. However, for debugging purposes the Data Input/Output Registers can be accessed via host write and read operations. The registers are used to buffer the input/output data blocks to/from the EIP-120t.
Note: The data input buffer (AES_DATA_IN_n) and data output buffer (AES_DATA_OUT_n) are mapped to the same address locations.
Writes (both DMA and host) to these addresses load the Input Buffer while reads pull from the Output Buffer. Therefore, for write access, the data input buffer is written; for read access, the data output buffer is read. The data input buffer must be written before starting an operation. The data output buffer contains valid data on completion of an operation. Therefore, any 128-bit data block can be split over multiple 32-bit word transfers; these can be mixed with other host transfers over the external interface.</description>
          <fields>
            <field>
              <name>AES_DATA_IN_OUT</name>
              <description>[31:0] AES input data[127:96] / AES output data[127:96]
Data registers for input/output block data to/from the EIP-120t.
For normal operations, this register is not used, since data input and output is transferred from and to the AES core via DMA. For a host write operation, these registers must be written with the 128-bit input block for the next AES operation. Writing at a word-aligned offset within this address range stores the word (4 bytes) of data into the corresponding position of 4-word deep (16 bytes = 128-bit AES block) data input buffer. This buffer is used for the next AES operation. If the last data block is not completely filled with valid data (see notes below), it is allowed to write only the words with valid data. Next AES operation is triggered by writing to the input_ready flag of the AES_CTRL register.
For a host read operation, these registers contain the 128-bit output block from the latest AES operation. Reading from a word-aligned offset within this address range reads one word (4 bytes) of data out the 4-word deep (16 bytes = 128-bits AES block) data output buffer. The words (4 words, one full block) should be read before the core will move the next block to the data output buffer. To empty the data output buffer, the output_ready flag of the AES_CTRL register must be written.
For the modes with authentication (CBC-MAC, GCM and CCM), the invalid (message) bytes/words can be written with any data.
Note: AES typically operates on 128 bits block multiple input data. The CTR, GCM and CCM modes form an exception. The last block of a CTR-mode message may contain less than 128 bits (refer to [NIST 800-38A]). For GCM/CCM, the last block of both AAD and message data may contain less than 128 bits (refer to [NIST 800-38D]). The EIP-120t automatically pads or masks misaligned ending data blocks with 0s for GCM, CCM and CBC-MAC. For CTR mode, the remaining data in an unaligned data block is ignored.
Note: The AAD / authentication only data is not copied to the output buffer but only used for authentication.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_TAG_OUT_0</name>
          <addressOffset>0x570</addressOffset>
          <size>32</size>
          <description>TAG registers
The tag registers can be accessed via DMA or directly with host reads.
These registers buffer the TAG from the EIP-120t. The registers are shared with the intermediate authentication result registers, but cannot be read until the processing is finished. While processing, a read from these registers returns 0s. If an operation does not return a TAG, reading from these registers returns an IV. If an operation returns a TAG plus an IV and both need to be read by the host, the host must first read the TAG followed by the IV. Reading these in reverse order will return the IV twice.</description>
          <fields>
            <field>
              <name>AES_TAG</name>
              <description>[31:0] AES_TAG[31:0]
Bits [31:0] of the AES_TAG registers store the authentication value for the combined and authentication only modes.
For a host read operation, these registers contain the last 128-bit TAG output of the EIP-120t; the TAG is available until the next context is written.
This register will only contain valid data if the TAG is available and when the store_ready bit from AES_CTRL register is set. During processing or for operations/modes that do not return a TAG, reads from this register return data from the IV register.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_TAG_OUT_1</name>
          <addressOffset>0x574</addressOffset>
          <size>32</size>
          <description>TAG registers
The tag registers can be accessed via DMA or directly with host reads.
These registers buffer the TAG from the EIP-120t. The registers are shared with the intermediate authentication result registers, but cannot be read until the processing is finished. While processing, a read from these registers returns 0s. If an operation does not return a TAG, reading from these registers returns an IV. If an operation returns a TAG plus an IV and both need to be read by the host, the host must first read the TAG followed by the IV. Reading these in reverse order returns the IV twice.</description>
          <fields>
            <field>
              <name>AES_TAG</name>
              <description>[31:0] AES_TAG[63:32]
For a host read operation, these registers contain the last 128-bit TAG output of the EIP-120t; the TAG is available until the next context is written.
This register contains valid data only if the TAG is available and when the store_ready bit from AES_CTRL register is set. During processing or for operations/modes that do not return a TAG, reads from this register return data from the IV register.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_TAG_OUT_2</name>
          <addressOffset>0x578</addressOffset>
          <size>32</size>
          <description>TAG registers
The tag registers can be accessed via DMA or directly with host reads.
These registers buffer the TAG from the EIP-120t. The registers are shared with the intermediate authentication result registers, but cannot be read until the processing is finished. While processing, a read from these registers returns 0s. If an operation does not return a TAG, reading from these registers returns an IV. If an operation returns a TAG plus an IV and both need to be read by the host, the host must first read the TAG followed by the IV. Reading these in reverse order returns the IV twice.</description>
          <fields>
            <field>
              <name>AES_TAG</name>
              <description>[31:0] AES_TAG[95:64]
For a host read operation, these registers contain the last 128-bit TAG output of the EIP-120t; the TAG is available until the next context is written.
This register contains valid data only if the TAG is available and when the store_ready bit from AES_CTRL register is set. During processing or for operations/modes that do not return a TAG, reads from this register return data from the IV register.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AES_TAG_OUT_3</name>
          <addressOffset>0x57c</addressOffset>
          <size>32</size>
          <description>TAG registers
The tag registers can be accessed via DMA or directly with host reads.
These registers buffer the TAG from the EIP-120t. The registers are shared with the intermediate authentication result registers, but cannot be read until the processing is finished. While processing, a read from these registers returns 0s. If an operation does not return a TAG, reading from these registers returns an IV. If an operation returns a TAG plus an IV and both need to be read by the host, the host must first read the TAG followed by the IV. Reading these in reverse order returns the IV twice.</description>
          <fields>
            <field>
              <name>AES_TAG</name>
              <description>[31:0] AES_TAG[127:96]
For a host read operation, these registers contain the last 128-bit TAG output of the EIP-120t; the TAG is available until the next context is written.
This register contains valid data only if the TAG is available and when the store_ready bit from AES_CTRL register is set. During processing or for operations/modes that do not return a TAG, reads from this register return data from the IV register.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DATA_IN_0</name>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <description>HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface.</description>
          <fields>
            <field>
              <name>HASH_DATA_IN</name>
              <description>[31:0] HASH_DATA_IN[31:0]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine's internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DATA_IN_1</name>
          <addressOffset>0x604</addressOffset>
          <size>32</size>
          <description>HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface.</description>
          <fields>
            <field>
              <name>HASH_DATA_IN</name>
              <description>[31:0] HASH_DATA_IN[63:32]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine's internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DATA_IN_2</name>
          <addressOffset>0x608</addressOffset>
          <size>32</size>
          <description>HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface.</description>
          <fields>
            <field>
              <name>HASH_DATA_IN</name>
              <description>[31:0] HASH_DATA_IN[95:64]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine's internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DATA_IN_3</name>
          <addressOffset>0x60c</addressOffset>
          <size>32</size>
          <description>HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface.</description>
          <fields>
            <field>
              <name>HASH_DATA_IN</name>
              <description>[31:0] HASH_DATA_IN[127:96]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine's internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DATA_IN_4</name>
          <addressOffset>0x610</addressOffset>
          <size>32</size>
          <description>HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface.</description>
          <fields>
            <field>
              <name>HASH_DATA_IN</name>
              <description>[31:0] HASH_DATA_IN[159:128]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine's internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DATA_IN_5</name>
          <addressOffset>0x614</addressOffset>
          <size>32</size>
          <description>HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface.</description>
          <fields>
            <field>
              <name>HASH_DATA_IN</name>
              <description>[31:0] HASH_DATA_IN[191:160]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine's internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DATA_IN_6</name>
          <addressOffset>0x618</addressOffset>
          <size>32</size>
          <description>HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface.</description>
          <fields>
            <field>
              <name>HASH_DATA_IN</name>
              <description>[31:0] HASH_DATA_IN[223:192]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine's internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DATA_IN_7</name>
          <addressOffset>0x61c</addressOffset>
          <size>32</size>
          <description>HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface.</description>
          <fields>
            <field>
              <name>HASH_DATA_IN</name>
              <description>[31:0] HASH_DATA_IN[255:224]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine's internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DATA_IN_8</name>
          <addressOffset>0x620</addressOffset>
          <size>32</size>
          <description>HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface.</description>
          <fields>
            <field>
              <name>HASH_DATA_IN</name>
              <description>[31:0] HASH_DATA_IN[287:256]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine's internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DATA_IN_9</name>
          <addressOffset>0x624</addressOffset>
          <size>32</size>
          <description>HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface.</description>
          <fields>
            <field>
              <name>HASH_DATA_IN</name>
              <description>[31:0] HASH_DATA_IN[319:288]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine's internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DATA_IN_10</name>
          <addressOffset>0x628</addressOffset>
          <size>32</size>
          <description>HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface.</description>
          <fields>
            <field>
              <name>HASH_DATA_IN</name>
              <description>[31:0] HASH_DATA_IN[351:320]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine's internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DATA_IN_11</name>
          <addressOffset>0x62c</addressOffset>
          <size>32</size>
          <description>HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface.</description>
          <fields>
            <field>
              <name>HASH_DATA_IN</name>
              <description>[31:0] HASH_DATA_IN[383:352]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine's internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DATA_IN_12</name>
          <addressOffset>0x630</addressOffset>
          <size>32</size>
          <description>HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface.</description>
          <fields>
            <field>
              <name>HASH_DATA_IN</name>
              <description>[31:0] HASH_DATA_IN[415:384]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine's internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DATA_IN_13</name>
          <addressOffset>0x634</addressOffset>
          <size>32</size>
          <description>HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface.</description>
          <fields>
            <field>
              <name>HASH_DATA_IN</name>
              <description>[31:0] HASH_DATA_IN[447:416]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine's internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DATA_IN_14</name>
          <addressOffset>0x638</addressOffset>
          <size>32</size>
          <description>HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface.</description>
          <fields>
            <field>
              <name>HASH_DATA_IN</name>
              <description>[31:0] HASH_DATA_IN[479:448]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine's internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DATA_IN_15</name>
          <addressOffset>0x63c</addressOffset>
          <size>32</size>
          <description>HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface.</description>
          <fields>
            <field>
              <name>HASH_DATA_IN</name>
              <description>[31:0] HASH_DATA_IN[511:480]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine's internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_IO_BUF_CTRL</name>
          <addressOffset>0x640</addressOffset>
          <size>32</size>
          <description>Input/output buffer control and status register
This register pair shares a single address location and contains bits that control and monitor the data flow between the host and the hash engine.</description>
          <fields>
            <field>
              <name>Reserved1</name>
              <description>[31:8] Write 0s and ignore on reading</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PAD_DMA_MESSAGE</name>
              <description>[7:7] Note: This bit must only be used when data is supplied through the DMA. It should not be used when data is supplied through the slave interface.
This bit indicates whether the hash engine has to pad the message, received through the DMA and finalize the hash.
When set to 1, the hash engine pads the last block using the programmed length. After padding, the final hash result is calculated.
When set to 0, the hash engine treats the last written block as block-size aligned and calculates the intermediate digest.
This bit is automatically cleared when the last DMA data block is arrived in the hash engine.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>GET_DIGEST</name>
              <description>[6:6] Note: The bit description below is only applicable when data is sent through the slave interface. This bit must be set to 0 when data is received through the DMA.
This bit indicates whether the hash engine should provide the hash digest.
When provided simultaneously with data_in_av, the hash digest is provided after processing the data that is currently in the HASH_DATA_IN register. When provided without data_in_av, the current internal digest buffer value is copied to the HASH_DIGEST_n registers.
The host must write a 1 to this bit to make the intermediate hash digest available.
Writing 0 to this bit has no effect.
This bit is automatically cleared (that is, reads 0) when the hash engine has processed the contents of the HASH_DATA_IN register. In the period between this bit is set by the host and the actual HASH_DATA_IN processing, this bit reads 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PAD_MESSAGE</name>
              <description>[5:5] Note: The bit description below is only applicable when data is sent through the slave interface. This bit must be set to 0 when data is received through the DMA.
This bit indicates that the HASH_DATA_IN registers hold the last data of the message and hash padding must be applied.
The host must write this bit to 1 in order to indicate to the hash engine that the HASH_DATA_IN register currently holds the last data of the message. When pad_message is set to 1, the hash engine will add padding bits to the data currently in the HASH_DATA_IN register.
When the last message block is smaller than 512 bits, the pad_message bit must be set to 1 together with the data_in_av bit.
When the last message block is equal to 512 bits, pad_message may be set together with data_in_av. In this case the pad_message bit may also be set after the last data block has been written to the hash engine (so when the rfd_in bit has become 1 again after writing the last data block).
Writing 0 to this bit has no effect.
This bit is automatically cleared (i.e. reads 0) by the hash engine. This bit reads 1 between the time it was set by the host and the hash engine interpreted its value.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>Reserved0</name>
              <description>[4:3] Write 0s and ignore on reading</description>
              <bitWidth>2</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RFD_IN</name>
              <description>[2:2] Note: The bit description below is only applicable when data is sent through the slave interface. This bit can be ignored when data is received through the DMA.
Read-only status of the input buffer of the hash engine.
When 1, the input buffer of the hash engine can accept new data; the HASH_DATA_IN registers can safely be populated with new data.
When 0, the input buffer of the hash engine is processing the data that is currently in HASH_DATA_IN; writing new data to these registers is not allowed.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DATA_IN_AV</name>
              <description>[1:1] Note: The bit description below is only applicable when data is sent through the slave interface. This bit must be set to 0 when data is received through the DMA.
This bit indicates that the HASH_DATA_IN registers contain new input data for processing.
The host must write a 1 to this bit to start processing the data in HASH_DATA_IN; the hash engine will process the new data as soon as it is ready for it (rfd_in bit is 1).
Writing 0 to this bit has no effect.
This bit is automatically cleared (i.e. reads as 0) when the hash engine starts processing the HASH_DATA_IN contents. This bit reads 1 between the time it was set by the host and the hash engine actually starts processing the input data block.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>OUTPUT_FULL</name>
              <description>[0:0] Indicates that the output buffer registers (HASH_DIGEST_n) are available for reading by the host.
When this bit reads 0, the output buffer registers are released; the hash engine is allowed to write new data to it. In this case, the registers should not be read by the host.
When this bit reads 1, the hash engine has stored the result of the latest hash operation in the output buffer registers. As long as this bit reads 1, the host may read output buffer registers and the hash engine is prevented from writing new data to the output buffer.
After retrieving the hash result data from the output buffer, the host must write a 1 to this bit to clear it. This makes the digest output buffer available for the hash engine to store new hash results.
Writing 0 to this bit has no effect.
Note: If this bit is asserted (1) no new operation should be started before the digest is retrieved from the hash engine and this bit is cleared (0).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_MODE_IN</name>
          <addressOffset>0x644</addressOffset>
          <size>32</size>
          <description>Hash mode register</description>
          <fields>
            <field>
              <name>Reserved1</name>
              <description>[31:4] Write 0s and ignore on reading</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SHA256_MODE</name>
              <description>[3:3] The host must write this bit with 1 before processing a hash session.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>Reserved2</name>
              <description>[2:1] Write 0s and ignore on reading</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>NEW_HASH</name>
              <description>[0:0] When set to 1, it indicates that the hash engine must start processing a new hash session. The HASH_DIGEST_n registers will automatically be loaded with the initial hash algorithm constants of the selected hash algorithm.
When this bit is 0 while the hash processing is started, the initial hash algorithm constants are not loaded in the HASH_DIGEST_n registers. The hash engine will start processing with the digest that is currently in its internal HASH_DIGEST_n registers.
This bit is automatically cleared when hash processing is started.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_LENGTH_IN_L</name>
          <addressOffset>0x648</addressOffset>
          <size>32</size>
          <description>Hash length register</description>
          <fields>
            <field>
              <name>LENGTH_IN</name>
              <description>[31:0] LENGTH_IN[31:0]
Message length registers. The content of these registers is used by the hash engine during the message padding phase of the hash session. The data lines of this registers are directly connected to the interface of the hash engine.
For a write operation by the host, these registers should be written with the message length in bits.

Final hash operations:
The total input data length must be programmed for new hash operations that require finalization (padding). The input data must be provided through the slave or DMA interface.

Continued hash operations (finalized):
For continued hash operations that require finalization, the total message length must be programmed, including the length of previously hashed data that corresponds to the written input digest.

Non-final hash operations:
For hash operations that do not require finalization (input data length is multiple of 512-bits which is SHA-256 data block size), the length field does not need to be programmed since not used by the operation.

If the message length in bits is below (2^32-1), then only HASH_LENGTH_IN_L needs to be written. The hardware automatically sets HASH_LENGTH_IN_H to 0s in this case.
The host may write the length register at any time during the hash session when the rfd_in bit of the HASH_IO_BUF_CTRL is high. The length register must be written before the last data of the active hash session is written into the hash engine.
host read operations from these register locations will return 0s.
Note: When getting data from DMA, this register must be programmed before DMA is programmed to start.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_LENGTH_IN_H</name>
          <addressOffset>0x64c</addressOffset>
          <size>32</size>
          <description>Hash length register</description>
          <fields>
            <field>
              <name>LENGTH_IN</name>
              <description>[31:0] LENGTH_IN[63:32]
Message length registers. The content of these registers is used by the hash engine during the message padding phase of the hash session. The data lines of this registers are directly connected to the interface of the hash engine.
For a write operation by the host, these registers should be written with the message length in bits.

Final hash operations:
The total input data length must be programmed for new hash operations that require finalization (padding). The input data must be provided through the slave or DMA interface.

Continued hash operations (finalized):
For continued hash operations that require finalization, the total message length must be programmed, including the length of previously hashed data that corresponds to the written input digest.

Non-final hash operations:
For hash operations that do not require finalization (input data length is multiple of 512-bits which is SHA-256 data block size), the length field does not need to be programmed since not used by the operation.

If the message length in bits is below (2^32-1), then only HASH_LENGTH_IN_L needs to be written. The hardware automatically sets HASH_LENGTH_IN_H to 0s in this case.
The host may write the length register at any time during the hash session when the rfd_in bit of the HASH_IO_BUF_CTRL is high. The length register must be written before the last data of the active hash session is written into the hash engine.
host read operations from these register locations will return 0s.
Note: When getting data from DMA, this register must be programmed before DMA is programmed to start.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DIGEST_A</name>
          <addressOffset>0x650</addressOffset>
          <size>32</size>
          <description>Hash digest registers
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</description>
          <fields>
            <field>
              <name>HASH_DIGEST</name>
              <description>[31:0] HASH_DIGEST[31:0]
Hash digest registers
Write operation:

Continued hash:
These registers should be written with the context data, before the start of a resumed hash session (the new_hash bit in the HASH_MODE register is 0 when starting a hash session).

New hash:
When initiating a new hash session (the new_hash bit in the HASH_MODE register is high), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.

Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DIGEST_B</name>
          <addressOffset>0x654</addressOffset>
          <size>32</size>
          <description>Hash digest registers
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</description>
          <fields>
            <field>
              <name>HASH_DIGEST</name>
              <description>[31:0] HASH_DIGEST[63:32]
Hash digest registers
Write operation:

Continued hash:
These registers should be written with the context data, before the start of a resumed hash session (the new_hash bit in the HASH_MODE register is 0 when starting a hash session).

New hash:
When initiating a new hash session (the new_hash bit in the HASH_MODE register is high), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.

Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DIGEST_C</name>
          <addressOffset>0x658</addressOffset>
          <size>32</size>
          <description>Hash digest registers
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</description>
          <fields>
            <field>
              <name>HASH_DIGEST</name>
              <description>[31:0] HASH_DIGEST[95:64]
Hash digest registers
Write operation:

Continued hash:
These registers should be written with the context data, before the start of a resumed hash session (the new_hash bit in the HASH_MODE register is 0 when starting a hash session).

New hash:
When initiating a new hash session (the new_hash bit in the HASH_MODE register is high), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.

Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DIGEST_D</name>
          <addressOffset>0x65c</addressOffset>
          <size>32</size>
          <description>Hash digest registers
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</description>
          <fields>
            <field>
              <name>HASH_DIGEST</name>
              <description>[31:0] HASH_DIGEST[127:96]
Hash digest registers
Write operation:

Continued hash:
These registers should be written with the context data, before the start of a resumed hash session (the new_hash bit in the HASH_MODE register is 0 when starting a hash session).

New hash:
When initiating a new hash session (the new_hash bit in the HASH_MODE register is high), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.

Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DIGEST_E</name>
          <addressOffset>0x660</addressOffset>
          <size>32</size>
          <description>Hash digest registers
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</description>
          <fields>
            <field>
              <name>HASH_DIGEST</name>
              <description>[31:0] HASH_DIGEST[159:128]
Hash digest registers
Write operation:

Continued hash:
These registers should be written with the context data, before the start of a resumed hash session (the new_hash bit in the HASH_MODE register is 0 when starting a hash session).

New hash:
When initiating a new hash session (the new_hash bit in the HASH_MODE register is high), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.

Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DIGEST_F</name>
          <addressOffset>0x664</addressOffset>
          <size>32</size>
          <description>Hash digest registers
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</description>
          <fields>
            <field>
              <name>HASH_DIGEST</name>
              <description>[31:0] HASH_DIGEST[191:160]
Hash digest registers
Write operation:

Continued hash:
These registers should be written with the context data, before the start of a resumed hash session (the new_hash bit in the HASH_MODE register is 0 when starting a hash session).

New hash:
When initiating a new hash session (the new_hash bit in the HASH_MODE register is high), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.

Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DIGEST_G</name>
          <addressOffset>0x668</addressOffset>
          <size>32</size>
          <description>Hash digest registers
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</description>
          <fields>
            <field>
              <name>HASH_DIGEST</name>
              <description>[31:0] HASH_DIGEST[223:192]
Hash digest registers
Write operation:

Continued hash:
These registers should be written with the context data, before the start of a resumed hash session (the new_hash bit in the HASH_MODE register is 0 when starting a hash session).

New hash:
When initiating a new hash session (the new_hash bit in the HASH_MODE register is high), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.

Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>HASH_DIGEST_H</name>
          <addressOffset>0x66c</addressOffset>
          <size>32</size>
          <description>Hash digest registers
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations.</description>
          <fields>
            <field>
              <name>HASH_DIGEST</name>
              <description>[31:0] HASH_DIGEST[255:224]
Hash digest registers
Write operation:

Continued hash:
These registers should be written with the context data, before the start of a resumed hash session (the new_hash bit in the HASH_MODE register is 0 when starting a hash session).

New hash:
When initiating a new hash session (the new_hash bit in the HASH_MODE register is high), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.

Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTRL_ALG_SEL</name>
          <addressOffset>0x700</addressOffset>
          <size>32</size>
          <description>Algorithm select
This algorithm selection register configures the internal destination of the DMA controller.</description>
          <fields>
            <field>
              <name>TAG</name>
              <description>[31:31] If this bit is cleared to 0, the DMA operation involves only data.
If this bit is set, the DMA operation includes a TAG (Authentication Result / Digest).
For SHA-256 operation, a DMA must be set up for both input data and TAG. For any other selected module, setting this bit only allows a DMA that reads the TAG. No data allowed to be transferred to or from the selected module via the DMA.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>Reserved28</name>
              <description>[30:3] Bits should be written with 0s and ignored on read.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>HASH</name>
              <description>[2:2] If set to one, selects the hash engine as destination for the DMA
The maximum transfer size to DMA engine is set to 64 bytes for reading and 32 bytes for writing (the latter is only applicable if the hash result is written out through the DMA).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>AES</name>
              <description>[1:1] If set to one, selects the AES engine as source/destination for the DMA
The read and write maximum transfer size to the DMA engine is set to 16 bytes.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>KEYSTORE</name>
              <description>[0:0] If set to one, selects the Key Store as destination for the DMA
The maximum transfer size to DMA engine is set to 32 bytes (however transfers of 16, 24 and 32 bytes are allowed)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTRL_PROT_EN</name>
          <addressOffset>0x704</addressOffset>
          <size>32</size>
          <description>Master PROT privileged access enable
This register enables the second bit (bit [1]) of the AHB HPROT bus of the AHB master interface when a read action of key(s) is performed on the AHB master interface for writing keys into the store module.</description>
          <fields>
            <field>
              <name>Reserved31</name>
              <description>[31:1] Bits should be written with 0s and ignored on read.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PROT_EN</name>
              <description>[0:0] If this bit is cleared to 0, m_h_prot[1] on the AHB mater interface always remains 0.
If this bit is set to one, the m_h_prot[1] signal on the master AHB bus is asserted to 1 if an AHB read operation is performed, using DMA, with the key store module as destination.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTRL_SW_RESET</name>
          <addressOffset>0x740</addressOffset>
          <size>32</size>
          <description>Software reset</description>
          <fields>
            <field>
              <name>Reserved31</name>
              <description>[31:1] Bits should be written with 0s and ignored on read.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SW_RESET</name>
              <description>[0:0] If this bit is set to 1, the following modules are reset: 
- Master control internal state is reset. That includes interrupt, error status register, and result available interrupt generation FSM. 
- Key store module state is reset. That includes clearing the written area flags; therefore, the keys must be reloaded to the key store module.
Writing 0 has no effect.
The bit is self cleared after executing the reset.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTRL_INT_CFG</name>
          <addressOffset>0x780</addressOffset>
          <size>32</size>
          <description>Interrupt configuration</description>
          <fields>
            <field>
              <name>Reserved31</name>
              <description>[31:1] Bits should be written with 0s and ignored on read.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>LEVEL</name>
              <description>[0:0] If this bit is 0, the interrupt output is a pulse.
If this bit is set to 1, the interrupt is a level interrupt that must be cleared by writing the interrupt clear register.
This bit is applicable for both interrupt output signals.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTRL_INT_EN</name>
          <addressOffset>0x784</addressOffset>
          <size>32</size>
          <description>Interrupt enable</description>
          <fields>
            <field>
              <name>Reserved30</name>
              <description>[31:2] Bits should be written with 0s and ignored on read.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DMA_IN_DONE</name>
              <description>[1:1] If this bit is set to 0, the DMA input done (irq_dma_in_done) interrupt output is disabled and remains 0.
If this bit is set to 1, the DMA input done interrupt output is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESULT_AV</name>
              <description>[0:0] If this bit is set to 0, the result available (irq_result_av) interrupt output is disabled and remains 0.
If this bit is set to 1, the result available interrupt output is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTRL_INT_CLR</name>
          <addressOffset>0x788</addressOffset>
          <size>32</size>
          <description>Interrupt clear</description>
          <fields>
            <field>
              <name>DMA_BUS_ERR</name>
              <description>[31:31] If 1 is written to this bit, the DMA bus error status is cleared.
Writing 0 has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>KEY_ST_WR_ERR</name>
              <description>[30:30] If 1 is written to this bit, the key store write error status is cleared.
Writing 0 has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>KEY_ST_RD_ERR</name>
              <description>[29:29] If 1 is written to this bit, the key store read error status is cleared.
Writing 0 has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>Reserved27</name>
              <description>[28:2] Bits should be written with 0s and ignored on read.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DMA_IN_DONE</name>
              <description>[1:1] If 1 is written to this bit, the DMA in done (irq_dma_in_done) interrupt output is cleared.
Writing 0 has no effect.
Note that clearing an interrupt makes sense only if the interrupt output is programmed as level (refer to CTRL_INT_CFG).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESULT_AV</name>
              <description>[0:0] If 1 is written to this bit, the result available (irq_result_av) interrupt output is cleared.
Writing 0 has no effect.
Note that clearing an interrupt makes sense only if the interrupt output is programmed as level (refer to CTRL_INT_CFG).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTRL_INT_SET</name>
          <addressOffset>0x78c</addressOffset>
          <size>32</size>
          <description>Interrupt set</description>
          <fields>
            <field>
              <name>Reserved30</name>
              <description>[31:2] Bits should be written with 0s and ignored on read.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DMA_IN_DONE</name>
              <description>[1:1] If 1 is written to this bit, the DMA data in done (irq_dma_in_done) interrupt output is set to one.
Writing 0 has no effect.
If the interrupt configuration register is programmed to pulse, clearing the DMA data in done (irq_dma_in_done) interrupt is not needed. If it is programmed to level, clearing the interrupt output should be done by writing the interrupt clear register (CTRL_INT_CLR).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESULT_AV</name>
              <description>[0:0] If 1 is written to this bit, the result available (irq_result_av) interrupt output is set to one.
Writing 0 has no effect.
If the interrupt configuration register is programmed to pulse, clearing the result available (irq_result_av) interrupt is not needed. If it is programmed to level, clearing the interrupt output should be done by writing the interrupt clear register (CTRL_INT_CLR).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTRL_INT_STAT</name>
          <addressOffset>0x790</addressOffset>
          <size>32</size>
          <description>Interrupt status</description>
          <fields>
            <field>
              <name>DMA_BUS_ERR</name>
              <description>[31:31] This bit is set when a DMA bus error is detected during a DMA operation. The value of this register is held until it is cleared through the CTRL_INT_CLR register.
Note: This error is asserted if an error is detected on the AHB master interface during a DMA operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>KEY_ST_WR_ERR</name>
              <description>[30:30] This bit is set when a write error is detected during the DMA write operation to the key store memory. The value of this register is held until it is cleared through the CTRL_INT_CLR register.
Note: This error is asserted if a DMA operation does not cover a full key area or more areas are written than expected.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>KEY_ST_RD_ERR</name>
              <description>[29:29] This bit is set when a read error is detected during the read of a key from the key store, while copying it to the AES core. The value of this register is held until it is cleared through the CTRL_INT_CLR register.
Note: This error is asserted if a key location is selected in the key store that is not available.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>Reserved27</name>
              <description>[28:2] Bits should be ignored</description>
              <bitWidth>27</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DMA_IN_DONE</name>
              <description>[1:1] This read only bit returns the actual DMA data in done (irq_data_in_done) interrupt status of the DMA data in done interrupt output pin (irq_data_in_done).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESULT_AV</name>
              <description>[0:0] This read only bit returns the actual result available (irq_result_av) interrupt status of the result available interrupt output pin (irq_result_av).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTRL_OPTIONS</name>
          <addressOffset>0x7f8</addressOffset>
          <size>32</size>
          <description>Options register</description>
          <fields>
            <field>
              <name>TYPE</name>
              <description>[31:24] This field is 0x01 for the TYPE1 device.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>Reserved7</name>
              <description>[23:17] Bits should be ignored</description>
              <bitWidth>7</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>AHBINTERFACE</name>
              <description>[16:16] AHB interface is available
If this bit is 0, the EIP-120t has a TCM interface.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[15:9] Bits should be ignored</description>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>SHA_256</name>
              <description>[8:8] The HASH core supports SHA-256.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>AES_CCM</name>
              <description>[7:7] AES-CCM is available as a single operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>AES_GCM</name>
              <description>[6:6] AES-GCM is available as a single operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>AES_256</name>
              <description>[5:5] AES core supports 256-bit keys
Note: If both AES-128 and AES-256 are set to one, the AES core supports 192-bit keys as well.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>AES_128</name>
              <description>[4:4] AES core supports 128-bit keys.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved2</name>
              <description>[3:3] Bit should be ignored</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>HASH</name>
              <description>[2:2] HASH Core is available.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>AES</name>
              <description>[1:1] AES core is available.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>KEYSTORE</name>
              <description>[0:0] KEY STORE is available.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTRL_VERSION</name>
          <addressOffset>0x7fc</addressOffset>
          <size>32</size>
          <description>Version register</description>
          <fields>
            <field>
              <name>Reserved1</name>
              <description>[31:28] Bit should be ignored</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>MAJOR_VERSION</name>
              <description>[27:24] Major version number</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>MINOR_VERSION</name>
              <description>[23:20] Minor version number</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>PATCH_LEVEL</name>
              <description>[19:16] Patch level
Starts at 0 at first delivery of this version</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>EIP_NUMBER_COMPL</name>
              <description>[15:8] These bits simply contain the complement of bits [7:0] (0x87), used by a driver to ascertain that the EIP-120t register is indeed read.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EIP_NUMBER</name>
              <description>[7:0] These bits encode the EIP number for the EIP-120t, this field contains the value 120 (decimal) or 0x78.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SYS_CTRL</name>
      <baseAddress>0x400D2000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00000100</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>CLOCK_CTRL</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>The clock control register handels clock settings in the CC2538. The settings in CLOCK_CTRL do not always reflect the current chip status which is found in CLOCK_STA register.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:26] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>OSC32K_CALDIS</name>
              <description>[25:25] Disable calibration 32-kHz RC oscillator.
0: Enable calibration
1: Disable calibration</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>OSC32K</name>
              <description>[24:24] 32-kHz clock oscillator selection
0: 32-kHz crystal oscillator
1: 32-kHz RC oscillator</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>Reserved24</name>
              <description>[23:22] Reserved. Always read 0.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>AMP_DET</name>
              <description>[21:21] Amplitude detector of XOSC during power up
0: No action
1: Delay qualification of XOSC until amplitude is greater than the threshold.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>Reserved21</name>
              <description>[20:18] Reserved. Always read 0.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>OSC_PD</name>
              <description>[17:17] 0: Power up both oscillators 
1: Power down oscillator not selected by OSC bit (hardware-controlled when selected).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>OSC</name>
              <description>[16:16] System clock oscillator selection
0: 32-MHz crystal oscillator
1: 16-MHz HF-RC oscillator</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved16</name>
              <description>[15:11] Reserved. Always read 0.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>IO_DIV</name>
              <description>[10:8] I/O clock rate setting
Cannot be higher than OSC setting
000: 32 MHz
001: 16 MHz
010: 8 MHz
011: 4 MHz
100: 2 MHz
101: 1 MHz
110: 0.5 MHz
111: 0.25 MHz</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:6] Reserved. Always read 0.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>Reserved5</name>
              <description>[5:5] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[4:3] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>SYS_DIV</name>
              <description>[2:0] System clock rate setting
Cannot be higher than OSC setting
000: 32 MHz
001: 16 MHz
010: 8 MHz
011: 4 MHz
100: 2 MHz
101: 1 MHz
110: 0.5 MHz
111: 0.25 MHz</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CLOCK_STA</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Clock status register
This register reflects the current chip status.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:27] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>SYNC_32K</name>
              <description>[26:26] 32-kHz clock source synced to undivided system clock (16 or 32 MHz).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>OSC32K_CALDIS</name>
              <description>[25:25] Disable calibration 32-kHz RC oscillator.
0: Calibration enabled
1: Calibration disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>OSC32K</name>
              <description>[24:24] Current 32-kHz clock oscillator selected.
0: 32-kHz crystal oscillator
1: 32-kHz RC oscillator</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RST</name>
              <description>[23:22] Returns last source of reset
00: POR
01: External reset
10: WDT
11: CLD or software reset</description>
              <bitWidth>2</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>Reserved22</name>
              <description>[21:21] Reserved. Always read 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>SOURCE_CHANGE</name>
              <description>[20:20] 0: System clock is not requested to change.
1: A change of system clock source has been initiated and is not finished. Same as when OSC bit in CLOCK_STA and CLOCK_CTRL register are not equal</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>XOSC_STB</name>
              <description>[19:19] XOSC stable status
0: XOSC is not powered up or not yet stable.
1: XOSC is powered up and stable.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>HSOSC_STB</name>
              <description>[18:18] HSOSC stable status
0: HSOSC is not powered up or not yet stable.
1: HSOSC is powered up and stable.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>OSC_PD</name>
              <description>[17:17] 0: Both oscillators powered up and stable and OSC_PD_CMD = 0.
1: Oscillator not selected by CLOCK_CTRL.OSC bit is powered down.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>OSC</name>
              <description>[16:16] Current clock source selected
0: 32-MHz crystal oscillator
1: 16-MHz HF-RC oscillator</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved16</name>
              <description>[15:11] Reserved. Always read 0.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>IO_DIV</name>
              <description>[10:8] Returns current functional frequency for IO_CLK
(may differ from setting in the CLOCK_CTRL register)
000: 32 MHz
001: 16 MHz
010: 8 MHz
011: 4 MHz
100: 2 MHz
101: 1 MHz
110: 0.5 MHz
111: 0.25 MHz</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:5] Reserved. Always read 0.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RTCLK_FREQ</name>
              <description>[4:3] Returns current functional frequency for real-time clock. 
(may differ from setting in the CLOCK_CTRL register)
1x : 8 MHz
01: 2 MHz
00: 62.5 kHz</description>
              <bitWidth>2</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>SYS_DIV</name>
              <description>[2:0] Returns current functional frequency for system clock 
(may differ from setting in the CLOCK_CTRL register)
000: 32 MHz
001: 16 MHz
010: 8 MHz
011: 4 MHz
100: 2 MHz
101: 1 MHz
110: 0.5 MHz
111: 0.25 MHz</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RCGCGPT</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>This register defines the module clocks for GPT[3:0] when the CPU is in active (run) mode. This register setting is don't care for PM1-3, because the system clock is powered down in these modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>GPT3</name>
              <description>[3:3] 0: Clock for GPT3 is gated.
1: Clock for GPT3 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>GPT2</name>
              <description>[2:2] 0: Clock for GPT2 is gated.
1: Clock for GPT2 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>GPT1</name>
              <description>[1:1] 0: Clock for GPT1 is gated.
1: Clock for GPT1 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>GPT0</name>
              <description>[0:0] 0: Clock for GPT0 is gated.
1: Clock for GPT0 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SCGCGPT</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>This register defines the module clocks for GPT[3:0] when the CPU is in sleep mode. This register setting is don't care for PM1-3, because the system clock is powered down in these modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>GPT3</name>
              <description>[3:3] 0: Clock for GPT3 is gated.
1: Clock for GPT3 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>GPT2</name>
              <description>[2:2] 0: Clock for GPT2 is gated.
1: Clock for GPT2 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>GPT1</name>
              <description>[1:1] 0: Clock for GPT1 is gated.
1: Clock for GPT1 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>GPT0</name>
              <description>[0:0] 0: Clock for GPT0 is gated.
1: Clock for GPT0 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DCGCGPT</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>This register defines the module clocks for GPT[3:0] when the CPU is in PM0. This register setting is don't care for PM1-3, because the system clock is powered down in these modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>GPT3</name>
              <description>[3:3] 0: Clock for GPT3 is gated.
1: Clock for GPT3 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>GPT2</name>
              <description>[2:2] 0: Clock for GPT2 is gated.
1: Clock for GPT2 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>GPT1</name>
              <description>[1:1] 0: Clock for GPT1 is gated.
1: Clock for GPT1 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>GPT0</name>
              <description>[0:0] 0: Clock for GPT0 is gated.
1: Clock for GPT0 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRGPT</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>This register controls the reset for GPT[3:0].</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>GPT3</name>
              <description>[3:3] 0: GPT3 module is not reset
1: GPT3 module is reset</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>GPT2</name>
              <description>[2:2] 0: GPT2 module is not reset
1: GPT2 module is reset</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>GPT1</name>
              <description>[1:1] 0: GPT1 module is not reset
1: GPT1 module is reset</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>GPT0</name>
              <description>[0:0] 0: GPT0 module is not reset
1: GPT0 module is reset</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RCGCSSI</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>This register defines the module clocks for SSI[1:0] when the CPU is in active (run) mode. This register setting is don't care for PM1-3, because the system clock is powered down in these modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:2] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SSI1</name>
              <description>[1:1] 0: Clock for SSI1 is gated.
1: Clock for SSI1 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SSI0</name>
              <description>[0:0] 0: Clock for SSI0 is gated.
1: Clock for SSI0 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SCGCSSI</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>This register defines the module clocks for SSI[1:0] when the CPU is insSleep mode. This register setting is don't care for PM1-3, because the system clock is powered down in these modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:2] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SSI1</name>
              <description>[1:1] 0: Clock for SSI1 is gated.
1: Clock for SSI1 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SSI0</name>
              <description>[0:0] 0: Clock for SSI0 is gated.
1: Clock for SSI0 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DCGCSSI</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>This register defines the module clocks for SSI[1:0] when the CPU is in PM0. This register setting is don't care for PM1-3, because the system clock is powered down in these modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:2] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SSI1</name>
              <description>[1:1] 0: Clock for SSI1 is gated.
1: Clock for SSI1 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SSI0</name>
              <description>[0:0] 0: Clock for SSI0 is gated.
1: Clock for SSI0 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRSSI</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>This register controls the reset for SSI[1:0].</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:2] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SSI1</name>
              <description>[1:1] 0: SSI1 module is not reset
1: SSI1 module is reset</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SSI0</name>
              <description>[0:0] 0: SSI0 module is not reset
1: SSI0 module is reset</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RCGCUART</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>This register defines the module clocks for UART[1:0] when the CPU is in active (run) mode. This register setting is don't care for PM1-3, because the system clock is powered down in these modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:2] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>UART1</name>
              <description>[1:1] 0: Clock for UART1 is gated.
1: Clock for UART1 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>UART0</name>
              <description>[0:0] 0: Clock for UART0 is gated.
1: Clock for UART0 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SCGCUART</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>This register defines the module clocks for UART[1:0] when the CPU is in sleep mode. This register setting is don't care for PM1-3, because the system clock is powered down in these modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:2] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>UART1</name>
              <description>[1:1] 0: Clock for UART1 is gated.
1: Clock for UART1 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>UART0</name>
              <description>[0:0] 0: Clock for UART0 is gated.
1: Clock for UART0 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DCGCUART</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>This register defines the module clocks for UART[1:0] when the CPU is in PM0. This register setting is don't care for PM1-3, because the system clock is powered down in these modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:2] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>UART1</name>
              <description>[1:1] 0: Clock for UART1 is gated.
1: Clock for UART1 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>UART0</name>
              <description>[0:0] 0: Clock for UART0 is gated.
1: Clock for UART0 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRUART</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>This register controls the reset for UART[1:0].</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:2] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>UART1</name>
              <description>[1:1] 0: UART1 module is not reset
1: UART1 module is reset</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>UART0</name>
              <description>[0:0] 0: UART0 module is not reset
1: UART0 module is reset</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RCGCI2C</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>This register defines the module clocks for I2C when the CPU is in active (run) mode. This register setting is don't care for PM1-3, because the system clock is powered down in these modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:1] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>I2C0</name>
              <description>[0:0] 0: Clock for I2C0 is gated.
1: Clock for I2C0 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SCGCI2C</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>This register defines the module clocks for I2C when the CPU is in sleep mode. This register setting is don't care for PM1-3, because the system clock is powered down in these modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:1] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>I2C0</name>
              <description>[0:0] 0: Clock for I2C0 is gated.
1: Clock for I2C0 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DCGCI2C</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>This register defines the module clocks for I2C when the CPU is in PM0. This register setting is don't care for PM1-3, because the system clock is powered down in these modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:1] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>I2C0</name>
              <description>[0:0] 0: Clock for I2C0 is gated.
1: Clock for I2C0 is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRI2C</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>This register controls the reset for I2C.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:1] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>I2C0</name>
              <description>[0:0] 0: I2C0 module is not reset
1: I2C0 module is reset</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RCGCSEC</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>This register defines the module clocks for the security module when the CPU is in active (run) mode. This register setting is don't care for PM1-3, because the system clock is powered down in these modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:2] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>AES</name>
              <description>[1:1] 0: Clock for AES is gated.
1: Clock for AES is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PKA</name>
              <description>[0:0] 0: Clock for PKA is gated.
1: Clock for PKA is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SCGCSEC</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>This register defines the module clocks for the security module when the CPU is in sleep mode. This register setting is don't care for PM1-3, because the system clock is powered down in these modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:2] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>AES</name>
              <description>[1:1] 0: Clock for AES is gated.
1: Clock for AES is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PKA</name>
              <description>[0:0] 0: Clock for PKA is gated.
1: Clock for PKA is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DCGCSEC</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>This register defines the module clocks for the security module when the CPU is in PM0. This register setting is don't care for PM1-3, because the system clock is powered down in these modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:2] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>AES</name>
              <description>[1:1] 0: Clock for AES is gated.
1: Clock for AES is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PKA</name>
              <description>[0:0] 0: Clock for PKA is gated.
1: Clock for PKA is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRSEC</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>This register controls the reset for the security module.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:2] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>AES</name>
              <description>[1:1] 0: AES module is not reset
1: AES module is reset</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PKA</name>
              <description>[0:0] 0: PKA module is not reset
1: PKA module is reset</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PMCTL</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>This register controls the power mode.
Note: The Corresponding PM is not entered before the WFI instruction is asserted. To enter PM1-3 the DEEPSLEEP bit in SYSCTRL must be 1.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:2] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PM</name>
              <description>[1:0] 00: No action
01: PM1
10: PM2
11: PM3</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SRCRC</name>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <description>This register controls CRC on state retention.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:13] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>19</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>Reserved12</name>
              <description>[12:12] Reserved</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>Reserved10</name>
              <description>[11:10] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>Reserved9</name>
              <description>[9:9] Reserved</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>CRC_REN_USB</name>
              <description>[8:8] 1: Enable reset of chip if CRC fails.
0: Disable reset feature of chip due to CRC.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:5] Reserved</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>Reserved4</name>
              <description>[4:4] Reserved</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved2</name>
              <description>[3:2] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[1:1] Reserved</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CRC_REN_RF</name>
              <description>[0:0] 1: Enable reset of chip if CRC fails.
0: Disable reset feature of chip due to CRC.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PWRDBG</name>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <description>Power debug register</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>FORCE_WARM_RESET</name>
              <description>[3:3] 0: No action
1: When written high, the chip is reset in the same manner as a CLD event and is readable from the RST field in the CLOCK_STA register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>Reserved2</name>
              <description>[2:2] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[1:1] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>Reserved</name>
              <description>[0:0] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CLD</name>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <description>This register controls the clock loss detection feature.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:9] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>VALID</name>
              <description>[8:8] 0: CLD status in always-on domain is not equal to status in the EN register.
1: CLD status in always-on domain and EN register are equal.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:1] Reserved. Always read zero</description>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[0:0] 0: CLD is disabled.
1: CLD is enabled.
Writing to this register shall be ignored if VALID = 0</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IWE</name>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <description>This register controls interrupt wake-up.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:6] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SM_TIMER_IWE</name>
              <description>[5:5] 1: Enable SM Timer wake-up interrupt.
0: Disable SM Timer wake-up interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>USB_IWE</name>
              <description>[4:4] 1: Enable USB wake-up interrupt.
0: Disable USB wake-up interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PORT_D_IWE</name>
              <description>[3:3] 1: Enable port D wake-up interrupt.
0: Disable port D wake-up interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PORT_C_IWE</name>
              <description>[2:2] 1: Enable port C wake-up interrupt.
0: Disable port C wake-up interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PORT_B_IWE</name>
              <description>[1:1] 1: Enable port B wake-up interrupt.
0: Disable port B wake-up interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PORT_A_IWE</name>
              <description>[0:0] 1: Enable port A wake-up interrupt.
0: Disable port A wake-up interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>I_MAP</name>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <description>This register selects which interrupt map to be used.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:1] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ALTMAP</name>
              <description>[0:0] 1: Select alternate interrupt map.
0: Select regular interrupt map.
(See the ASD document for details.)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RCGCRFC</name>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <description>This register defines the module clocks for RF CORE when the CPU is in active (run) mode. This register setting is don't care for PM1-3, because the system clock is powered down in these modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:1] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RFC0</name>
              <description>[0:0] 0: Clock for RF CORE is gated.
1: Clock for RF CORE is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SCGCRFC</name>
          <addressOffset>0xac</addressOffset>
          <size>32</size>
          <description>This register defines the module clocks for RF CORE when the CPU is in sleep mode. This register setting is don't care for PM1-3, because the system clock is powered down in these modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:1] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RFC0</name>
              <description>[0:0] 0: Clock for RF CORE is gated.
1: Clock for RF CORE is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DCGCRFC</name>
          <addressOffset>0xb0</addressOffset>
          <size>32</size>
          <description>This register defines the module clocks for RF CORE when the CPU is in PM0. This register setting is don't care for PM1-3, because the system clock is powered down in these modes.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:1] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RFC0</name>
              <description>[0:0] 0: Clock for RF CORE is gated.
1: Clock for RF CORE is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>EMUOVR</name>
          <addressOffset>0xb4</addressOffset>
          <size>32</size>
          <description>This register defines the emulator override controls for power mode and peripheral clock gate.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Unused. This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ICEPICK_FORCE_CLOCK_CG</name>
              <description>[7:7] ICEPick 'Force Active' clock gate override bit. 'Force Active' is an ICEPick command.

1 --> In non-sleep power mode, peripherals clocks are forced to follow RCG* register settings. It forces CM3 clocks on.

0 --> Does not affect the peripheral clock settings.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>ICEPICK_FORCE_POWER_CG</name>
              <description>[6:6] ICEPick 'Force Power' clock gate override bit. 'Force Power' is an ICEPick command.

1 --> In non-sleep power mode, peripherals clocks are forced to follow RCG* register settings. It forces CM3 clocks on.

0 --> Does not affect the peripheral clock settings.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>ICEPICK_INHIBIT_SLEEP_CG</name>
              <description>[5:5] ICEPick 'Inhibit Sleep' clock gate override bit. 'Inhibit Sleep' is an ICEPick command.

1 --> In non-sleep power mode, peripherals clocks are forced to follow RCG* register settings. It forces CM3 clocks on.

0 --> Does not affect the peripheral clock settings.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>ICEMELTER_WKUP_CG</name>
              <description>[4:4] ICEMelter 'WAKEUPEMU' clock gate override bit.

1 --> In non-sleep power mode, peripherals clocks are forced to follow RCG* register settings. It forces CM3 clocks on.

0 --> Does not affect the peripheral clock settings</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>ICEPICK_FORCE_CLOCK_PM</name>
              <description>[3:3] ICEPick 'Force Active' power mode override bit. 'Force Active' is an ICEPick command.

1 --> Prohibit the system to go into any power down modes. Keeps the emulator attached.
0 --> Does not override any power mode settings from SYSREGS and does not prohibit system to go into any power down modes.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>ICEPICK_FORCE_POWER_PM</name>
              <description>[2:2] ICEPick 'Force Power' power mode override bit. 'Force Power' is an ICEPick command.

1 --> Prohibit the system to go into any power down modes. Keeps the emulator attached.
0 --> Does not override any power mode settings from SYSREGS and does not prohibit system to go into any power down modes.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>ICEPICK_INHIBIT_SLEEP_PM</name>
              <description>[1:1] ICEPick 'Inhibit Sleep' power mode override bit. 'Inhibit Sleep' is an ICEPick command.

1 --> Prohibit the system to go into any power down modes. Keeps the emulator attached.
0 --> Does not override any power mode settings from SYSREGS and does not prohibit system to go into any power down modes.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ICEMELTER_WKUP_PM</name>
              <description>[0:0] ICEMelter 'WAKEUPEMU' power mode override bit.

1 --> Prohibit the system to go into any power down modes. Keeps the emulator attached.
0 --> Does not override any power mode settings from SYSREGS and does not prohibit system to go into any power down modes.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FLASH_CTRL</name>
      <baseAddress>0x400D3000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00000100</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>FCTL</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Flash control
This register provides control and monitoring functions for the flash module.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:10] Unused</description>
              <bitWidth>22</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>UPPER_PAGE_ACCESS</name>
              <description>[9:9] Lock bit for lock bit page
0: Neither write nor erase not allowed
1: Both write and erase allowed</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>SEL_INFO_PAGE</name>
              <description>[8:8] Flash erase or write operation on APB bus must assert this when accessing the information page</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>BUSY</name>
              <description>[7:7] Set when the WRITE or ERASE bit is set; that is, when the flash controller is busy</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>FULL</name>
              <description>[6:6] Write buffer full
The CPU can write to FWDATA when this bit is 0 and WRITE is 1. This bit is cleared when BUSY is cleared.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>ABORT</name>
              <description>[5:5] Abort status
This bit is set to 1 when a write sequence or page erase is aborted. An operation is aborted when the accessed page is locked. Cleared when a write or page erase is started.
If a write operation times out (because the FWDATA register is not written fast enough), the ABORT bit is not set even if the page is locked.
If a page erase and a write operation are started simultaneously, the ABORT bit reflects the status of the last write operation. For example, if the page is locked and the write times out, the ABORT bit is not set because only the write operation times out.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>Reserved5</name>
              <description>[4:4] Reserved</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>CM</name>
              <description>[3:2] Cache Mode
Disabling the cache increases the power consumption and reduces performance. Prefetching improves performance at the expense of a potential increase in power consumption. Real-time mode provides predictable flash read access time, the execution time is equal to cache disabled mode, but the power consumption is lower.
00: Cache disabled
01: Cache enabled
10: Cache enabled, with prefetch
11: Real-time mode
Note: The read value always represents the current cache mode. Writing a new cache mode starts a cache mode change request that does not take effect until the controller is ready. Writes to this register are ignored if there is a current cache change request in progress.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>WRITE</name>
              <description>[1:1] Write bit
Start a write sequence by setting this bit to 1. Cleared by hardware when the operation completes. Writes to this bit are ignored when FCTL.BUSY is 1. If FCTL.ERASE is set simultaneously with this bit, the erase operation is started first, then the write is started.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ERASE</name>
              <description>[0:0] Erase bit
Start an erase operation by setting this bit to 1. Cleared by hardware when the operation completes. Writes to this bit are ignored when FCTL.BUSY is 1. If FCTL.WRITE is set simultaneously with this bit, the erase operation is started first, then the write is started.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FADDR</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Flash address
The register sets the address to be written in flash memory. See the bitfield descriptions for formatting information.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:17] Unused. These bits always reflect 0 on read back</description>
              <bitWidth>15</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>FADDR</name>
              <description>[16:0] Bit number [16:9] selects one of 256 pages for page erase. 
Bit number [8:7] selects one of the 4 row in a given page
Bit number [6:1] selects one of the 64-bit wide locations in a give row.
Bit number [0] will select upper/lower 32-bits in a given 64-bit location
- 64Kbytes --> Bits [16:14] will always be 0.
- 128Kbytes --> Bits [16:15] will always be 0.
- 256Kbytes --> Bit [16] will always be 0.
- 384/512Kbytes --> All bits written and valid.

Writes to this register will be ignored when any of FCTL.WRITE and FCTL.ERASE is set.

FADDR should be written with byte addressable location of the Flash to be programmed.

Read back value always reflects a 32-bit aligned address. When the register is read back, the value that was written to FADDR gets right shift by 2 to indicate 32-bit aligned address. In other words lower 2 bits are discarded while reading back the register.

Out of range address results in roll over. There is no status signal generated by flash controller to indicate this. Firmware is responsible to managing the addresses correctly.</description>
              <bitWidth>17</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FWDATA</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Flash data
This register contains the 32-bits of data to be written to the flash location selected in FADDR.</description>
          <fields>
            <field>
              <name>FWDATA</name>
              <description>[31:0] 32-bit flash write data
Writes to this register are accepted only during a flash write sequence; that is, writes to this register after having written 1 to the FCTL.WRITE bit. New 32-bit data is written only if FCTL.FULL = 0.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIECFG0</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>These settings are a function of the FLASH information page bit settings, which are programmed during production test, and are subject for specific configuration for multiple device flavors of cc2538.</description>
          <fields>
            <field>
              <name>CHIPID</name>
              <description>[31:16] Register copy of configuration bits
Three clock cycles after reset is released, this bit field is equal to the field with the same name in the information page.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved16</name>
              <description>[15:11] Unused</description>
              <bitWidth>5</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CLK_SEL_GATE_EN_N</name>
              <description>[10:10] Register copy of configuration bits
Three clock cycles after reset is released, this bit is equal to the field with the same name in the information page.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>SRAM_SIZE</name>
              <description>[9:7] Register copy of configuration bits
Three clock cycles after reset is released, this bit field is equal to the field with the same name in the information page.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>FLASH_SIZE</name>
              <description>[6:4] Register copy of configuration bits
Three clock cycles after reset is released, this bit field is equal to the field with the same name in the information page.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>USB_ENABLE</name>
              <description>[3:3] Register copy of configuration bits
Three clock cycles after reset is released, this bit is equal to the field with the same name in the information page.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MASS_ERASE_ENABLE</name>
              <description>[2:2] Register copy of configuration bits
Three clock cycles after reset is released, this bit is equal to the field with the same name in the information page.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>LOCK_FWT_N</name>
              <description>[1:1] Register copy of configuration bits
Three clock cycles after reset is released, this bit is equal to the field with the same name in the information page.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>LOCK_IP_N</name>
              <description>[0:0] Register copy of configuration bits
Three clock cycles after reset is released, this bit is equal to the field with the same name in the information page.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIECFG1</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>These settings are a function of the FLASH information page bit settings, which are programmed during production test, and are subject for specific configuration for multiple device flavors of cc2538.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:25] Unused</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>I2C_EN</name>
              <description>[24:24] 1: I2C is enabled.
0: I2C is permanently disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>Reserved24</name>
              <description>[23:18] Unused</description>
              <bitWidth>6</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>UART1_EN</name>
              <description>[17:17] 1: UART1 is enabled.
0: UART1 is permanently disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>UART0_EN</name>
              <description>[16:16] 1: UART0 is enabled.
0: UART0 is permanently disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved16</name>
              <description>[15:10] Unused</description>
              <bitWidth>6</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>SSI1_EN</name>
              <description>[9:9] 1: SSI1 is enabled.
0: SSI1 is permanently disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>SSI0_EN</name>
              <description>[8:8] 1: SSI0 is enabled.
0: SSI0 is permanently disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:4] Unused</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>GPTM3_EN</name>
              <description>[3:3] 1: GPTM3 is enabled.
0: GPTM3 is permanently disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>GPTM2_EN</name>
              <description>[2:2] 1: GPTM2 is enabled.
0: GPTM2 is permanently disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>GPTM1_EN</name>
              <description>[1:1] 1: GPTM1 is enabled.
0: GPTM1 is permanently disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>GPTM0_EN</name>
              <description>[0:0] 1: GPTM0 is enabled.
0: GPTM0 is permanently disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIECFG2</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>These settings are a function of the FLASH information page bit settings, which are programmed during production test, and are subject for specific configuration for multiple device flavors of cc2538. The DIE_*_REVISION registers are an exeception to this, as they are hardwired and are not part of the FLASH information page.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:16] Unused</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DIE_MAJOR_REVISION</name>
              <description>[15:12] Indicates the major revision (all layer change) number for the cc2538
0x0 - PG1.0
0x2 - PG2.0</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>DIE_MINOR_REVISION</name>
              <description>[11:8] Indicates the minor revision (metla layer only) number for the cc2538
0x0 - PG1.0 or PG2.0</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:3] Unused</description>
              <bitWidth>5</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RF_CORE_EN</name>
              <description>[2:2] 1: RF_CORE is enabled.
0: RF_CORE is permanently disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>AES_EN</name>
              <description>[1:1] 1: AES is enabled.
0: AES is permanently disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PKA_EN</name>
              <description>[0:0] 1: PKA is enabled.
0: PKA is permanently disabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>IOC</name>
      <baseAddress>0x400D4000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00000154</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>PA0_SEL</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PA0</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PA0_sel</name>
              <description>[4:0] Select one peripheral signal output for PA0.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PA1_SEL</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PA1</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PA1_sel</name>
              <description>[4:0] Select one peripheral signal output for PA1.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PA2_SEL</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PA2</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PA2_sel</name>
              <description>[4:0] Select one peripheral signal output for PA2.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PA3_SEL</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PA3</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PA3_sel</name>
              <description>[4:0] Select one peripheral signal output for PA3.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PA4_SEL</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PA4</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PA4_sel</name>
              <description>[4:0] Select one peripheral signal output for PA4.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PA5_SEL</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PA5</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PA5_sel</name>
              <description>[4:0] Select one peripheral signal output for PA5.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PA6_SEL</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PA6</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PA6_sel</name>
              <description>[4:0] Select one peripheral signal output for PA6.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PA7_SEL</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PA7</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PA7_sel</name>
              <description>[4:0] Select one peripheral signal output for PA7.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PB0_SEL</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PB0</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PB0_sel</name>
              <description>[4:0] Select one peripheral signal output for PB0.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PB1_SEL</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PB1</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PB1_sel</name>
              <description>[4:0] Select one peripheral signal output for PB1.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PB2_SEL</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PB2</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PB2_sel</name>
              <description>[4:0] Select one peripheral signal output for PB2.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PB3_SEL</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PB3</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PB3_sel</name>
              <description>[4:0] Select one peripheral signal output for PB3.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PB4_SEL</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PB4</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PB4_sel</name>
              <description>[4:0] Select one peripheral signal output for PB4.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PB5_SEL</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PB5</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PB5_sel</name>
              <description>[4:0] Select one peripheral signal output for PB5.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PB6_SEL</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PB6</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PB6_sel</name>
              <description>[4:0] Select one peripheral signal output for PB6.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PB7_SEL</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PB7</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PB7_sel</name>
              <description>[4:0] Select one peripheral signal output for PB7.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PC0_SEL</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PC0</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PC0_sel</name>
              <description>[4:0] Select one peripheral signal output for PC0.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PC1_SEL</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PC1</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PC1_sel</name>
              <description>[4:0] Select one peripheral signal output for PC1.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PC2_SEL</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PC2</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PC2_sel</name>
              <description>[4:0] Select one peripheral signal output for PC2.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PC3_SEL</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PC3</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PC3_sel</name>
              <description>[4:0] Select one peripheral signal output for PC3.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PC4_SEL</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PC4</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PC4_sel</name>
              <description>[4:0] Select one peripheral signal output for PC4.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PC5_SEL</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PC5</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PC5_sel</name>
              <description>[4:0] Select one peripheral signal output for PC5.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PC6_SEL</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PC6</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PC6_sel</name>
              <description>[4:0] Select one peripheral signal output for PC6.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PC7_SEL</name>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PC7</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PC7_sel</name>
              <description>[4:0] Select one peripheral signal output for PC7.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PD0_SEL</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PD0</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PD0_sel</name>
              <description>[4:0] Select one peripheral signal output for PD0.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PD1_SEL</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PD1</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PD1_sel</name>
              <description>[4:0] Select one peripheral signal output for PD1.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PD2_SEL</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PD2</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PD2_sel</name>
              <description>[4:0] Select one peripheral signal output for PD2.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PD3_SEL</name>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PD3</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PD3_sel</name>
              <description>[4:0] Select one peripheral signal output for PD3.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PD4_SEL</name>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PD4</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PD4_sel</name>
              <description>[4:0] Select one peripheral signal output for PD4.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PD5_SEL</name>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PD5</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PD5_sel</name>
              <description>[4:0] Select one peripheral signal output for PD5.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PD6_SEL</name>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PD6</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PD6_sel</name>
              <description>[4:0] Select one peripheral signal output for PD6.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PD7_SEL</name>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <description>Peripheral select control for PD7</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PD7_sel</name>
              <description>[4:0] Select one peripheral signal output for PD7.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PA0_OVER</name>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PA0_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PA1_OVER</name>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PA1_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PA2_OVER</name>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PA2_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PA3_OVER</name>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PA3_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PA4_OVER</name>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PA4_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PA5_OVER</name>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PA5_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PA6_OVER</name>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PA6_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PA7_OVER</name>
          <addressOffset>0x9c</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PA7_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PB0_OVER</name>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PB0_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PB1_OVER</name>
          <addressOffset>0xa4</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PB1_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PB2_OVER</name>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PB2_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PB3_OVER</name>
          <addressOffset>0xac</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PB3_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PB4_OVER</name>
          <addressOffset>0xb0</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PB4_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PB5_OVER</name>
          <addressOffset>0xb4</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PB5_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PB6_OVER</name>
          <addressOffset>0xb8</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PB6_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PB7_OVER</name>
          <addressOffset>0xbc</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PB7_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PC0_OVER</name>
          <addressOffset>0xc0</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad. PC0 has high drive capability.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PC0_over</name>
              <description>[3:3] 0: output disable
1: oe - output enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[2:0] Reserved</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PC1_OVER</name>
          <addressOffset>0xc4</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad. PC1 has high drive capability.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PC1_over</name>
              <description>[3:3] 0: output disable
1: oe - output enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[2:0] Reserved</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PC2_OVER</name>
          <addressOffset>0xc8</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad. PC2 has high drive capability.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PC2_over</name>
              <description>[3:3] 0: output disable
1: oe - output enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[2:0] Reserved</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PC3_OVER</name>
          <addressOffset>0xcc</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad. PC3 has high drive capability.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PC3_over</name>
              <description>[3:3] 0: output disable
1: oe - output enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[2:0] Reserved</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PC4_OVER</name>
          <addressOffset>0xd0</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PC4_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PC5_OVER</name>
          <addressOffset>0xd4</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PC5_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PC6_OVER</name>
          <addressOffset>0xd8</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PC6_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PC7_OVER</name>
          <addressOffset>0xdc</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PC7_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PD0_OVER</name>
          <addressOffset>0xe0</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PD0_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PD1_OVER</name>
          <addressOffset>0xe4</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PD1_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PD2_OVER</name>
          <addressOffset>0xe8</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PD2_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PD3_OVER</name>
          <addressOffset>0xec</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PD3_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PD4_OVER</name>
          <addressOffset>0xf0</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PD4_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PD5_OVER</name>
          <addressOffset>0xf4</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PD5_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PD6_OVER</name>
          <addressOffset>0xf8</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PD6_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PD7_OVER</name>
          <addressOffset>0xfc</addressOffset>
          <size>32</size>
          <description>This is the overide configuration register for each pad.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:4] Reserved</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PD7_over</name>
              <description>[3:0] 0x8: oe - output enable
0x4: pue - pullup enable
0x2: pde - pulldown enable
0x1: ana - analog enable</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>UARTRXD_UART0</name>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the UART0 RX.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as UART0 RX
1: PA1 selected as UART0 RX
...
31: PD7 selected as UART0 RX</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>UARTCTS_UART1</name>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the UART1 CTS.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as UART1 CTS
1: PA1 selected as UART1 CTS
...
31: PD7 selected as UART1 CTS</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>UARTRXD_UART1</name>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the UART1 RX.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as UART1 RX
1: PA1 selected as UART1 RX
...
31: PD7 selected as UART1 RX</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CLK_SSI_SSI0</name>
          <addressOffset>0x10c</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the SSI0 CLK.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as SSI0 CLK
1: PA1 selected as SSI0 CLK
...
31: PD7 selected as SSI0 CLK</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SSIRXD_SSI0</name>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the SSI0 RX.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as SSI0 RX
1: PA1 selected as SSI0 RX
...
31: PD7 selected as SSI0 RX</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SSIFSSIN_SSI0</name>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the SSI0 FSSIN.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as SSI0 FSSIN
1: PA1 selected as SSI0 FSSIN
...
31: PD7 selected as SSI0 FSSIN</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CLK_SSIIN_SSI0</name>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the SSI0 CLK_SSIN.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as SSI0 CLK_SSIN
1: PA1 selected as SSI0 CLK_SSIN
...
31: PD7 selected as SSI0 CLK_SSIN</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CLK_SSI_SSI1</name>
          <addressOffset>0x11c</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the SSI1 CLK.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as SSI1 CLK
1: PA1 selected as SSI1 CLK
...
31: PD7 selected as SSI1 CLK</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SSIRXD_SSI1</name>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the SSI1 RX.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as SSI1 RX
1: PA1 selected as SSI1 RX
...
31: PD7 selected as SSI1 RX</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SSIFSSIN_SSI1</name>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the SSI1 FSSIN.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as SSI1 FSSIN
1: PA1 selected as SSI1 FSSIN
...
31: PD7 selected as SSI1 FSSIN</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CLK_SSIIN_SSI1</name>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the SSI1 CLK_SSIN.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as SSI1 CLK_SSIN
1: PA1 selected as SSI1 CLK_SSIN
...
31: PD7 selected as SSI1 CLK_SSIN</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>I2CMSSDA</name>
          <addressOffset>0x12c</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the I2C SDA.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as I2C SDA
1: PA1 selected as I2C SDA
...
31: PD7 selected as I2C SDA</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>I2CMSSCL</name>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the I2C SCL.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as I2C SCL
1: PA1 selected as I2C SCL
...
31: PD7 selected as I2C SCL</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPT0OCP1</name>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the GPT0OCP1.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as GPT0OCP1
1: PA1 selected as GPT0OCP1
...
31: PD7 selected as GPT0OCP1</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPT0OCP2</name>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the GPT0OCP2.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as GPT0OCP2
1: PA1 selected as GPT0OCP2
...
31: PD7 selected as GPT0OCP2</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPT1OCP1</name>
          <addressOffset>0x13c</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the GPT1OCP1.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as GPT1OCP1
1: PA1 selected as GPT1OCP1
...
31: PD7 selected as GPT1OCP1</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPT1OCP2</name>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the GPT1OCP2.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as GPT1OCP2
1: PA1 selected as GPT1OCP2
...
31: PD7 selected as GPT1OCP2</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPT2OCP1</name>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the GPT2OCP1.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as GPT2OCP1
1: PA1 selected as GPT2OCP1
...
31: PD7 selected as GPT2OCP1</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPT2OCP2</name>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the GPT2OCP2.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as GPT2OCP2
1: PA1 selected as GPT2OCP2
...
31: PD7 selected as GPT2OCP2</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPT3OCP1</name>
          <addressOffset>0x14c</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the GPT3OCP1.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as GPT3OCP1
1: PA1 selected as GPT3OCP1
...
31: PD7 selected as GPT3OCP1</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPT3OCP2</name>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <description>Selects one of the 32 pins on the four 8-pin I/O-ports (port A, port B, port C, and port D) to be the GPT3OCP2.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:5] Reserved</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>INPUT_SEL</name>
              <description>[4:0] 0: PA0 selected as GPT3OCP2
1: PA1 selected as GPT3OCP2
...
31: PD7 selected as GPT3OCP2</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SMWDTHROSC</name>
      <baseAddress>0x400D5000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00000100</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>WDCTL</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Watchdog Timer Control</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CLR</name>
              <description>[7:4] Clear timer
When 0xA followed by 0x5 is written to these bits, the timer is loaded with 0x0000. Note that 0x5 must be written within one watchdog clock period Twdt after 0xA was written for the clearing to take effect (ensured). 
If 0x5 is written between Twdt and 2Twdt after 0xA was written, the clearing may take effect, but there is no guarantee. If 0x5 is written > 2Twdt after 0xA was written, the timer will not be cleared. 
If a value other than 0x5 is written after 0xA has been written, the clear sequence is aborted. If 0xA is written, this starts a new clear sequence. 
Writing to these bits when EN = 0 has no effect.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[3:3] Enable timer
When 1 is written to this bit the timer is enabled and starts incrementing. The interval setting specified by INT[1:0] is used. 
Writing 0 to this bit have no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>Reserved2</name>
              <description>[2:2] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>INT</name>
              <description>[1:0] Timer interval select
These bits select the timer interval as follows: 
00: Twdt x 32768 
01: Twdt x 8192 
10: Twdt x 512 
11: Twdt x 64 
Writing these bits when EN = 1 has no effect.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ST0</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>Sleep Timer 0 count and compare</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ST0</name>
              <description>[7:0] Sleep Timer count and compare value. When read, this register returns the low bits [7:0] of the Sleep Timer count. When writing this register sets the low bits [7:0] of the compare value.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ST1</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>Sleep Timer 1 count and compare</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ST1</name>
              <description>[7:0] Sleep Timer count and compare value
When read, this register returns the middle bits [15:8] of the Sleep Timer count. When writing this register sets the middle bits [15:8] of the compare value. The value read is latched at the time of reading register ST0. The value written is latched when ST0 is written.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ST2</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>Sleep Timer 2 count and compare</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ST2</name>
              <description>[7:0] Sleep Timer count and compare value
When read, this register returns the high bits [23:16] of the Sleep Timer count. When writing this register sets the high bits [23:16] of the compare value. The value read is latched at the time of reading register ST0. The value written is latched when ST0 is written.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ST3</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>Sleep Timer 3 count and compare</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ST3</name>
              <description>[7:0] Sleep Timer count and compare value
When read, this register returns the high bits [31:24] of the Sleep Timer count. When writing this register sets the high bits [31:24] of the compare value. The value read is latched at the time of reading register ST0. The value written is latched when ST0 is written.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>STLOAD</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>Sleep Timer load status</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved7</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STLOAD</name>
              <description>[0:0] Status signal for when STx registers have been uploaded to 32-kHz counter.
1: Load is complete
0: Load is busy and STx regs are blocked for writing</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>STCC</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>Sleep Timer Capture control</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT</name>
              <description>[5:3] Port select
Valid settings are 0-3, all others inhibit any capture from occurring
000: Port A selected
001: Port B selected
010: Port C selected
011: Port D selected</description>
              <bitWidth>3</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PIN</name>
              <description>[2:0] Pin select
Valid settings are 1-7 when either port A, B, C, or D is selected.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>STCS</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>Sleep Timer Capture status</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved7</name>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>VALID</name>
              <description>[0:0] Capture valid flag
Set to 1 when capture value in STCV has been updated
Clear explicitly to allow new capture</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>STCV0</name>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <description>Sleep Timer Capture value byte 0</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>STCV0</name>
              <description>[7:0] Bits [7:0] of Sleep Timer capture value</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>STCV1</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>Sleep Timer Capture value byte 1</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>STCV1</name>
              <description>[7:0] Bits [15:8] of Sleep Timer capture value</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>STCV2</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>Sleep Timer Capture value byte 2</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>STCV2</name>
              <description>[7:0] Bits [23:16] of Sleep Timer capture value</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>STCV3</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>Sleep Timer Capture value byte 3</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>STCV3</name>
              <description>[7:0] Bits [32:24] of Sleep Timer capture value</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ANA_REGS</name>
      <baseAddress>0x400D6000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00000100</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>IVCTRL</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Analog control register</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[7:7] Reserved. Always read 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>Reserved7</name>
              <description>[6:6] Reserved. Always read 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DAC_CURR_CTRL</name>
              <description>[5:4] Controls bias current to DAC
00: 100% IVREF, 0% IREF bias
01: 60% IVREF, 40% IREF bias
10: 40% IVREF, 60% IREF bias
11: 0% IVREF, 100% IREF bias</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>LODIV_BIAS_CTRL</name>
              <description>[3:3] Controls bias current to LODIV
1: PTAT bias
0: IVREF bias</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>TXMIX_DC_CTRL</name>
              <description>[2:2] Controls DC bias in TXMIX</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PA_BIAS_CTRL</name>
              <description>[1:0] Controls bias current to PA
00: IREF bias
01: IREF and IVREF bias (CC2530 mode)
10: PTAT bias
11: Increased PTAT slope bias</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SOC_ADC</name>
      <baseAddress>0x400D7000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00000100</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>ADCCON1</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>This register controls the ADC.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EOC</name>
              <description>[7:7] End of conversion. Cleared when ADCH has been read. If a new conversion is completed before the previous data has been read, the EOC bit remains high.
0: Conversion not complete
1: Conversion completed</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>ST</name>
              <description>[6:6] Start conversion
Read as 1 until conversion completes
0: No conversion in progress.
1: Start a conversion sequence if ADCCON1.STSEL = 11 and no sequence is running.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>STSEL</name>
              <description>[5:4] Start select
Selects the event that starts a new conversion sequence
00: Not implemented
01: Full speed. Do not wait for triggers
10: Timer 1 channel 0 compare event
11: ADCCON1.ST = 1</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RCTRL</name>
              <description>[3:2] Controls the 16-bit random-number generator (see User Guide Chapter 16)
When 01 is written, the setting automatically returns to 00 when the operation completes.

00: Normal operation (13x unrolling)
01: Clock the LFSR once (13x unrolling)
10: Reserved
11: Stopped. The random-number generator is turned off.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[1:0] Reserved. Always set to 11.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ADCCON2</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>This register controls the ADC.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SREF</name>
              <description>[7:6] Selects reference voltage used for the sequence of conversions
00: Internal reference
01: External reference on AIN7 pin
10: AVDD5 pin
11: External reference on AIN6-AIN7 differential input</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SDIV</name>
              <description>[5:4] Sets the decimation rate for channels included in the sequence of conversions. The decimation
rate also determines the resolution and time required to complete a conversion.
00: 64 decimation rate (7 bits ENOB setting)
01: 128 decimation rate (9 bits ENOB setting)
10: 256 decimation rate (10 bits ENOB setting)
11: 512 decimation rate (12 bits ENOB setting)</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SCH</name>
              <description>[3:0] Sequence channel select
Selects the end of the sequence
A sequence can either be from AIN0 to AIN7 (SCH &lt;= 7) or from differential input AIN0-AIN1 to AIN6-AIN7 (8 &lt;= SCH &lt;= 11). For other
settings, only one conversions is performed.
When read, these bits indicate the channel number on which a conversion is ongoing:
0000: AIN0
0001: AIN1
0010: AIN2
0011: AIN3
0100: AIN4
0101: AIN5
0110: AIN6
0111: AIN7
1000: AIN0-AIN1
1001: AIN2-AIN3
1010: AIN4-AIN5
1011: AIN6-AIN7
1100: GND
1101: Reserved
1110: Temperature sensor
1111: VDD/3</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ADCCON3</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>This register controls the ADC.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EREF</name>
              <description>[7:6] Selects reference voltage used for the extra conversion
00: Internal reference
01: External reference on AIN7 pin
10: AVDD5 pin
11: External reference on AIN6-AIN7 differential input</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>EDIV</name>
              <description>[5:4] Sets the decimation rate used for the extra conversion
The decimation rate also determines the resolution and the time required to complete the conversion.
00: 64 decimation rate (7 bits ENOB)
01: 128 decimation rate (9 bits ENOB)
10: 256 decimation rate (10 bits ENOB)
11: 512 decimation rate (12 bits ENOB)</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>ECH</name>
              <description>[3:0] Single channel select. Selects the channel number of the single conversion that is triggered by
writing to ADCCON3.
0000: AIN0
0001: AIN1
0010: AIN2
0011: AIN3
0100: AIN4
0101: AIN5
0110: AIN6
0111: AIN7
1000: AIN0-AIN1
1001: AIN2-AIN3
1010: AIN4-AIN5
1011: AIN6-AIN7
1100: GND
1101: Reserved
1110: Temperature sensor
1111: VDD/3</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ADCL</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>This register contains the least-significant part of ADC conversion result.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ADC</name>
              <description>[7:2] Least-significant part of ADC conversion result</description>
              <bitWidth>6</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[1:0] Reserved. Always read as 0.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ADCH</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>This register contains the most-significant part of ADC conversion result.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ADC</name>
              <description>[7:0] Most-significant part of ADC conversion result</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RNDL</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>This registers contains random-number-generator data; low byte.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RNDL</name>
              <description>[7:0] Random value/seed or CRC result, low byte
When used for random-number generation, writing to this register twice seeds the random-number generator. Writing to this register copies the 8 LSBs of the LFSR to the 8 MSBs and replaces the 8 LSBs with the data value written. The value returned when reading from this register is the 8 LSBs of the LFSR. When used for random-number generation, reading this register returns the 8 LSBs of the random number. When used for CRC calculations, reading this register returns the 8 LSBs of the CRC result.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RNDH</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>This register contains random-number-generator data; high byte.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RNDH</name>
              <description>[7:0] Random value or CRC result/input data, high byte
When written, a CRC16 calculation is triggered, and the data value written is processed starting with the MSB.
The value returned when reading from this register is the 8 MSBs of the LFSR.
When used for random-number generation, reading this register returns the 8 MSBs of the random number. When used for CRC calculations, reading this register returns the 8 MSBs of the
CRC result.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CMPCTL</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Analog comparator control and status register.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] This register is 8 bits in a 32-bit address space.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved</name>
              <description>[7:2] Reserved</description>
              <bitWidth>6</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[1:1] Comparator enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>OUTPUT</name>
              <description>[0:0] Comparator output</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO_A</name>
      <baseAddress>0x400D9000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00001000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>DATA</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>This is the data register. In software control mode, values written in
the GPIODATA register are transferred onto the GPOUT pins if the respective pins have been configured as outputs through the GPIODIR register. A read from GPIODATA returns the last bit value written if the respective pins are configured as output, or it returns the value on the corresponding input GPIN bit when these are configured as inputs.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DATA</name>
              <description>[7:0] Input and output data</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIR</name>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <description>The DIR register is the data direction register. All bits are cleared by a reset; therefore, the GPIO pins are input by default.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DIR</name>
              <description>[7:0] Bits set: Corresponding pin is output
Bits cleared: Corresponding pin is input</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IS</name>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <description>The IS register is the interrupt sense register.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IS</name>
              <description>[7:0] Bits set: Level on corresponding pin is detected
Bits cleared: Edge on corresponding pin is detected</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IBE</name>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <description>The IBE register is the interrupt both-edges register. When the corresponding bit in IS is set to detect edges, bits set to high in IBE configure the corresponding pin to detect both rising and falling edges, regardless of the corresponding bit in the IEV (interrupt event register). Clearing a bit configures the pin to be controlled by IEV.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IBE</name>
              <description>[7:0] Bits set: Both edges on corresponding pin trigger an interrupt
Bits cleared: Interrupt generation event is controlled by GPIOIEV
Single edge: Determined by corresponding bit in GPIOIEV register</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IEV</name>
          <addressOffset>0x40c</addressOffset>
          <size>32</size>
          <description>The IEV register is the interrupt event register. Bits set to high in IEV
configure the corresponding pin to detect rising edges or high levels, depending on the corresponding bit value in IS. Clearing a bit configures the pin to detect falling edges or low levels, depending on the corresponding bit value in IS.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IEV</name>
              <description>[7:0] Bits set: Rising edges or high levels on corresponding pin trigger interrupts
Bits cleared: Falling edges or low levels on corresponding pin trigger interrupts</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IE</name>
          <addressOffset>0x410</addressOffset>
          <size>32</size>
          <description>The IE register is the interrupt mask register. Bits set to high in IE allow the corresponding pins to trigger their individual interrupts and the combined GPIOINTR line. Clearing a bit disables interrupt triggering on that pin.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[7:0] Bits set: Corresponding pin is not masked
Bits cleared: Corresponding pin is masked</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x414</addressOffset>
          <size>32</size>
          <description>The RIS register is the raw interrupt status register. Bits read high in RIS reflect the status of interrupts trigger conditions detected (raw, before masking), indicating that all the requirements are met, before they are finally allowed to trigger by IE. Bits read as 0 indicate that corresponding input pins have not initiated an interrupt.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RIS</name>
              <description>[7:0] Reflects the status of interrupts trigger conditions detected on pins (raw, before masking)
Bits set: Requirements met by corresponding pins
Bits clear: Requirements not met</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x418</addressOffset>
          <size>32</size>
          <description>The MIS register is the masked interrupt status register. Bits read high in MIS reflect the status of input lines triggering an interrupt. Bits read as low indicate that either no interrupt has been generated, or the interrupt is masked. MIS is the state of the interrupt after masking.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MIS</name>
              <description>[7:0] Masked value of interrupt due to corresponding pin
Bits clear: GPIO line interrupt not active
Bits set: GPIO line asserting interrupt</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IC</name>
          <addressOffset>0x41c</addressOffset>
          <size>32</size>
          <description>The IC register is the interrupt clear register. Writing 1 to a bit in this register clears the corresponding interrupt edge detection logic register. Writing 0 has no effect.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IC</name>
              <description>[7:0] Bit written as 1: Clears edge detection logic
Bit written as 0: Has no effect</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AFSEL</name>
          <addressOffset>0x420</addressOffset>
          <size>32</size>
          <description>The AFSEL register is the mode control select register. Writing 1 to any bit in this register selects the hardware (peripheral) control for the corresponding GPIO line. All bits are cleared by a reset, therefore no GPIO line is set to hardware control by default.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>AFSEL</name>
              <description>[7:0] Bit set: Enables hardware (peripheral) control mode
Bit cleared: Enables software control mode</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIOLOCK</name>
          <addressOffset>0x520</addressOffset>
          <size>32</size>
          <description>A write of the value 0x4C4F434B to the GPIOLOCK register unlocks the GPIO commit register (GPIOCR) for write access. A write of any other value reapplies the lock, preventing any register updates. Any write to the commit register (GPIOCR) causes the lock register to be locked.</description>
          <fields>
            <field>
              <name>LOCK</name>
              <description>[31:0] A read of this register returns the following values:
Locked: 0x00000001
Unlocked: 0x00000000</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIOCR</name>
          <addressOffset>0x524</addressOffset>
          <size>32</size>
          <description>The GPIOCR register is the commit register. The value of the GPIOCR register determines which bits of the AFSEL register is committed when a write to the AFSEL register is performed. If a bit in the GPIOCR register is 0, the data being written to the corresponding bit in the AFSEL register is not committed and retains its previous value. If a bit in the GPIOCR register is set to 1, the data being written to the corresponding bit of the AFSEL register is committed to the register and will reflect the new value. The contents of the GPIOCR register can only be modified if the GPIOLOCK register is unlocked. Writes to the GPIOCR register will be ignored if the GPIOLOCK register is locked. Any write to the commit register causes the lock register to be locked.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved bits return an indeterminate value, and should never be changed.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CR</name>
              <description>[7:0] On a bit-wise basis, any bit set allows the corresponding GPIOAFSEL bit to be set to its alternate function.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PMUX</name>
          <addressOffset>0x700</addressOffset>
          <size>32</size>
          <description>The PMUX register can be used to output external decouple control and clock_32k on I/O pins.  Decouple control can be output on specific PB pins and clock_32k can be output on a specific PA or PB pin. These features override the current setting of the selected pin when enabled. The pin is set to output, pull-up and -down disabled, and analog mode disabled.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CKOEN</name>
              <description>[7:7] Clock out enable
When this bit is set, the 32-kHz clock is routed to either PA[0] or PB[7] pins. PMUX.CKOPIN selects the pin to use. This overrides the current configuration setting for this pin. The pullup or pulldown is disabled and the direction is set to output for this pin.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>Reserved7</name>
              <description>[6:5] These are spare registers that are unused in the design.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>CKOPIN</name>
              <description>[4:4] Decouple control pin select
This control only has relevance when CKOEN is set. 
When 0, PA[0] becomes the 32-kHz clock output. When 1, PB[7] becomes the 32-kHz clock output.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DCEN</name>
              <description>[3:3] Decouple control enable
When this bit is set, the on-die digital regulator status is routed  to either PB[1] or PB[0] pins. PMUX.DCPIN selects the pin to use. This overrides the current configuration setting for this pin. The pullup or pulldown is disabled and the direction is set to output for this pin.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[2:1] These are spare registers that are unused in the design.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DCPIN</name>
              <description>[0:0] Decouple control pin select
This control has relevance only when DCEN is set. 
When 0, PB[1] becomes the on-die digital regulator status (1 indicates the on-die digital regulator is active); when 1, PB[0] becomes the on-die digital regulator status.

NOTE: PB[1] and PB[0] can also be controlled with other override features.

In priority order for PB[1]:
When POR/BOD test mode is active, PB[1] becomes the active low brown-out detected indicator.
When DCEN is set and DCPIN is not set, PB[1] becomes the on-dir digital regulator status.

In priority order for PB[0]:
When POR/BOD test mode is active, PB[0] becomes the power-on-reset indicator.
When DCEN and DCPIN are set, PB[0] becomes the on-die digital regulator status.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>P_EDGE_CTRL</name>
          <addressOffset>0x704</addressOffset>
          <size>32</size>
          <description>The port edge control register is used to control which edge of each port input causes that port to generate a power-up interrupt to the system.</description>
          <fields>
            <field>
              <name>PDIRC7</name>
              <description>[31:31] Port D bit 7 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>PDIRC6</name>
              <description>[30:30] Port D bit 6 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>PDIRC5</name>
              <description>[29:29] Port D bit 5 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>PDIRC4</name>
              <description>[28:28] Port D bit 4 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>PDIRC3</name>
              <description>[27:27] Port D bit 3 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>PDIRC2</name>
              <description>[26:26] Port D bit 2 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>PDIRC1</name>
              <description>[25:25] Port D bit 1 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>PDIRC0</name>
              <description>[24:24] Port D bit 0 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PCIRC7</name>
              <description>[23:23] Port C bit 7 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>PCIRC6</name>
              <description>[22:22] Port C bit 6 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>PCIRC5</name>
              <description>[21:21] Port C bit 5 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>PCIRC4</name>
              <description>[20:20] Port C bit 4 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>PCIRC3</name>
              <description>[19:19] Port C bit 3 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>PCIRC2</name>
              <description>[18:18] Port C bit 2 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>PCIRC1</name>
              <description>[17:17] Port C bit 1 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>PCIRC0</name>
              <description>[16:16] Port C bit 0 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PBIRC7</name>
              <description>[15:15] Port B bit 7 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PBIRC6</name>
              <description>[14:14] Port B bit 6 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>PBIRC5</name>
              <description>[13:13] Port B bit 5 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PBIRC4</name>
              <description>[12:12] Port B bit 4 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>PBIRC3</name>
              <description>[11:11] Port B bit 3 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>PBIRC2</name>
              <description>[10:10] Port B bit 2 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PBIRC1</name>
              <description>[9:9] Port B bit 1 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PBIRC0</name>
              <description>[8:8] Port B bit 0 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PAIRC7</name>
              <description>[7:7] Port A bit 7 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>PAIRC6</name>
              <description>[6:6] Port A bit 6 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PAIRC5</name>
              <description>[5:5] Port A bit 5 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PAIRC4</name>
              <description>[4:4] Port A bit 4 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PAIRC3</name>
              <description>[3:3] Port A bit 3 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PAIRC2</name>
              <description>[2:2] Port A bit 2 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PAIRC1</name>
              <description>[1:1] Port A bit 1 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PAIRC0</name>
              <description>[0:0] Port A bit 0 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>USB_CTRL</name>
          <addressOffset>0x708</addressOffset>
          <size>32</size>
          <description>This register is used to control which edge of the USB controller input generates a power-up interrupt to the system.</description>
          <fields>
            <field>
              <name>Reserved31</name>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>USB_EDGE_CTL</name>
              <description>[0:0] Used to set the edge which triggers the USB power up interrupt
0: Rising
1: Falling</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PI_IEN</name>
          <addressOffset>0x710</addressOffset>
          <size>32</size>
          <description>The power-up interrupt enable register selects, for its corresponding port A-D pin, whether interrupts are enabled or disabled.</description>
          <fields>
            <field>
              <name>PDIEN7</name>
              <description>[31:31] Port D bit 7 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>PDIEN6</name>
              <description>[30:30] Port D bit 6 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>PDIEN5</name>
              <description>[29:29] Port D bit 5 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>PDIEN4</name>
              <description>[28:28] Port D bit 4 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>PDIEN3</name>
              <description>[27:27] Port D bit 3 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>PDIEN2</name>
              <description>[26:26] Port D bit 2 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>PDIEN1</name>
              <description>[25:25] Port D bit 1 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>PDIEN0</name>
              <description>[24:24] Port D bit 0 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PCIEN7</name>
              <description>[23:23] Port C bit 7 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>PCIEN6</name>
              <description>[22:22] Port C bit 6 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>PCIEN5</name>
              <description>[21:21] Port C bit 5 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>PCIEN4</name>
              <description>[20:20] Port C bit 4 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>PCIEN3</name>
              <description>[19:19] Port C bit 3 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>PCIEN2</name>
              <description>[18:18] Port C bit 2 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>PCIEN1</name>
              <description>[17:17] Port C bit 1 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>PCIEN0</name>
              <description>[16:16] Port C bit 0 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PBIEN7</name>
              <description>[15:15] Port B bit 7 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PBIEN6</name>
              <description>[14:14] Port B bit 6 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>PBIEN5</name>
              <description>[13:13] Port B bit 5 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PBIEN4</name>
              <description>[12:12] Port B bit 4 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>PBIEN3</name>
              <description>[11:11] Port B bit 3 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>PBIEN2</name>
              <description>[10:10] Port B bit 2 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PBIEN1</name>
              <description>[9:9] Port B bit 1 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PBIEN0</name>
              <description>[8:8] Port B bit 0 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PAIEN7</name>
              <description>[7:7] Port A bit 7 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>PAIEN6</name>
              <description>[6:6] Port A bit 6 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PAIEN5</name>
              <description>[5:5] Port A bit 5 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PAIEN4</name>
              <description>[4:4] Port A bit 4 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PAIEN3</name>
              <description>[3:3] Port A bit 3 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PAIEN2</name>
              <description>[2:2] Port A bit 2 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PAIEN1</name>
              <description>[1:1] Port A bit 1 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PAIEN0</name>
              <description>[0:0] Port A bit 0 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IRQ_DETECT_ACK</name>
          <addressOffset>0x718</addressOffset>
          <size>32</size>
          <description>If the IRQ detect ACK register is read, the value returned can be used to determine which enabled I/O port is responsible for creating a power-up interrupt to the system. Writing the IRQ detect ACK register is used to clear any number of individual port bits that may be signaling that an edge was detected as configured by the port edge control register and the interrupt control register. There is a self-clearing function to this register that generates a reset pulse to clear any interrupt which has its corresponding bit set to 1.</description>
          <fields>
            <field>
              <name>PDIACK7</name>
              <description>[31:31] Port D bit 7 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>PDIACK6</name>
              <description>[30:30] Port D bit 6 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>PDIACK5</name>
              <description>[29:29] Port D bit 5 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>PDIACK4</name>
              <description>[28:28] Port D bit 4 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>PDIACK3</name>
              <description>[27:27] Port D bit 3 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>PDIACK2</name>
              <description>[26:26] Port D bit 2 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>PDIACK1</name>
              <description>[25:25] Port D bit 1 masked interrupt status:
1: Detected0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>PDIACK0</name>
              <description>[24:24] Port D bit 0 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PCIACK7</name>
              <description>[23:23] Port C bit 7 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>PCIACK6</name>
              <description>[22:22] Port C bit 6 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>PCIACK5</name>
              <description>[21:21] Port C bit 5 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>PCIACK4</name>
              <description>[20:20] Port C bit 4 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>PCIACK3</name>
              <description>[19:19] Port C bit 3 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>PCIACK2</name>
              <description>[18:18] Port C bit 2 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>PCIACK1</name>
              <description>[17:17] Port C bit 1 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>PCIACK0</name>
              <description>[16:16] Port C bit 0 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PBIACK7</name>
              <description>[15:15] Port B bit 7 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PBIACK6</name>
              <description>[14:14] Port B bit 6 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>PBIACK5</name>
              <description>[13:13] Port B bit 5 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PBIACK4</name>
              <description>[12:12] Port B bit 4 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>PBIACK3</name>
              <description>[11:11] Port B bit 3 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>PBIACK2</name>
              <description>[10:10] Port B bit 2 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PBIACK1</name>
              <description>[9:9] Port B bit 1 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PBIACK0</name>
              <description>[8:8] Port B bit 0 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PAIACK7</name>
              <description>[7:7] Port A bit 7 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>PAIACK6</name>
              <description>[6:6] Port A bit 6 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PAIACK5</name>
              <description>[5:5] Port A bit 5 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PAIACK4</name>
              <description>[4:4] Port A bit 4 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PAIACK3</name>
              <description>[3:3] Port A bit 3 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PAIACK2</name>
              <description>[2:2] Port A bit 2 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PAIACK1</name>
              <description>[1:1] Port A bit 1 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PAIACK0</name>
              <description>[0:0] Port A bit 0 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>USB_IRQ_ACK</name>
          <addressOffset>0x71c</addressOffset>
          <size>32</size>
          <description>Same functionality as IRQ_DETECT_ACK, but for USB</description>
          <fields>
            <field>
              <name>Reserved31</name>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>USBACK</name>
              <description>[0:0] USB masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IRQ_DETECT_UNMASK</name>
          <addressOffset>0x720</addressOffset>
          <size>32</size>
          <description>Same functionality as IRQ_DETECT_ACK, but this register handles masked interrupts</description>
          <fields>
            <field>
              <name>PDIACK7</name>
              <description>[31:31] Port D bit 7 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>PDIACK6</name>
              <description>[30:30] Port D bit 6 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>PDIACK5</name>
              <description>[29:29] Port D bit 5 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>PDIACK4</name>
              <description>[28:28] Port D bit 4 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>PDIACK3</name>
              <description>[27:27] Port D bit 3 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>PDIACK2</name>
              <description>[26:26] Port D bit 2 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>PDIACK1</name>
              <description>[25:25] Port D bit 1 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>PDIACK0</name>
              <description>[24:24] Port D bit 0 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PCIACK7</name>
              <description>[23:23] Port C bit 7 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>PCIACK6</name>
              <description>[22:22] Port C bit 6 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>PCIACK5</name>
              <description>[21:21] Port C bit 5 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>PCIACK4</name>
              <description>[20:20] Port C bit 4 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>PCIACK3</name>
              <description>[19:19] Port C bit 3 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>PCIACK2</name>
              <description>[18:18] Port C bit 2 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>PCIACK1</name>
              <description>[17:17] Port C bit 1 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>PCIACK0</name>
              <description>[16:16] Port C bit 0 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PBIACK7</name>
              <description>[15:15] Port B bit 7 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PBIACK6</name>
              <description>[14:14] Port B bit 6 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>PBIACK5</name>
              <description>[13:13] Port B bit 5 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PBIACK4</name>
              <description>[12:12] Port B bit 4 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>PBIACK3</name>
              <description>[11:11] Port B bit 3 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>PBIACK2</name>
              <description>[10:10] Port B bit 2 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PBIACK1</name>
              <description>[9:9] Port B bit 1 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PBIACK0</name>
              <description>[8:8] Port B bit 0 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PAIACK7</name>
              <description>[7:7] Port A bit 7 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>PAIACK6</name>
              <description>[6:6] Port A bit 6 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PAIACK5</name>
              <description>[5:5] Port A bit 5 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PAIACK4</name>
              <description>[4:4] Port A bit 4 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PAIACK3</name>
              <description>[3:3] Port A bit 3 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PAIACK2</name>
              <description>[2:2] Port A bit 2 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PAIACK1</name>
              <description>[1:1] Port A bit 1 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PAIACK0</name>
              <description>[0:0] Port A bit 0 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO_B</name>
      <baseAddress>0x400DA000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00001000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>DATA</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>This is the data register. In software control mode, values written in
the GPIODATA register are transferred onto the GPOUT pins if the respective pins have been configured as outputs through the GPIODIR register. A read from GPIODATA returns the last bit value written if the respective pins are configured as output, or it returns the value on the corresponding input GPIN bit when these are configured as inputs.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DATA</name>
              <description>[7:0] Input and output data</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIR</name>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <description>The DIR register is the data direction register. All bits are cleared by a reset; therefore, the GPIO pins are input by default.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DIR</name>
              <description>[7:0] Bits set: Corresponding pin is output
Bits cleared: Corresponding pin is input</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IS</name>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <description>The IS register is the interrupt sense register.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IS</name>
              <description>[7:0] Bits set: Level on corresponding pin is detected
Bits cleared: Edge on corresponding pin is detected</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IBE</name>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <description>The IBE register is the interrupt both-edges register. When the corresponding bit in IS is set to detect edges, bits set to high in IBE configure the corresponding pin to detect both rising and falling edges, regardless of the corresponding bit in the IEV (interrupt event register). Clearing a bit configures the pin to be controlled by IEV.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IBE</name>
              <description>[7:0] Bits set: Both edges on corresponding pin trigger an interrupt
Bits cleared: Interrupt generation event is controlled by GPIOIEV
Single edge: Determined by corresponding bit in GPIOIEV register</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IEV</name>
          <addressOffset>0x40c</addressOffset>
          <size>32</size>
          <description>The IEV register is the interrupt event register. Bits set to high in IEV
configure the corresponding pin to detect rising edges or high levels, depending on the corresponding bit value in IS. Clearing a bit configures the pin to detect falling edges or low levels, depending on the corresponding bit value in IS.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IEV</name>
              <description>[7:0] Bits set: Rising edges or high levels on corresponding pin trigger interrupts
Bits cleared: Falling edges or low levels on corresponding pin trigger interrupts</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IE</name>
          <addressOffset>0x410</addressOffset>
          <size>32</size>
          <description>The IE register is the interrupt mask register. Bits set to high in IE allow the corresponding pins to trigger their individual interrupts and the combined GPIOINTR line. Clearing a bit disables interrupt triggering on that pin.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[7:0] Bits set: Corresponding pin is not masked
Bits cleared: Corresponding pin is masked</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x414</addressOffset>
          <size>32</size>
          <description>The RIS register is the raw interrupt status register. Bits read high in RIS reflect the status of interrupts trigger conditions detected (raw, before masking), indicating that all the requirements are met, before they are finally allowed to trigger by IE. Bits read as 0 indicate that corresponding input pins have not initiated an interrupt.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RIS</name>
              <description>[7:0] Reflects the status of interrupts trigger conditions detected on pins (raw, before masking)
Bits set: Requirements met by corresponding pins
Bits clear: Requirements not met</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x418</addressOffset>
          <size>32</size>
          <description>The MIS register is the masked interrupt status register. Bits read high in MIS reflect the status of input lines triggering an interrupt. Bits read as low indicate that either no interrupt has been generated, or the interrupt is masked. MIS is the state of the interrupt after masking.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MIS</name>
              <description>[7:0] Masked value of interrupt due to corresponding pin
Bits clear: GPIO line interrupt not active
Bits set: GPIO line asserting interrupt</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IC</name>
          <addressOffset>0x41c</addressOffset>
          <size>32</size>
          <description>The IC register is the interrupt clear register. Writing 1 to a bit in this register clears the corresponding interrupt edge detection logic register. Writing 0 has no effect.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IC</name>
              <description>[7:0] Bit written as 1: Clears edge detection logic
Bit written as 0: Has no effect</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AFSEL</name>
          <addressOffset>0x420</addressOffset>
          <size>32</size>
          <description>The AFSEL register is the mode control select register. Writing 1 to any bit in this register selects the hardware (peripheral) control for the corresponding GPIO line. All bits are cleared by a reset, therefore no GPIO line is set to hardware control by default.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>AFSEL</name>
              <description>[7:0] Bit set: Enables hardware (peripheral) control mode
Bit cleared: Enables software control mode</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIOLOCK</name>
          <addressOffset>0x520</addressOffset>
          <size>32</size>
          <description>A write of the value 0x4C4F434B to the GPIOLOCK register unlocks the GPIO commit register (GPIOCR) for write access. A write of any other value reapplies the lock, preventing any register updates. Any write to the commit register (GPIOCR) causes the lock register to be locked.</description>
          <fields>
            <field>
              <name>LOCK</name>
              <description>[31:0] A read of this register returns the following values:
Locked: 0x00000001
Unlocked: 0x00000000</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIOCR</name>
          <addressOffset>0x524</addressOffset>
          <size>32</size>
          <description>The GPIOCR register is the commit register. The value of the GPIOCR register determines which bits of the AFSEL register is committed when a write to the AFSEL register is performed. If a bit in the GPIOCR register is 0, the data being written to the corresponding bit in the AFSEL register is not committed and retains its previous value. If a bit in the GPIOCR register is set to 1, the data being written to the corresponding bit of the AFSEL register is committed to the register and will reflect the new value. The contents of the GPIOCR register can only be modified if the GPIOLOCK register is unlocked. Writes to the GPIOCR register will be ignored if the GPIOLOCK register is locked. Any write to the commit register causes the lock register to be locked.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved bits return an indeterminate value, and should never be changed.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CR</name>
              <description>[7:0] On a bit-wise basis, any bit set allows the corresponding GPIOAFSEL bit to be set to its alternate function.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PMUX</name>
          <addressOffset>0x700</addressOffset>
          <size>32</size>
          <description>The PMUX register can be used to output external decouple control and clock_32k on I/O pins.  Decouple control can be output on specific PB pins and clock_32k can be output on a specific PA or PB pin. These features override the current setting of the selected pin when enabled. The pin is set to output, pull-up and -down disabled, and analog mode disabled.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CKOEN</name>
              <description>[7:7] Clock out enable
When this bit is set, the 32-kHz clock is routed to either PA[0] or PB[7] pins. PMUX.CKOPIN selects the pin to use. This overrides the current configuration setting for this pin. The pullup or pulldown is disabled and the direction is set to output for this pin.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>Reserved7</name>
              <description>[6:5] These are spare registers that are unused in the design.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>CKOPIN</name>
              <description>[4:4] Decouple control pin select
This control only has relevance when CKOEN is set. 
When 0, PA[0] becomes the 32-kHz clock output. When 1, PB[7] becomes the 32-kHz clock output.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DCEN</name>
              <description>[3:3] Decouple control enable
When this bit is set, the on-die digital regulator status is routed  to either PB[1] or PB[0] pins. PMUX.DCPIN selects the pin to use. This overrides the current configuration setting for this pin. The pullup or pulldown is disabled and the direction is set to output for this pin.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[2:1] These are spare registers that are unused in the design.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DCPIN</name>
              <description>[0:0] Decouple control pin select
This control has relevance only when DCEN is set. 
When 0, PB[1] becomes the on-die digital regulator status (1 indicates the on-die digital regulator is active); when 1, PB[0] becomes the on-die digital regulator status.

NOTE: PB[1] and PB[0] can also be controlled with other override features.

In priority order for PB[1]:
When POR/BOD test mode is active, PB[1] becomes the active low brown-out detected indicator.
When DCEN is set and DCPIN is not set, PB[1] becomes the on-dir digital regulator status.

In priority order for PB[0]:
When POR/BOD test mode is active, PB[0] becomes the power-on-reset indicator.
When DCEN and DCPIN are set, PB[0] becomes the on-die digital regulator status.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>P_EDGE_CTRL</name>
          <addressOffset>0x704</addressOffset>
          <size>32</size>
          <description>The port edge control register is used to control which edge of each port input causes that port to generate a power-up interrupt to the system.</description>
          <fields>
            <field>
              <name>PDIRC7</name>
              <description>[31:31] Port D bit 7 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>PDIRC6</name>
              <description>[30:30] Port D bit 6 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>PDIRC5</name>
              <description>[29:29] Port D bit 5 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>PDIRC4</name>
              <description>[28:28] Port D bit 4 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>PDIRC3</name>
              <description>[27:27] Port D bit 3 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>PDIRC2</name>
              <description>[26:26] Port D bit 2 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>PDIRC1</name>
              <description>[25:25] Port D bit 1 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>PDIRC0</name>
              <description>[24:24] Port D bit 0 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PCIRC7</name>
              <description>[23:23] Port C bit 7 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>PCIRC6</name>
              <description>[22:22] Port C bit 6 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>PCIRC5</name>
              <description>[21:21] Port C bit 5 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>PCIRC4</name>
              <description>[20:20] Port C bit 4 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>PCIRC3</name>
              <description>[19:19] Port C bit 3 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>PCIRC2</name>
              <description>[18:18] Port C bit 2 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>PCIRC1</name>
              <description>[17:17] Port C bit 1 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>PCIRC0</name>
              <description>[16:16] Port C bit 0 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PBIRC7</name>
              <description>[15:15] Port B bit 7 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PBIRC6</name>
              <description>[14:14] Port B bit 6 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>PBIRC5</name>
              <description>[13:13] Port B bit 5 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PBIRC4</name>
              <description>[12:12] Port B bit 4 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>PBIRC3</name>
              <description>[11:11] Port B bit 3 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>PBIRC2</name>
              <description>[10:10] Port B bit 2 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PBIRC1</name>
              <description>[9:9] Port B bit 1 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PBIRC0</name>
              <description>[8:8] Port B bit 0 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PAIRC7</name>
              <description>[7:7] Port A bit 7 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>PAIRC6</name>
              <description>[6:6] Port A bit 6 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PAIRC5</name>
              <description>[5:5] Port A bit 5 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PAIRC4</name>
              <description>[4:4] Port A bit 4 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PAIRC3</name>
              <description>[3:3] Port A bit 3 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PAIRC2</name>
              <description>[2:2] Port A bit 2 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PAIRC1</name>
              <description>[1:1] Port A bit 1 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PAIRC0</name>
              <description>[0:0] Port A bit 0 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>USB_CTRL</name>
          <addressOffset>0x708</addressOffset>
          <size>32</size>
          <description>This register is used to control which edge of the USB controller input generates a power-up interrupt to the system.</description>
          <fields>
            <field>
              <name>Reserved31</name>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>USB_EDGE_CTL</name>
              <description>[0:0] Used to set the edge which triggers the USB power up interrupt
0: Rising
1: Falling</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PI_IEN</name>
          <addressOffset>0x710</addressOffset>
          <size>32</size>
          <description>The power-up interrupt enable register selects, for its corresponding port A-D pin, whether interrupts are enabled or disabled.</description>
          <fields>
            <field>
              <name>PDIEN7</name>
              <description>[31:31] Port D bit 7 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>PDIEN6</name>
              <description>[30:30] Port D bit 6 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>PDIEN5</name>
              <description>[29:29] Port D bit 5 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>PDIEN4</name>
              <description>[28:28] Port D bit 4 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>PDIEN3</name>
              <description>[27:27] Port D bit 3 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>PDIEN2</name>
              <description>[26:26] Port D bit 2 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>PDIEN1</name>
              <description>[25:25] Port D bit 1 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>PDIEN0</name>
              <description>[24:24] Port D bit 0 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PCIEN7</name>
              <description>[23:23] Port C bit 7 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>PCIEN6</name>
              <description>[22:22] Port C bit 6 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>PCIEN5</name>
              <description>[21:21] Port C bit 5 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>PCIEN4</name>
              <description>[20:20] Port C bit 4 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>PCIEN3</name>
              <description>[19:19] Port C bit 3 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>PCIEN2</name>
              <description>[18:18] Port C bit 2 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>PCIEN1</name>
              <description>[17:17] Port C bit 1 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>PCIEN0</name>
              <description>[16:16] Port C bit 0 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PBIEN7</name>
              <description>[15:15] Port B bit 7 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PBIEN6</name>
              <description>[14:14] Port B bit 6 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>PBIEN5</name>
              <description>[13:13] Port B bit 5 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PBIEN4</name>
              <description>[12:12] Port B bit 4 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>PBIEN3</name>
              <description>[11:11] Port B bit 3 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>PBIEN2</name>
              <description>[10:10] Port B bit 2 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PBIEN1</name>
              <description>[9:9] Port B bit 1 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PBIEN0</name>
              <description>[8:8] Port B bit 0 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PAIEN7</name>
              <description>[7:7] Port A bit 7 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>PAIEN6</name>
              <description>[6:6] Port A bit 6 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PAIEN5</name>
              <description>[5:5] Port A bit 5 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PAIEN4</name>
              <description>[4:4] Port A bit 4 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PAIEN3</name>
              <description>[3:3] Port A bit 3 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PAIEN2</name>
              <description>[2:2] Port A bit 2 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PAIEN1</name>
              <description>[1:1] Port A bit 1 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PAIEN0</name>
              <description>[0:0] Port A bit 0 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IRQ_DETECT_ACK</name>
          <addressOffset>0x718</addressOffset>
          <size>32</size>
          <description>If the IRQ detect ACK register is read, the value returned can be used to determine which enabled I/O port is responsible for creating a power-up interrupt to the system. Writing the IRQ detect ACK register is used to clear any number of individual port bits that may be signaling that an edge was detected as configured by the port edge control register and the interrupt control register. There is a self-clearing function to this register that generates a reset pulse to clear any interrupt which has its corresponding bit set to 1.</description>
          <fields>
            <field>
              <name>PDIACK7</name>
              <description>[31:31] Port D bit 7 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>PDIACK6</name>
              <description>[30:30] Port D bit 6 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>PDIACK5</name>
              <description>[29:29] Port D bit 5 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>PDIACK4</name>
              <description>[28:28] Port D bit 4 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>PDIACK3</name>
              <description>[27:27] Port D bit 3 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>PDIACK2</name>
              <description>[26:26] Port D bit 2 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>PDIACK1</name>
              <description>[25:25] Port D bit 1 masked interrupt status:
1: Detected0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>PDIACK0</name>
              <description>[24:24] Port D bit 0 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PCIACK7</name>
              <description>[23:23] Port C bit 7 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>PCIACK6</name>
              <description>[22:22] Port C bit 6 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>PCIACK5</name>
              <description>[21:21] Port C bit 5 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>PCIACK4</name>
              <description>[20:20] Port C bit 4 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>PCIACK3</name>
              <description>[19:19] Port C bit 3 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>PCIACK2</name>
              <description>[18:18] Port C bit 2 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>PCIACK1</name>
              <description>[17:17] Port C bit 1 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>PCIACK0</name>
              <description>[16:16] Port C bit 0 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PBIACK7</name>
              <description>[15:15] Port B bit 7 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PBIACK6</name>
              <description>[14:14] Port B bit 6 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>PBIACK5</name>
              <description>[13:13] Port B bit 5 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PBIACK4</name>
              <description>[12:12] Port B bit 4 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>PBIACK3</name>
              <description>[11:11] Port B bit 3 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>PBIACK2</name>
              <description>[10:10] Port B bit 2 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PBIACK1</name>
              <description>[9:9] Port B bit 1 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PBIACK0</name>
              <description>[8:8] Port B bit 0 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PAIACK7</name>
              <description>[7:7] Port A bit 7 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>PAIACK6</name>
              <description>[6:6] Port A bit 6 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PAIACK5</name>
              <description>[5:5] Port A bit 5 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PAIACK4</name>
              <description>[4:4] Port A bit 4 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PAIACK3</name>
              <description>[3:3] Port A bit 3 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PAIACK2</name>
              <description>[2:2] Port A bit 2 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PAIACK1</name>
              <description>[1:1] Port A bit 1 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PAIACK0</name>
              <description>[0:0] Port A bit 0 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>USB_IRQ_ACK</name>
          <addressOffset>0x71c</addressOffset>
          <size>32</size>
          <description>Same functionality as IRQ_DETECT_ACK, but for USB</description>
          <fields>
            <field>
              <name>Reserved31</name>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>USBACK</name>
              <description>[0:0] USB masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IRQ_DETECT_UNMASK</name>
          <addressOffset>0x720</addressOffset>
          <size>32</size>
          <description>Same functionality as IRQ_DETECT_ACK, but this register handles masked interrupts</description>
          <fields>
            <field>
              <name>PDIACK7</name>
              <description>[31:31] Port D bit 7 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>PDIACK6</name>
              <description>[30:30] Port D bit 6 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>PDIACK5</name>
              <description>[29:29] Port D bit 5 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>PDIACK4</name>
              <description>[28:28] Port D bit 4 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>PDIACK3</name>
              <description>[27:27] Port D bit 3 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>PDIACK2</name>
              <description>[26:26] Port D bit 2 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>PDIACK1</name>
              <description>[25:25] Port D bit 1 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>PDIACK0</name>
              <description>[24:24] Port D bit 0 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PCIACK7</name>
              <description>[23:23] Port C bit 7 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>PCIACK6</name>
              <description>[22:22] Port C bit 6 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>PCIACK5</name>
              <description>[21:21] Port C bit 5 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>PCIACK4</name>
              <description>[20:20] Port C bit 4 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>PCIACK3</name>
              <description>[19:19] Port C bit 3 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>PCIACK2</name>
              <description>[18:18] Port C bit 2 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>PCIACK1</name>
              <description>[17:17] Port C bit 1 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>PCIACK0</name>
              <description>[16:16] Port C bit 0 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PBIACK7</name>
              <description>[15:15] Port B bit 7 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PBIACK6</name>
              <description>[14:14] Port B bit 6 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>PBIACK5</name>
              <description>[13:13] Port B bit 5 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PBIACK4</name>
              <description>[12:12] Port B bit 4 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>PBIACK3</name>
              <description>[11:11] Port B bit 3 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>PBIACK2</name>
              <description>[10:10] Port B bit 2 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PBIACK1</name>
              <description>[9:9] Port B bit 1 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PBIACK0</name>
              <description>[8:8] Port B bit 0 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PAIACK7</name>
              <description>[7:7] Port A bit 7 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>PAIACK6</name>
              <description>[6:6] Port A bit 6 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PAIACK5</name>
              <description>[5:5] Port A bit 5 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PAIACK4</name>
              <description>[4:4] Port A bit 4 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PAIACK3</name>
              <description>[3:3] Port A bit 3 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PAIACK2</name>
              <description>[2:2] Port A bit 2 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PAIACK1</name>
              <description>[1:1] Port A bit 1 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PAIACK0</name>
              <description>[0:0] Port A bit 0 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO_C</name>
      <baseAddress>0x400DB000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00001000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>DATA</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>This is the data register. In software control mode, values written in
the GPIODATA register are transferred onto the GPOUT pins if the respective pins have been configured as outputs through the GPIODIR register. A read from GPIODATA returns the last bit value written if the respective pins are configured as output, or it returns the value on the corresponding input GPIN bit when these are configured as inputs.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DATA</name>
              <description>[7:0] Input and output data</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIR</name>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <description>The DIR register is the data direction register. All bits are cleared by a reset; therefore, the GPIO pins are input by default.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DIR</name>
              <description>[7:0] Bits set: Corresponding pin is output
Bits cleared: Corresponding pin is input</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IS</name>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <description>The IS register is the interrupt sense register.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IS</name>
              <description>[7:0] Bits set: Level on corresponding pin is detected
Bits cleared: Edge on corresponding pin is detected</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IBE</name>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <description>The IBE register is the interrupt both-edges register. When the corresponding bit in IS is set to detect edges, bits set to high in IBE configure the corresponding pin to detect both rising and falling edges, regardless of the corresponding bit in the IEV (interrupt event register). Clearing a bit configures the pin to be controlled by IEV.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IBE</name>
              <description>[7:0] Bits set: Both edges on corresponding pin trigger an interrupt
Bits cleared: Interrupt generation event is controlled by GPIOIEV
Single edge: Determined by corresponding bit in GPIOIEV register</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IEV</name>
          <addressOffset>0x40c</addressOffset>
          <size>32</size>
          <description>The IEV register is the interrupt event register. Bits set to high in IEV
configure the corresponding pin to detect rising edges or high levels, depending on the corresponding bit value in IS. Clearing a bit configures the pin to detect falling edges or low levels, depending on the corresponding bit value in IS.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IEV</name>
              <description>[7:0] Bits set: Rising edges or high levels on corresponding pin trigger interrupts
Bits cleared: Falling edges or low levels on corresponding pin trigger interrupts</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IE</name>
          <addressOffset>0x410</addressOffset>
          <size>32</size>
          <description>The IE register is the interrupt mask register. Bits set to high in IE allow the corresponding pins to trigger their individual interrupts and the combined GPIOINTR line. Clearing a bit disables interrupt triggering on that pin.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[7:0] Bits set: Corresponding pin is not masked
Bits cleared: Corresponding pin is masked</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x414</addressOffset>
          <size>32</size>
          <description>The RIS register is the raw interrupt status register. Bits read high in RIS reflect the status of interrupts trigger conditions detected (raw, before masking), indicating that all the requirements are met, before they are finally allowed to trigger by IE. Bits read as 0 indicate that corresponding input pins have not initiated an interrupt.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RIS</name>
              <description>[7:0] Reflects the status of interrupts trigger conditions detected on pins (raw, before masking)
Bits set: Requirements met by corresponding pins
Bits clear: Requirements not met</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x418</addressOffset>
          <size>32</size>
          <description>The MIS register is the masked interrupt status register. Bits read high in MIS reflect the status of input lines triggering an interrupt. Bits read as low indicate that either no interrupt has been generated, or the interrupt is masked. MIS is the state of the interrupt after masking.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MIS</name>
              <description>[7:0] Masked value of interrupt due to corresponding pin
Bits clear: GPIO line interrupt not active
Bits set: GPIO line asserting interrupt</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IC</name>
          <addressOffset>0x41c</addressOffset>
          <size>32</size>
          <description>The IC register is the interrupt clear register. Writing 1 to a bit in this register clears the corresponding interrupt edge detection logic register. Writing 0 has no effect.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IC</name>
              <description>[7:0] Bit written as 1: Clears edge detection logic
Bit written as 0: Has no effect</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AFSEL</name>
          <addressOffset>0x420</addressOffset>
          <size>32</size>
          <description>The AFSEL register is the mode control select register. Writing 1 to any bit in this register selects the hardware (peripheral) control for the corresponding GPIO line. All bits are cleared by a reset, therefore no GPIO line is set to hardware control by default.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>AFSEL</name>
              <description>[7:0] Bit set: Enables hardware (peripheral) control mode
Bit cleared: Enables software control mode</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIOLOCK</name>
          <addressOffset>0x520</addressOffset>
          <size>32</size>
          <description>A write of the value 0x4C4F434B to the GPIOLOCK register unlocks the GPIO commit register (GPIOCR) for write access. A write of any other value reapplies the lock, preventing any register updates. Any write to the commit register (GPIOCR) causes the lock register to be locked.</description>
          <fields>
            <field>
              <name>LOCK</name>
              <description>[31:0] A read of this register returns the following values:
Locked: 0x00000001
Unlocked: 0x00000000</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIOCR</name>
          <addressOffset>0x524</addressOffset>
          <size>32</size>
          <description>The GPIOCR register is the commit register. The value of the GPIOCR register determines which bits of the AFSEL register is committed when a write to the AFSEL register is performed. If a bit in the GPIOCR register is 0, the data being written to the corresponding bit in the AFSEL register is not committed and retains its previous value. If a bit in the GPIOCR register is set to 1, the data being written to the corresponding bit of the AFSEL register is committed to the register and will reflect the new value. The contents of the GPIOCR register can only be modified if the GPIOLOCK register is unlocked. Writes to the GPIOCR register will be ignored if the GPIOLOCK register is locked. Any write to the commit register causes the lock register to be locked.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved bits return an indeterminate value, and should never be changed.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CR</name>
              <description>[7:0] On a bit-wise basis, any bit set allows the corresponding GPIOAFSEL bit to be set to its alternate function.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PMUX</name>
          <addressOffset>0x700</addressOffset>
          <size>32</size>
          <description>The PMUX register can be used to output external decouple control and clock_32k on I/O pins.  Decouple control can be output on specific PB pins and clock_32k can be output on a specific PA or PB pin. These features override the current setting of the selected pin when enabled. The pin is set to output, pull-up and -down disabled, and analog mode disabled.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CKOEN</name>
              <description>[7:7] Clock out enable
When this bit is set, the 32-kHz clock is routed to either PA[0] or PB[7] pins. PMUX.CKOPIN selects the pin to use. This overrides the current configuration setting for this pin. The pullup or pulldown is disabled and the direction is set to output for this pin.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>Reserved7</name>
              <description>[6:5] These are spare registers that are unused in the design.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>CKOPIN</name>
              <description>[4:4] Decouple control pin select
This control only has relevance when CKOEN is set. 
When 0, PA[0] becomes the 32-kHz clock output. When 1, PB[7] becomes the 32-kHz clock output.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DCEN</name>
              <description>[3:3] Decouple control enable
When this bit is set, the on-die digital regulator status is routed  to either PB[1] or PB[0] pins. PMUX.DCPIN selects the pin to use. This overrides the current configuration setting for this pin. The pullup or pulldown is disabled and the direction is set to output for this pin.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[2:1] These are spare registers that are unused in the design.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DCPIN</name>
              <description>[0:0] Decouple control pin select
This control has relevance only when DCEN is set. 
When 0, PB[1] becomes the on-die digital regulator status (1 indicates the on-die digital regulator is active); when 1, PB[0] becomes the on-die digital regulator status.

NOTE: PB[1] and PB[0] can also be controlled with other override features.

In priority order for PB[1]:
When POR/BOD test mode is active, PB[1] becomes the active low brown-out detected indicator.
When DCEN is set and DCPIN is not set, PB[1] becomes the on-dir digital regulator status.

In priority order for PB[0]:
When POR/BOD test mode is active, PB[0] becomes the power-on-reset indicator.
When DCEN and DCPIN are set, PB[0] becomes the on-die digital regulator status.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>P_EDGE_CTRL</name>
          <addressOffset>0x704</addressOffset>
          <size>32</size>
          <description>The port edge control register is used to control which edge of each port input causes that port to generate a power-up interrupt to the system.</description>
          <fields>
            <field>
              <name>PDIRC7</name>
              <description>[31:31] Port D bit 7 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>PDIRC6</name>
              <description>[30:30] Port D bit 6 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>PDIRC5</name>
              <description>[29:29] Port D bit 5 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>PDIRC4</name>
              <description>[28:28] Port D bit 4 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>PDIRC3</name>
              <description>[27:27] Port D bit 3 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>PDIRC2</name>
              <description>[26:26] Port D bit 2 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>PDIRC1</name>
              <description>[25:25] Port D bit 1 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>PDIRC0</name>
              <description>[24:24] Port D bit 0 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PCIRC7</name>
              <description>[23:23] Port C bit 7 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>PCIRC6</name>
              <description>[22:22] Port C bit 6 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>PCIRC5</name>
              <description>[21:21] Port C bit 5 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>PCIRC4</name>
              <description>[20:20] Port C bit 4 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>PCIRC3</name>
              <description>[19:19] Port C bit 3 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>PCIRC2</name>
              <description>[18:18] Port C bit 2 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>PCIRC1</name>
              <description>[17:17] Port C bit 1 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>PCIRC0</name>
              <description>[16:16] Port C bit 0 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PBIRC7</name>
              <description>[15:15] Port B bit 7 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PBIRC6</name>
              <description>[14:14] Port B bit 6 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>PBIRC5</name>
              <description>[13:13] Port B bit 5 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PBIRC4</name>
              <description>[12:12] Port B bit 4 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>PBIRC3</name>
              <description>[11:11] Port B bit 3 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>PBIRC2</name>
              <description>[10:10] Port B bit 2 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PBIRC1</name>
              <description>[9:9] Port B bit 1 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PBIRC0</name>
              <description>[8:8] Port B bit 0 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PAIRC7</name>
              <description>[7:7] Port A bit 7 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>PAIRC6</name>
              <description>[6:6] Port A bit 6 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PAIRC5</name>
              <description>[5:5] Port A bit 5 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PAIRC4</name>
              <description>[4:4] Port A bit 4 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PAIRC3</name>
              <description>[3:3] Port A bit 3 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PAIRC2</name>
              <description>[2:2] Port A bit 2 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PAIRC1</name>
              <description>[1:1] Port A bit 1 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PAIRC0</name>
              <description>[0:0] Port A bit 0 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>USB_CTRL</name>
          <addressOffset>0x708</addressOffset>
          <size>32</size>
          <description>This register is used to control which edge of the USB controller input generates a power-up interrupt to the system.</description>
          <fields>
            <field>
              <name>Reserved31</name>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>USB_EDGE_CTL</name>
              <description>[0:0] Used to set the edge which triggers the USB power up interrupt
0: Rising
1: Falling</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PI_IEN</name>
          <addressOffset>0x710</addressOffset>
          <size>32</size>
          <description>The power-up interrupt enable register selects, for its corresponding port A-D pin, whether interrupts are enabled or disabled.</description>
          <fields>
            <field>
              <name>PDIEN7</name>
              <description>[31:31] Port D bit 7 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>PDIEN6</name>
              <description>[30:30] Port D bit 6 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>PDIEN5</name>
              <description>[29:29] Port D bit 5 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>PDIEN4</name>
              <description>[28:28] Port D bit 4 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>PDIEN3</name>
              <description>[27:27] Port D bit 3 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>PDIEN2</name>
              <description>[26:26] Port D bit 2 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>PDIEN1</name>
              <description>[25:25] Port D bit 1 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>PDIEN0</name>
              <description>[24:24] Port D bit 0 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PCIEN7</name>
              <description>[23:23] Port C bit 7 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>PCIEN6</name>
              <description>[22:22] Port C bit 6 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>PCIEN5</name>
              <description>[21:21] Port C bit 5 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>PCIEN4</name>
              <description>[20:20] Port C bit 4 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>PCIEN3</name>
              <description>[19:19] Port C bit 3 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>PCIEN2</name>
              <description>[18:18] Port C bit 2 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>PCIEN1</name>
              <description>[17:17] Port C bit 1 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>PCIEN0</name>
              <description>[16:16] Port C bit 0 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PBIEN7</name>
              <description>[15:15] Port B bit 7 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PBIEN6</name>
              <description>[14:14] Port B bit 6 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>PBIEN5</name>
              <description>[13:13] Port B bit 5 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PBIEN4</name>
              <description>[12:12] Port B bit 4 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>PBIEN3</name>
              <description>[11:11] Port B bit 3 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>PBIEN2</name>
              <description>[10:10] Port B bit 2 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PBIEN1</name>
              <description>[9:9] Port B bit 1 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PBIEN0</name>
              <description>[8:8] Port B bit 0 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PAIEN7</name>
              <description>[7:7] Port A bit 7 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>PAIEN6</name>
              <description>[6:6] Port A bit 6 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PAIEN5</name>
              <description>[5:5] Port A bit 5 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PAIEN4</name>
              <description>[4:4] Port A bit 4 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PAIEN3</name>
              <description>[3:3] Port A bit 3 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PAIEN2</name>
              <description>[2:2] Port A bit 2 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PAIEN1</name>
              <description>[1:1] Port A bit 1 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PAIEN0</name>
              <description>[0:0] Port A bit 0 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IRQ_DETECT_ACK</name>
          <addressOffset>0x718</addressOffset>
          <size>32</size>
          <description>If the IRQ detect ACK register is read, the value returned can be used to determine which enabled I/O port is responsible for creating a power-up interrupt to the system. Writing the IRQ detect ACK register is used to clear any number of individual port bits that may be signaling that an edge was detected as configured by the port edge control register and the interrupt control register. There is a self-clearing function to this register that generates a reset pulse to clear any interrupt which has its corresponding bit set to 1.</description>
          <fields>
            <field>
              <name>PDIACK7</name>
              <description>[31:31] Port D bit 7 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>PDIACK6</name>
              <description>[30:30] Port D bit 6 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>PDIACK5</name>
              <description>[29:29] Port D bit 5 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>PDIACK4</name>
              <description>[28:28] Port D bit 4 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>PDIACK3</name>
              <description>[27:27] Port D bit 3 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>PDIACK2</name>
              <description>[26:26] Port D bit 2 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>PDIACK1</name>
              <description>[25:25] Port D bit 1 masked interrupt status:
1: Detected0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>PDIACK0</name>
              <description>[24:24] Port D bit 0 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PCIACK7</name>
              <description>[23:23] Port C bit 7 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>PCIACK6</name>
              <description>[22:22] Port C bit 6 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>PCIACK5</name>
              <description>[21:21] Port C bit 5 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>PCIACK4</name>
              <description>[20:20] Port C bit 4 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>PCIACK3</name>
              <description>[19:19] Port C bit 3 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>PCIACK2</name>
              <description>[18:18] Port C bit 2 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>PCIACK1</name>
              <description>[17:17] Port C bit 1 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>PCIACK0</name>
              <description>[16:16] Port C bit 0 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PBIACK7</name>
              <description>[15:15] Port B bit 7 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PBIACK6</name>
              <description>[14:14] Port B bit 6 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>PBIACK5</name>
              <description>[13:13] Port B bit 5 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PBIACK4</name>
              <description>[12:12] Port B bit 4 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>PBIACK3</name>
              <description>[11:11] Port B bit 3 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>PBIACK2</name>
              <description>[10:10] Port B bit 2 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PBIACK1</name>
              <description>[9:9] Port B bit 1 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PBIACK0</name>
              <description>[8:8] Port B bit 0 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PAIACK7</name>
              <description>[7:7] Port A bit 7 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>PAIACK6</name>
              <description>[6:6] Port A bit 6 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PAIACK5</name>
              <description>[5:5] Port A bit 5 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PAIACK4</name>
              <description>[4:4] Port A bit 4 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PAIACK3</name>
              <description>[3:3] Port A bit 3 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PAIACK2</name>
              <description>[2:2] Port A bit 2 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PAIACK1</name>
              <description>[1:1] Port A bit 1 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PAIACK0</name>
              <description>[0:0] Port A bit 0 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>USB_IRQ_ACK</name>
          <addressOffset>0x71c</addressOffset>
          <size>32</size>
          <description>Same functionality as IRQ_DETECT_ACK, but for USB</description>
          <fields>
            <field>
              <name>Reserved31</name>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>USBACK</name>
              <description>[0:0] USB masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IRQ_DETECT_UNMASK</name>
          <addressOffset>0x720</addressOffset>
          <size>32</size>
          <description>Same functionality as IRQ_DETECT_ACK, but this register handles masked interrupts</description>
          <fields>
            <field>
              <name>PDIACK7</name>
              <description>[31:31] Port D bit 7 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>PDIACK6</name>
              <description>[30:30] Port D bit 6 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>PDIACK5</name>
              <description>[29:29] Port D bit 5 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>PDIACK4</name>
              <description>[28:28] Port D bit 4 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>PDIACK3</name>
              <description>[27:27] Port D bit 3 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>PDIACK2</name>
              <description>[26:26] Port D bit 2 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>PDIACK1</name>
              <description>[25:25] Port D bit 1 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>PDIACK0</name>
              <description>[24:24] Port D bit 0 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PCIACK7</name>
              <description>[23:23] Port C bit 7 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>PCIACK6</name>
              <description>[22:22] Port C bit 6 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>PCIACK5</name>
              <description>[21:21] Port C bit 5 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>PCIACK4</name>
              <description>[20:20] Port C bit 4 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>PCIACK3</name>
              <description>[19:19] Port C bit 3 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>PCIACK2</name>
              <description>[18:18] Port C bit 2 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>PCIACK1</name>
              <description>[17:17] Port C bit 1 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>PCIACK0</name>
              <description>[16:16] Port C bit 0 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PBIACK7</name>
              <description>[15:15] Port B bit 7 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PBIACK6</name>
              <description>[14:14] Port B bit 6 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>PBIACK5</name>
              <description>[13:13] Port B bit 5 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PBIACK4</name>
              <description>[12:12] Port B bit 4 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>PBIACK3</name>
              <description>[11:11] Port B bit 3 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>PBIACK2</name>
              <description>[10:10] Port B bit 2 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PBIACK1</name>
              <description>[9:9] Port B bit 1 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PBIACK0</name>
              <description>[8:8] Port B bit 0 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PAIACK7</name>
              <description>[7:7] Port A bit 7 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>PAIACK6</name>
              <description>[6:6] Port A bit 6 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PAIACK5</name>
              <description>[5:5] Port A bit 5 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PAIACK4</name>
              <description>[4:4] Port A bit 4 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PAIACK3</name>
              <description>[3:3] Port A bit 3 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PAIACK2</name>
              <description>[2:2] Port A bit 2 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PAIACK1</name>
              <description>[1:1] Port A bit 1 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PAIACK0</name>
              <description>[0:0] Port A bit 0 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO_D</name>
      <baseAddress>0x400DC000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00001000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>DATA</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>This is the data register. In software control mode, values written in
the GPIODATA register are transferred onto the GPOUT pins if the respective pins have been configured as outputs through the GPIODIR register. A read from GPIODATA returns the last bit value written if the respective pins are configured as output, or it returns the value on the corresponding input GPIN bit when these are configured as inputs.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DATA</name>
              <description>[7:0] Input and output data</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIR</name>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <description>The DIR register is the data direction register. All bits are cleared by a reset; therefore, the GPIO pins are input by default.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DIR</name>
              <description>[7:0] Bits set: Corresponding pin is output
Bits cleared: Corresponding pin is input</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IS</name>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <description>The IS register is the interrupt sense register.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IS</name>
              <description>[7:0] Bits set: Level on corresponding pin is detected
Bits cleared: Edge on corresponding pin is detected</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IBE</name>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <description>The IBE register is the interrupt both-edges register. When the corresponding bit in IS is set to detect edges, bits set to high in IBE configure the corresponding pin to detect both rising and falling edges, regardless of the corresponding bit in the IEV (interrupt event register). Clearing a bit configures the pin to be controlled by IEV.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IBE</name>
              <description>[7:0] Bits set: Both edges on corresponding pin trigger an interrupt
Bits cleared: Interrupt generation event is controlled by GPIOIEV
Single edge: Determined by corresponding bit in GPIOIEV register</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IEV</name>
          <addressOffset>0x40c</addressOffset>
          <size>32</size>
          <description>The IEV register is the interrupt event register. Bits set to high in IEV
configure the corresponding pin to detect rising edges or high levels, depending on the corresponding bit value in IS. Clearing a bit configures the pin to detect falling edges or low levels, depending on the corresponding bit value in IS.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IEV</name>
              <description>[7:0] Bits set: Rising edges or high levels on corresponding pin trigger interrupts
Bits cleared: Falling edges or low levels on corresponding pin trigger interrupts</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IE</name>
          <addressOffset>0x410</addressOffset>
          <size>32</size>
          <description>The IE register is the interrupt mask register. Bits set to high in IE allow the corresponding pins to trigger their individual interrupts and the combined GPIOINTR line. Clearing a bit disables interrupt triggering on that pin.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[7:0] Bits set: Corresponding pin is not masked
Bits cleared: Corresponding pin is masked</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x414</addressOffset>
          <size>32</size>
          <description>The RIS register is the raw interrupt status register. Bits read high in RIS reflect the status of interrupts trigger conditions detected (raw, before masking), indicating that all the requirements are met, before they are finally allowed to trigger by IE. Bits read as 0 indicate that corresponding input pins have not initiated an interrupt.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RIS</name>
              <description>[7:0] Reflects the status of interrupts trigger conditions detected on pins (raw, before masking)
Bits set: Requirements met by corresponding pins
Bits clear: Requirements not met</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x418</addressOffset>
          <size>32</size>
          <description>The MIS register is the masked interrupt status register. Bits read high in MIS reflect the status of input lines triggering an interrupt. Bits read as low indicate that either no interrupt has been generated, or the interrupt is masked. MIS is the state of the interrupt after masking.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MIS</name>
              <description>[7:0] Masked value of interrupt due to corresponding pin
Bits clear: GPIO line interrupt not active
Bits set: GPIO line asserting interrupt</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IC</name>
          <addressOffset>0x41c</addressOffset>
          <size>32</size>
          <description>The IC register is the interrupt clear register. Writing 1 to a bit in this register clears the corresponding interrupt edge detection logic register. Writing 0 has no effect.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IC</name>
              <description>[7:0] Bit written as 1: Clears edge detection logic
Bit written as 0: Has no effect</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>AFSEL</name>
          <addressOffset>0x420</addressOffset>
          <size>32</size>
          <description>The AFSEL register is the mode control select register. Writing 1 to any bit in this register selects the hardware (peripheral) control for the corresponding GPIO line. All bits are cleared by a reset, therefore no GPIO line is set to hardware control by default.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>AFSEL</name>
              <description>[7:0] Bit set: Enables hardware (peripheral) control mode
Bit cleared: Enables software control mode</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIOLOCK</name>
          <addressOffset>0x520</addressOffset>
          <size>32</size>
          <description>A write of the value 0x4C4F434B to the GPIOLOCK register unlocks the GPIO commit register (GPIOCR) for write access. A write of any other value reapplies the lock, preventing any register updates. Any write to the commit register (GPIOCR) causes the lock register to be locked.</description>
          <fields>
            <field>
              <name>LOCK</name>
              <description>[31:0] A read of this register returns the following values:
Locked: 0x00000001
Unlocked: 0x00000000</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPIOCR</name>
          <addressOffset>0x524</addressOffset>
          <size>32</size>
          <description>The GPIOCR register is the commit register. The value of the GPIOCR register determines which bits of the AFSEL register is committed when a write to the AFSEL register is performed. If a bit in the GPIOCR register is 0, the data being written to the corresponding bit in the AFSEL register is not committed and retains its previous value. If a bit in the GPIOCR register is set to 1, the data being written to the corresponding bit of the AFSEL register is committed to the register and will reflect the new value. The contents of the GPIOCR register can only be modified if the GPIOLOCK register is unlocked. Writes to the GPIOCR register will be ignored if the GPIOLOCK register is locked. Any write to the commit register causes the lock register to be locked.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <description>[31:8] Reserved bits return an indeterminate value, and should never be changed.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CR</name>
              <description>[7:0] On a bit-wise basis, any bit set allows the corresponding GPIOAFSEL bit to be set to its alternate function.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PMUX</name>
          <addressOffset>0x700</addressOffset>
          <size>32</size>
          <description>The PMUX register can be used to output external decouple control and clock_32k on I/O pins.  Decouple control can be output on specific PB pins and clock_32k can be output on a specific PA or PB pin. These features override the current setting of the selected pin when enabled. The pin is set to output, pull-up and -down disabled, and analog mode disabled.</description>
          <fields>
            <field>
              <name>Reserved32</name>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CKOEN</name>
              <description>[7:7] Clock out enable
When this bit is set, the 32-kHz clock is routed to either PA[0] or PB[7] pins. PMUX.CKOPIN selects the pin to use. This overrides the current configuration setting for this pin. The pullup or pulldown is disabled and the direction is set to output for this pin.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>Reserved7</name>
              <description>[6:5] These are spare registers that are unused in the design.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>CKOPIN</name>
              <description>[4:4] Decouple control pin select
This control only has relevance when CKOEN is set. 
When 0, PA[0] becomes the 32-kHz clock output. When 1, PB[7] becomes the 32-kHz clock output.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DCEN</name>
              <description>[3:3] Decouple control enable
When this bit is set, the on-die digital regulator status is routed  to either PB[1] or PB[0] pins. PMUX.DCPIN selects the pin to use. This overrides the current configuration setting for this pin. The pullup or pulldown is disabled and the direction is set to output for this pin.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[2:1] These are spare registers that are unused in the design.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DCPIN</name>
              <description>[0:0] Decouple control pin select
This control has relevance only when DCEN is set. 
When 0, PB[1] becomes the on-die digital regulator status (1 indicates the on-die digital regulator is active); when 1, PB[0] becomes the on-die digital regulator status.

NOTE: PB[1] and PB[0] can also be controlled with other override features.

In priority order for PB[1]:
When POR/BOD test mode is active, PB[1] becomes the active low brown-out detected indicator.
When DCEN is set and DCPIN is not set, PB[1] becomes the on-dir digital regulator status.

In priority order for PB[0]:
When POR/BOD test mode is active, PB[0] becomes the power-on-reset indicator.
When DCEN and DCPIN are set, PB[0] becomes the on-die digital regulator status.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>P_EDGE_CTRL</name>
          <addressOffset>0x704</addressOffset>
          <size>32</size>
          <description>The port edge control register is used to control which edge of each port input causes that port to generate a power-up interrupt to the system.</description>
          <fields>
            <field>
              <name>PDIRC7</name>
              <description>[31:31] Port D bit 7 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>PDIRC6</name>
              <description>[30:30] Port D bit 6 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>PDIRC5</name>
              <description>[29:29] Port D bit 5 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>PDIRC4</name>
              <description>[28:28] Port D bit 4 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>PDIRC3</name>
              <description>[27:27] Port D bit 3 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>PDIRC2</name>
              <description>[26:26] Port D bit 2 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>PDIRC1</name>
              <description>[25:25] Port D bit 1 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>PDIRC0</name>
              <description>[24:24] Port D bit 0 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PCIRC7</name>
              <description>[23:23] Port C bit 7 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>PCIRC6</name>
              <description>[22:22] Port C bit 6 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>PCIRC5</name>
              <description>[21:21] Port C bit 5 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>PCIRC4</name>
              <description>[20:20] Port C bit 4 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>PCIRC3</name>
              <description>[19:19] Port C bit 3 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>PCIRC2</name>
              <description>[18:18] Port C bit 2 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>PCIRC1</name>
              <description>[17:17] Port C bit 1 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>PCIRC0</name>
              <description>[16:16] Port C bit 0 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PBIRC7</name>
              <description>[15:15] Port B bit 7 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PBIRC6</name>
              <description>[14:14] Port B bit 6 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>PBIRC5</name>
              <description>[13:13] Port B bit 5 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PBIRC4</name>
              <description>[12:12] Port B bit 4 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>PBIRC3</name>
              <description>[11:11] Port B bit 3 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>PBIRC2</name>
              <description>[10:10] Port B bit 2 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PBIRC1</name>
              <description>[9:9] Port B bit 1 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PBIRC0</name>
              <description>[8:8] Port B bit 0 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PAIRC7</name>
              <description>[7:7] Port A bit 7 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>PAIRC6</name>
              <description>[6:6] Port A bit 6 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PAIRC5</name>
              <description>[5:5] Port A bit 5 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PAIRC4</name>
              <description>[4:4] Port A bit 4 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PAIRC3</name>
              <description>[3:3] Port A bit 3 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PAIRC2</name>
              <description>[2:2] Port A bit 2 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PAIRC1</name>
              <description>[1:1] Port A bit 1 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PAIRC0</name>
              <description>[0:0] Port A bit 0 interrupt request condition:
0: Rising
1: Falling edge</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>USB_CTRL</name>
          <addressOffset>0x708</addressOffset>
          <size>32</size>
          <description>This register is used to control which edge of the USB controller input generates a power-up interrupt to the system.</description>
          <fields>
            <field>
              <name>Reserved31</name>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>USB_EDGE_CTL</name>
              <description>[0:0] Used to set the edge which triggers the USB power up interrupt
0: Rising
1: Falling</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PI_IEN</name>
          <addressOffset>0x710</addressOffset>
          <size>32</size>
          <description>The power-up interrupt enable register selects, for its corresponding port A-D pin, whether interrupts are enabled or disabled.</description>
          <fields>
            <field>
              <name>PDIEN7</name>
              <description>[31:31] Port D bit 7 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>PDIEN6</name>
              <description>[30:30] Port D bit 6 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>PDIEN5</name>
              <description>[29:29] Port D bit 5 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>PDIEN4</name>
              <description>[28:28] Port D bit 4 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>PDIEN3</name>
              <description>[27:27] Port D bit 3 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>PDIEN2</name>
              <description>[26:26] Port D bit 2 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>PDIEN1</name>
              <description>[25:25] Port D bit 1 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>PDIEN0</name>
              <description>[24:24] Port D bit 0 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PCIEN7</name>
              <description>[23:23] Port C bit 7 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>PCIEN6</name>
              <description>[22:22] Port C bit 6 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>PCIEN5</name>
              <description>[21:21] Port C bit 5 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>PCIEN4</name>
              <description>[20:20] Port C bit 4 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>PCIEN3</name>
              <description>[19:19] Port C bit 3 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>PCIEN2</name>
              <description>[18:18] Port C bit 2 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>PCIEN1</name>
              <description>[17:17] Port C bit 1 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>PCIEN0</name>
              <description>[16:16] Port C bit 0 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PBIEN7</name>
              <description>[15:15] Port B bit 7 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PBIEN6</name>
              <description>[14:14] Port B bit 6 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>PBIEN5</name>
              <description>[13:13] Port B bit 5 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PBIEN4</name>
              <description>[12:12] Port B bit 4 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>PBIEN3</name>
              <description>[11:11] Port B bit 3 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>PBIEN2</name>
              <description>[10:10] Port B bit 2 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PBIEN1</name>
              <description>[9:9] Port B bit 1 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PBIEN0</name>
              <description>[8:8] Port B bit 0 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PAIEN7</name>
              <description>[7:7] Port A bit 7 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>PAIEN6</name>
              <description>[6:6] Port A bit 6 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PAIEN5</name>
              <description>[5:5] Port A bit 5 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PAIEN4</name>
              <description>[4:4] Port A bit 4 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PAIEN3</name>
              <description>[3:3] Port A bit 3 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PAIEN2</name>
              <description>[2:2] Port A bit 2 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PAIEN1</name>
              <description>[1:1] Port A bit 1 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PAIEN0</name>
              <description>[0:0] Port A bit 0 interrupt enable:
1: Enabled
2: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IRQ_DETECT_ACK</name>
          <addressOffset>0x718</addressOffset>
          <size>32</size>
          <description>If the IRQ detect ACK register is read, the value returned can be used to determine which enabled I/O port is responsible for creating a power-up interrupt to the system. Writing the IRQ detect ACK register is used to clear any number of individual port bits that may be signaling that an edge was detected as configured by the port edge control register and the interrupt control register. There is a self-clearing function to this register that generates a reset pulse to clear any interrupt which has its corresponding bit set to 1.</description>
          <fields>
            <field>
              <name>PDIACK7</name>
              <description>[31:31] Port D bit 7 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>PDIACK6</name>
              <description>[30:30] Port D bit 6 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>PDIACK5</name>
              <description>[29:29] Port D bit 5 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>PDIACK4</name>
              <description>[28:28] Port D bit 4 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>PDIACK3</name>
              <description>[27:27] Port D bit 3 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>PDIACK2</name>
              <description>[26:26] Port D bit 2 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>PDIACK1</name>
              <description>[25:25] Port D bit 1 masked interrupt status:
1: Detected0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>PDIACK0</name>
              <description>[24:24] Port D bit 0 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PCIACK7</name>
              <description>[23:23] Port C bit 7 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>PCIACK6</name>
              <description>[22:22] Port C bit 6 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>PCIACK5</name>
              <description>[21:21] Port C bit 5 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>PCIACK4</name>
              <description>[20:20] Port C bit 4 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>PCIACK3</name>
              <description>[19:19] Port C bit 3 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>PCIACK2</name>
              <description>[18:18] Port C bit 2 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>PCIACK1</name>
              <description>[17:17] Port C bit 1 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>PCIACK0</name>
              <description>[16:16] Port C bit 0 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PBIACK7</name>
              <description>[15:15] Port B bit 7 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PBIACK6</name>
              <description>[14:14] Port B bit 6 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>PBIACK5</name>
              <description>[13:13] Port B bit 5 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PBIACK4</name>
              <description>[12:12] Port B bit 4 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>PBIACK3</name>
              <description>[11:11] Port B bit 3 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>PBIACK2</name>
              <description>[10:10] Port B bit 2 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PBIACK1</name>
              <description>[9:9] Port B bit 1 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PBIACK0</name>
              <description>[8:8] Port B bit 0 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PAIACK7</name>
              <description>[7:7] Port A bit 7 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>PAIACK6</name>
              <description>[6:6] Port A bit 6 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PAIACK5</name>
              <description>[5:5] Port A bit 5 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PAIACK4</name>
              <description>[4:4] Port A bit 4 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PAIACK3</name>
              <description>[3:3] Port A bit 3 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PAIACK2</name>
              <description>[2:2] Port A bit 2 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PAIACK1</name>
              <description>[1:1] Port A bit 1 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PAIACK0</name>
              <description>[0:0] Port A bit 0 masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>USB_IRQ_ACK</name>
          <addressOffset>0x71c</addressOffset>
          <size>32</size>
          <description>Same functionality as IRQ_DETECT_ACK, but for USB</description>
          <fields>
            <field>
              <name>Reserved31</name>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>USBACK</name>
              <description>[0:0] USB masked interrupt status:
1: Detected
0: Not detected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>IRQ_DETECT_UNMASK</name>
          <addressOffset>0x720</addressOffset>
          <size>32</size>
          <description>Same functionality as IRQ_DETECT_ACK, but this register handles masked interrupts</description>
          <fields>
            <field>
              <name>PDIACK7</name>
              <description>[31:31] Port D bit 7 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>PDIACK6</name>
              <description>[30:30] Port D bit 6 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>PDIACK5</name>
              <description>[29:29] Port D bit 5 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>PDIACK4</name>
              <description>[28:28] Port D bit 4 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>PDIACK3</name>
              <description>[27:27] Port D bit 3 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>PDIACK2</name>
              <description>[26:26] Port D bit 2 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>PDIACK1</name>
              <description>[25:25] Port D bit 1 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>PDIACK0</name>
              <description>[24:24] Port D bit 0 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PCIACK7</name>
              <description>[23:23] Port C bit 7 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>PCIACK6</name>
              <description>[22:22] Port C bit 6 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>PCIACK5</name>
              <description>[21:21] Port C bit 5 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>PCIACK4</name>
              <description>[20:20] Port C bit 4 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>PCIACK3</name>
              <description>[19:19] Port C bit 3 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>PCIACK2</name>
              <description>[18:18] Port C bit 2 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>PCIACK1</name>
              <description>[17:17] Port C bit 1 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>PCIACK0</name>
              <description>[16:16] Port C bit 0 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PBIACK7</name>
              <description>[15:15] Port B bit 7 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PBIACK6</name>
              <description>[14:14] Port B bit 6 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>PBIACK5</name>
              <description>[13:13] Port B bit 5 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PBIACK4</name>
              <description>[12:12] Port B bit 4 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>PBIACK3</name>
              <description>[11:11] Port B bit 3 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>PBIACK2</name>
              <description>[10:10] Port B bit 2 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PBIACK1</name>
              <description>[9:9] Port B bit 1 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PBIACK0</name>
              <description>[8:8] Port B bit 0 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PAIACK7</name>
              <description>[7:7] Port A bit 7 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>PAIACK6</name>
              <description>[6:6] Port A bit 6 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PAIACK5</name>
              <description>[5:5] Port A bit 5 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PAIACK4</name>
              <description>[4:4] Port A bit 4 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PAIACK3</name>
              <description>[3:3] Port A bit 3 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PAIACK2</name>
              <description>[2:2] Port A bit 2 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PAIACK1</name>
              <description>[1:1] Port A bit 1 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PAIACK0</name>
              <description>[0:0] Port A bit 0 unmasked interrupt status:
1: Detected
0: Undetected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UDMA</name>
      <baseAddress>0x400FF000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00001000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>STAT</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>DMA status
The STAT register returns the status of the uDMA controller. This register cannot be read when the uDMA controller is in the reset state.</description>
          <fields>
            <field>
              <name>Reserved11</name>
              <description>[31:21] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>11</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>DMACHANS</name>
              <description>[20:16] Available uDMA channels minus 1
This field contains a value equal to the number of uDMA channels the uDMA controller is configured to use, minus one. The value of 0x1F corresponds to 32 uDMA channels.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved8</name>
              <description>[15:8] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>STATE</name>
              <description>[7:4] Control state machine status
This field shows the current status of the control state-machine. Status can be one of the following:
0x0: Idle
0x1: Reading channel controller data
0x2: Reading source end pointer
0x3: Reading destination end pointer
0x4: Reading source data
0x5: Writing destination data
0x6: Waiting for uDMA request to clear
0x7: Writing channel controller data
0x8: Stalled
0x9: Done
0xA-0xF: Undefined</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[3:1] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>MASTEN</name>
              <description>[0:0] Master enable status
0: The uDMA controller is disabled.
1: The uDMA controller is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CFG</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>DMA configuration
The CFG register controls the configuration of the uDMA controller.</description>
          <fields>
            <field>
              <name>Reserved31</name>
              <description>[31:1] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>MASTEN</name>
              <description>[0:0] Controller master enable
0: Disables the uDMA controller.
1: Enables the uDMA controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CTLBASE</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>DMA channel control base pointer
The CTLBASE register must be configured so that the base pointer points to a location in system memory.
The amount of system memory that must be assigned to the uDMA controller depends on the number of uDMA channels used and whether the alternate channel control data structure is used. See Section 10.2.5 for details about the Channel Control Table. The base address must be aligned on a 1024-byte boundary. This register cannot be read when the uDMA controller is in the reset state.</description>
          <fields>
            <field>
              <name>ADDR</name>
              <description>[31:10] Channel control base address
This field contains the pointer to the base address of the channel control table. The base address must be 1024-byte alligned.</description>
              <bitWidth>22</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>Reserved10</name>
              <description>[9:0] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>10</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ALTBASE</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>DMA alternate channel control base pointer
The ALTBASE register returns the base address of the alternate channel control data. This register removes the necessity for application software to calculate the base address of the alternate channel control structures. This register cannot be read when the uDMA controller is in the reset state.</description>
          <fields>
            <field>
              <name>ADDR</name>
              <description>[31:0] Alternate channel address pointer
This field provides the base address of the alternate channel control structures.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>WAITSTAT</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>DMA channel wait-on-request status
This read-only register indicates that the uDMA channel is waiting on a request. A peripheral can hold off the uDMA from performing a single request until the peripheral is ready for a burst request to enhance the uDMA performance. The use of this feature is dependent on the design of the peripheral and is not controllable by software in any way. This register cannot be read when the uDMA controller is in the reset state.</description>
          <fields>
            <field>
              <name>WAITREQ</name>
              <description>[31:0] Channel [n] wait status
These bits provide the tchannel wait-on-request status. Bit 0 corresponds to channel 0.
1: The corresponding channel is waiting on a request.
0: The corresponding channel is not waiting on a request.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SWREQ</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>DMA channel software request
Each bit of the SWREQ register represents the corresponding uDMA channel. Setting a bit generates a request for the specified uDMA channel.</description>
          <fields>
            <field>
              <name>SWREQ</name>
              <description>[31:0] Channel [n] software request
These bits generate software requests. Bit 0 corresponds to channel 0.
1: Generate a software request for the corresponding channel
0: No request generated
These bits are automatically cleared when the software request has been completed.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>USEBURSTSET</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>DMA channel useburst set
Each bit of the USEBURSTSET register represents the corresponding uDMA channel. Setting a bit disables the channel single request input from generating requests, configuring the channel to only accept burst requests. Reading the register returns the status of USEBURST.
If the amount of data to transfer is a multiple of the arbitration (burst) size, the corresponding SET[n] bit is cleared after completing the final transfer. If there are fewer items remaining to transfer than the arbitration (burst) size, the uDMA controller automatically clears the corresponding SET[n] bit, allowing the remaining items to transfer using single requests. To resume transfers using burst requests, the corresponding bit must be set again. A bit must not be set if the corresponding peripheral does not support the burst request model.</description>
          <fields>
            <field>
              <name>SET</name>
              <description>[31:0] Channel [n] useburst set
0: uDMA channel [n] responds to single or burst requests.
1: uDMA channel [n] responds only to burst requests.
Bit 0 corresponds to channel 0. This bit is automatically cleared as described above. A bit can also be manually cleared by setting the corresponding CLR[n] bit in the DMAUSEBURSTCLR register.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>USEBURSTCLR</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>DMA channel useburst clear
Each bit of the USEBURSTCLR register represents the corresponding uDMA channel. Setting a bit clears the corresponding SET[n] bit in the USEBURSTSET register.</description>
          <fields>
            <field>
              <name>CLR</name>
              <description>[31:0] Channel [n] useburst clear
0: No effect
1: Setting a bit clears the corresponding SET[n] bit in the DMAUSEBURSTSET register meaning that uDMA channel [n] responds to single and burst requests.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REQMASKSET</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>DMA channel request mask set
Each bit of the REQMASKSET register represents the corresponding uDMA channel. Setting a bit disables uDMA requests for the channel. Reading the register returns the request mask status. When a uDMA channel request is masked, that means the peripheral can no longer request uDMA transfers. The channel can then be used for software-initiated transfers.</description>
          <fields>
            <field>
              <name>SET</name>
              <description>[31:0] Channel [n] request mask set
0: The peripheral associated with channel [n] is enabled to request uDMA transfers
1: The peripheral associated with channel [n] is not able to request uDMA transfers. Channel [n] may be used for software-initiated transfers.
Bit 0 corresponds to channel 0. A bit can only be cleared by setting the corresponding CLR[n] bit in the DMAREQMASKCLR register.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REQMASKCLR</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>DMA channel request mask clear
Each bit of the REQMASKCLR register represents the corresponding uDMA channel. Setting a bit clears the corresponding SET[n] bit in the REQMASKSET register.</description>
          <fields>
            <field>
              <name>CLR</name>
              <description>[31:0] Channel [n] request mask clear
0: No effect
1: Setting a bit clears the corresponding SET[n] bit in the DMAREQMASKSET register meaning that the peripheral associated with channel [n] is enabled to request uDMA transfers.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ENASET</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>DMA channel enable set
Each bit of the ENASET register represents the corresponding uDMA channel. Setting a bit enables the corresponding uDMA channel. Reading the register returns the enable status of the channels. If a channel is enabled but the request mask is set (REQMASKSET), then the channel can be used for software-initiated transfers.</description>
          <fields>
            <field>
              <name>SET</name>
              <description>[31:0] Channel [n] enable set
0: uDMA channel [n] is disabled
1: uDMA channel [n] is enabled
Bit 0 corresponds to channel 0. A bit can only be cleared by setting the corresponding CLR[n] bit in the DMAENACLR register.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ENACLR</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>DMA channel enable clear
Each bit of the ENACLR register represents the corresponding uDMA channel. Setting a bit clears the corresponding SET[n] bit in the ENASET register.</description>
          <fields>
            <field>
              <name>CLR</name>
              <description>[31:0] Channel [n] enable clear
0: No effect
1: Setting a bit clears the corresponding SET[n] bit in the DMAENASET register meaning that channel [n] is disabled for uDMA transfers.
Note: The controller disables a channel when it completes the uDMA cycle.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ALTSET</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>DMA channel primary alternate set
Each bit of the ALTSET register represents the corresponding uDMA channel. Setting a bit configures the uDMA channel to use the alternate control data structure. Reading the register returns the status of which control data structure is in use for the corresponding uDMA channel.</description>
          <fields>
            <field>
              <name>SET</name>
              <description>[31:0] Channel [n] alternate set
0: uDMA channel [n] is using the primary control structure
1: uDMA channel [n] is using the alternate control structure
Bit 0 corresponds to channel 0. A bit can only be cleared by setting the corresponding CLR[n] bit in the DMAALTCLR register.
Note: For Ping-Pong and Scatter-Gather cycle types, the uDMA controller automatically sets these bits to select the alternate channel control data structure.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ALTCLR</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>DMA channel primary alternate clear
Each bit of the ALTCLR register represents the corresponding uDMA channel. Setting a bit clears the corresponding SET[n] bit in the ALTSET register.</description>
          <fields>
            <field>
              <name>CLR</name>
              <description>[31:0] Channel [n] alternate clear
0: No effect
1: Setting a bit clears the corresponding SET[n] bit in the DMAALTSET register meaning that channel [n] is using the primary control structure.
Note: For Ping-Pong and Scatter-Gather cycle types, the uDMA controller automatically sets these bits to select the alternate channel control data structure.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRIOSET</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>DMA channel priority set
Each bit of the PRIOSET register represents the corresponding uDMA channel. Setting a bit configures the uDMA channel to have a high priority level. Reading the register returns the status of the channel priority mask.</description>
          <fields>
            <field>
              <name>SET</name>
              <description>[31:0] Channel [n] priority set
0: uDMA channel [n] is using the default priority level
1: uDMA channel [n] is using a high priority level
Bit 0 corresponds to channel 0. A bit can only be cleared by setting the corresponding CLR[n] bit in the DMAPRIOCLR register.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PRIOCLR</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>DMA channel priority clear
Each bit of the DMAPRIOCLR register represents the corresponding uDMA channel. Setting a bit clears the corresponding SET[n] bit in the PRIOSET register.</description>
          <fields>
            <field>
              <name>CLR</name>
              <description>[31:0] Channel [n] priority clear
0: No effect
1: Setting a bit clears the corresponding SET[n] bit in the DMAPRIOSET register meaning that channel [n] is using the default priority level.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ERRCLR</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>DMA bus error clear
The ERRCLR register is used to read and clear the uDMA bus error status. The error status is set if the uDMA controller encountered a bus error while performing a transfer. If a bus error occurs on a channel, that channel is automatically disabled by the uDMA controller. The other channels are unaffected.</description>
          <fields>
            <field>
              <name>Reserved31</name>
              <description>[31:1] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ERRCLR</name>
              <description>[0:0] uDMA bus error status
0: No bus error is pending
1: A bus error is pending
This bit is cleared by writing 1 to it.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CHASGN</name>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <description>DMA channel assignment
Each bit of the CHASGN register represents the corresponding uDMA channel. Setting a bit selects the secondary channel assignment as specified in the section "Channel Assignments"</description>
          <fields>
            <field>
              <name>CHASGN</name>
              <description>[31:0] Channel [n] assignment select
0: Use the primary channel assignment
1: Use the secondary channel assignment</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CHIS</name>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <description>DMA channel interrupt status
Each bit of the CHIS register represents the corresponding uDMA channel. A bit is set when that uDMA channel causes a completion interrupt. The bits are cleared by writing 1.</description>
          <fields>
            <field>
              <name>CHIS</name>
              <description>[31:0] Channel [n] interrupt status
0: The corresponding uDMA channel has not caused an interrupt.
1: The corresponding uDMA channel has caused an interrupt.
This bit is cleared by writing 1 to it.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CHMAP0</name>
          <addressOffset>0x510</addressOffset>
          <size>32</size>
          <description>DMA channel map select 0
Each 4-bit field of the CHMAP0 register configures the uDMA channel assignment as specified in the uDMA channel assignment table in the "Channel Assignments" section.</description>
          <fields>
            <field>
              <name>CH7SEL</name>
              <description>[31:28] uDMA channel 7 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>CH6SEL</name>
              <description>[27:24] uDMA channel 6 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>CH5SEL</name>
              <description>[23:20] uDMA channel 5 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>CH4SEL</name>
              <description>[19:16] uDMA channel 4 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CH3SEL</name>
              <description>[15:12] uDMA channel 3 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>CH2SEL</name>
              <description>[11:8] uDMA channel 2 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CH1SEL</name>
              <description>[7:4] uDMA channel 1 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>CH0SEL</name>
              <description>[3:0] uDMA channel 0 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CHMAP1</name>
          <addressOffset>0x514</addressOffset>
          <size>32</size>
          <description>DMA channel map select 1
Each 4-bit field of the CHMAP1 register configures the uDMA channel assignment as specified in the uDMA channel assignment table in the "Channel Assignments" section.</description>
          <fields>
            <field>
              <name>CH15SEL</name>
              <description>[31:28] uDMA channel 15 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>CH14SEL</name>
              <description>[27:24] uDMA channel 14 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>CH13SEL</name>
              <description>[23:20] uDMA channel 13 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>CH12SEL</name>
              <description>[19:16] uDMA channel 12 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CH11SEL</name>
              <description>[15:12] uDMA channel 11 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>CH10SEL</name>
              <description>[11:8] uDMA channel 10 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CH9SEL</name>
              <description>[7:4] uDMA channel 9 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>CH8SEL</name>
              <description>[3:0] uDMA channel 8 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CHMAP2</name>
          <addressOffset>0x518</addressOffset>
          <size>32</size>
          <description>DMA channel map select 2
Each 4-bit field of the CHMAP2 register configures the uDMA channel assignment as specified in the uDMA channel assignment table in the "Channel Assignments" section.</description>
          <fields>
            <field>
              <name>CH23SEL</name>
              <description>[31:28] uDMA channel 23 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>CH22SEL</name>
              <description>[27:24] uDMA channel 22 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>CH21SEL</name>
              <description>[23:20] uDMA channel 21 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>CH20SEL</name>
              <description>[19:16] uDMA channel 20 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CH19SEL</name>
              <description>[15:12] uDMA channel 19 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>CH18SEL</name>
              <description>[11:8] uDMA channel 18 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CH17SEL</name>
              <description>[7:4] uDMA channel 17 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>CH16SEL</name>
              <description>[3:0] uDMA channel 16 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CHMAP3</name>
          <addressOffset>0x51c</addressOffset>
          <size>32</size>
          <description>DMA channel map select 3
Each 4-bit field of the CHMAP3 register configures the uDMA channel assignment as specified in the uDMA channel assignment table in the "Channel Assignments" section.</description>
          <fields>
            <field>
              <name>CH31SEL</name>
              <description>[31:28] uDMA channel 31 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>CH30SEL</name>
              <description>[27:24] uDMA channel 30 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>CH29SEL</name>
              <description>[23:20] uDMA channel 29 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>CH28SEL</name>
              <description>[19:16] uDMA channel 28 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CH27SEL</name>
              <description>[15:12] uDMA channel 27 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>CH26SEL</name>
              <description>[11:8] uDMA channel 26 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CH25SEL</name>
              <description>[7:4] uDMA channel 25 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>CH24SEL</name>
              <description>[3:0] uDMA channel 24 source select
See section titled "Channel Assignments" in Micro Direct Memory Access chapter.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>STTEST</name>
      <baseAddress>0x40110000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00000100</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>LPBKGPT</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>GPTIMER Internal loopback</description>
          <fields>
            <field>
              <name>Reserved1</name>
              <description>[31:22] Reserved</description>
              <bitWidth>10</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>LPBK32GPT3</name>
              <description>[21:20] GPTimer3 32-bit RTC loopback modes
00: Normal operation
01: GPT0 GPTimerA PWM connected to GPT3 capture
10: GPT0 capture connected to GPT3 PWM GPTimer A
11: Reserved, defaults to normal operation</description>
              <bitWidth>2</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>LPBK32GPT2</name>
              <description>[19:18] GPTimer2 32-bit RTC loopback modes
00: Normal operation
01: GPT0 Timer A PWM connected to GPT2 capture
10: GPT0 capture connected to GPT2 PWM Timer A
11: Reserved, defaults to normal operation</description>
              <bitWidth>2</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>LPBK32GPT1</name>
              <description>[17:16] GPTimer1 32-bit RTC loopback modes
00: Normal operation
01: GPT0 timerA PWM connected to GPT1 capture
10: GPT0 capture connected to GPT1 PWM Timer A
11: Reserved, defaults to normal operation</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved2</name>
              <description>[15:8] Reserved</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>LPBK16GPT3</name>
              <description>[7:6] GPTimer3 16-bit loopback modes
00: Normal operation
01: Timer A PWM connected to Timer B capture
10: Timer A capture connected to Timer B PWM
11: Reserved, defaults to normal operation</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>LPBK16GPT2</name>
              <description>[5:4] GPTimer2 16-bit loopback modes
00: Normal operation
01: Timer A PWM connected to Timer B capture
10: Timer A capture connected to Timer B PWM
11: Reserved, defaults to normal operation</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>LPBK16GPT1</name>
              <description>[3:2] GPTimer1 16-bit loopback modes
00: Normal operation
01: Timer A PWM connected to Timer B capture
10: Timer A capture connected to Timer B PWM
11: Reserved, defaults to normal operation</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>LPBK16GPT0</name>
              <description>[1:0] GPTimer0 16-bit loopback modes
00: Normal operation
01: Timer A PWM connected to Timer B capture
10: Timer A capture connected to Timer B PWM
11: Reserved, defaults to normal operation</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LPBKUART</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>UART internal loopback</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:1] Reserved</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>LPBKUART</name>
              <description>[0:0] UART0/1 loopback mode
0: Normal operation
1: UART0 TX (RX) connected to UART1 RX (TX)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>LPBKI2C</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>I2C internal loopback</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:1] Reserved</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>LPBKI2C</name>
              <description>[0:0] I2C0 Master/slave loopback mode
0: Normal mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PTME1</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>Peripheral test mode enable 1</description>
          <fields>
            <field>
              <name>Reserved1</name>
              <description>[31:10] Reserved</description>
              <bitWidth>22</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>UART1TME</name>
              <description>[9:9] UART1 test mode enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>UART0TME</name>
              <description>[8:8] UART0 test mode enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved2</name>
              <description>[7:0] Reserved</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>PTME2</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>Peripheral test mode enable 2</description>
          <fields>
            <field>
              <name>Reserved1</name>
              <description>[31:20] Reserved</description>
              <bitWidth>12</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>T3TME</name>
              <description>[19:19] Timer3 test mode enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>MTTME</name>
              <description>[18:18] MacTimer test mode enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>T1TME</name>
              <description>[17:17] Timer1 test mode enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>T0TME</name>
              <description>[16:16] Timer0 test mode enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved2</name>
              <description>[15:1] Reserved</description>
              <bitWidth>15</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>I2C0TME</name>
              <description>[0:0] I2C 0 test mode enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>GPT</name>
          <addressOffset>0xc0</addressOffset>
          <size>32</size>
          <description>GPTIMER override values</description>
          <fields>
            <field>
              <name>Reserved1</name>
              <description>[31:9] Reserved</description>
              <bitWidth>23</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>GPTIDOE</name>
              <description>[8:8] GPTimer increment/decrement override enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>Reserved2</name>
              <description>[7:5] Reserved</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>GPTIDOV</name>
              <description>[4:0] GPTimer increment/decrement override value</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PKA</name>
      <baseAddress>0x44004000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00000100</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>APTR</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>PKA vector A address
During execution of basic PKCP operations, this register is double buffered and can be written with a new value for the next operation; when not written, the value remains intact. During the execution of sequencer-controlled complex operations, this register may not be written and its value is undefined at the conclusion of the operation. The driver software cannot rely on the written value to remain intact.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:11] Set to zero on write, ignore on read</description>
              <bitWidth>21</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>APTR</name>
              <description>[10:0] This register specifies the location of vector A within the PKA RAM. Vectors are identified through the location of their least-significant 32-bit word. Note that bit [0] must be zero to ensure that the vector starts at an 8-byte boundary.</description>
              <bitWidth>11</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>BPTR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>PKA vector B address
During execution of basic PKCP operations, this register is double buffered and can be written with a new value for the next operation; when not written, the value remains intact. During the execution of sequencer-controlled complex operations, this register may not be written and its value is undefined at the conclusion of the operation. The driver software cannot rely on the written value to remain intact.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:11] Set to zero on write, ignore on read</description>
              <bitWidth>21</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>BPTR</name>
              <description>[10:0] This register specifies the location of vector B within the PKA RAM. Vectors are identified through the location of their least-significant 32-bit word. Note that bit [0] must be zero to ensure that the vector starts at an 8-byte boundary.</description>
              <bitWidth>11</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>CPTR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>PKA vector C address
During execution of basic PKCP operations, this register is double buffered and can be written with a new value for the next operation; when not written, the value remains intact. During the execution of sequencer-controlled complex operations, this register may not be written and its value is undefined at the conclusion of the operation. The driver software cannot rely on the written value to remain intact.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:11] Set to zero on write, ignore on read</description>
              <bitWidth>21</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CPTR</name>
              <description>[10:0] This register specifies the location of vector C within the PKA RAM. Vectors are identified through the location of their least-significant 32-bit word. Note that bit [0] must be zero to ensure that the vector starts at an 8-byte boundary.</description>
              <bitWidth>11</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DPTR</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>PKA vector D address
During execution of basic PKCP operations, this register is double buffered and can be written with a new value for the next operation; when not written, the value remains intact. During the execution of sequencer-controlled complex operations, this register may not be written and its value is undefined at the conclusion of the operation. The driver software cannot rely on the written value to remain intact.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:11] Set to zero on write, ignore on read</description>
              <bitWidth>21</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>DPTR</name>
              <description>[10:0] This register specifies the location of vector D within the PKA RAM. Vectors are identified through the location of their least-significant 32-bit word. Note that bit [0] must be zero to ensure that the vector starts at an 8-byte boundary.</description>
              <bitWidth>11</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>ALENGTH</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>PKA vector A length
During execution of basic PKCP operations, this register is double buffered and can be written with a new value for the next operation; when not written, the value remains intact. During the execution of sequencer-controlled complex operations, this register may not be written and its value is undefined at the conclusion of the operation. The driver software cannot rely on the written value to remain intact.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:9] Set to zero on write, ignore on read</description>
              <bitWidth>23</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>ALENGTH</name>
              <description>[8:0] This register specifies the length (in 32-bit words) of Vector A.</description>
              <bitWidth>9</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>BLENGTH</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>PKA vector B length
During execution of basic PKCP operations, this register is double buffered and can be written with a new value for the next operation; when not written, the value remains intact. During the execution of sequencer-controlled complex operations, this register may not be written and its value is undefined at the conclusion of the operation. The driver software cannot rely on the written value to remain intact.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:9] Set to zero on write, ignore on read</description>
              <bitWidth>23</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>BLENGTH</name>
              <description>[8:0] This register specifies the length (in 32-bit words) of Vector B.</description>
              <bitWidth>9</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SHIFT</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>PKA bit shift value
For basic PKCP operations, modifying the contents of this register is made impossible while the operation is being performed. For the ExpMod-variable and ExpMod-CRT operations, this register is used to indicate the number of odd powers to use (directly as a value in the range 1-16). For the ModInv and ECC operations, this register is used to hold a completion code.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:5] Set to zero on write, ignore on read</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>NUM_BITS_TO_SHIFT</name>
              <description>[4:0] This register specifies the number of bits to shift the input vector (in the range 0-31) during a Rshift or Lshift operation.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>FUNCTION</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>PKA function
This register contains the control bits to start basic PKCP as well as complex sequencer operations. The run bit can be used to poll for the completion of the operation. Modifying bits [11:0] is made impossible during the execution of a basic PKCP operation.
During the execution of sequencer-controlled complex operations, this register is modified; the run and stall result bits are set to zero at the conclusion, but other bits are undefined.

Attention: Continuously reading this register to poll the run bit is not allowed when executing complex sequencer operations (the sequencer cannot access the PKCP when this is done). Leave at least one sysclk cycle between poll operations.</description>
          <fields>
            <field>
              <name>Reserved1</name>
              <description>[31:25] Set to zero on write, ignore on read</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>STALL_RESULT</name>
              <description>[24:24] When written with a 1b, updating of the PKA_COMPARE, PKA_MSW and PKA_DIVMSW registers, as well as resetting the run bit is stalled beyond the point that a running operation is actually finished. Use this to allow software enough time to read results from a previous operation when the newly started operation is known to take only a short amount of time. If a result is waiting, the result registers is updated and the run bit is reset in the clock cycle following writing the stall result bit back to 0b. The Stall result function may only be used for basic PKCP operations.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>Reserved2</name>
              <description>[23:16] Set to zero on write, ignore on read</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RUN</name>
              <description>[15:15] The host sets this bit to instruct the PKA module to begin processing the basic PKCP or complex sequencer operation. This bit is reset low automatically when the operation is complete. The complement of this bit is output as interrupts[1].
After a reset, the run bit is always set to 1b. Depending on the option, program ROM or program RAM, the following applies:
Program ROM - The first sequencer instruction sets the bit to 0b. This is done immediately after the hardware reset is released.
Program RAM - The sequencer must set the bit to 0b. As a valid firmware may not have been loaded, the sequencer is held in software reset after the hardware reset is released (the reset bit in PKA_SEQ_CRTL is set to 1b). After the FW image is loaded and the Reset bit is cleared, the sequencer starts to execute the FW. The first instruction clears the run bit.
In both cases a few clock cycles are needed before the first instruction is executed and the run bit state has been propagated.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>SEQUENCER_OPERATIONS</name>
              <description>[14:12] These bits select the complex sequencer operation to perform: 
000b: None 
001b: ExpMod-CRT 
010b: ExpMod-ACT4 (compatible with EIP2315) 
011b: ECC-ADD (if available in firmware, otherwise reserved) 
100b: ExpMod-ACT2 (compatible with EIP2316) 
101b: ECC-MUL (if available in firmware, otherwise reserved) 
110b: ExpMod-variable 
111b: ModInv (if available in firmware, otherwise reserved) 
The encoding of these operations is determined by sequencer firmware.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>COPY</name>
              <description>[11:11] Perform copy operation</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>COMPARE</name>
              <description>[10:10] Perform compare operation</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>MODULO</name>
              <description>[9:9] Perform modulo operation</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DIVIDE</name>
              <description>[8:8] Perform divide operation</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>LSHIFT</name>
              <description>[7:7] Perform left shift operation</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RSHIFT</name>
              <description>[6:6] Perform right shift operation</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SUBTRACT</name>
              <description>[5:5] Perform subtract operation</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>ADD</name>
              <description>[4:4] Perform add operation</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MS_ONE</name>
              <description>[3:3] Loads the location of the Most Significant one bit within the result word indicated in the PKA_MSW register into bits [4:0] of the PKA_DIVMSW register - can only be used with basic PKCP operations, except for Divide, Modulo and Compare.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>Reserved3</name>
              <description>[2:2] Set to zero on write, ignore on read</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>ADDSUB</name>
              <description>[1:1] Perform combined add/subtract operation</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>MULTIPLY</name>
              <description>[0:0] Perform multiply operation</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>COMPARE</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>PKA compare result
This register provides the result of a basic PKCP compare operation. It is updated when the run bit in the PKA_FUNCTION register is reset at the end of that operation.
Status after a complex sequencer operation is unknown</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:3] Ignore on read</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>A_GREATER_THAN_B</name>
              <description>[2:2] Vector_A is greater than Vector_B</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>A_LESS_THAN_B</name>
              <description>[1:1] Vector_A is less than Vector_B</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>A_EQUALS_B</name>
              <description>[0:0] Vector_A is equal to Vector_B</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>MSW</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>PKA most-significant-word of result vector
This register indicates the (word) address in the PKA RAM where the most significant nonzero 32-bit word of the result is stored. Should be ignored for modulo operations. For basic PKCP operations, this register is updated when the run bit in the PKA_FUNCTION register is reset at the end of the operation. For the complex-sequencer controlled operations, updating of the final value matching the actual result is done near the end of the operation; note that the result is only meaningful if no errors were detected and that for ECC operations, the PKA_MSW register will provide information for the x-coordinate of the result point only.</description>
          <fields>
            <field>
              <name>Reserved1</name>
              <description>[31:16] Ignore on read</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESULT_IS_ZERO</name>
              <description>[15:15] The result vector is all zeroes, ignore the address returned in bits [10:0]</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>Reserved2</name>
              <description>[14:11] Ignore on read</description>
              <bitWidth>4</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>MSW_ADDRESS</name>
              <description>[10:0] Address of the most-significant nonzero 32-bit word of the result vector in PKA RAM</description>
              <bitWidth>11</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>DIVMSW</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>PKA most-significant-word of divide remainder
This register indicates the (32-bit word) address in the PKA RAM where the most significant nonzero 32-bit word of the remainder result for the basic divide and modulo operations is stored. Bits [4:0] are loaded with the bit number of the most-significant nonzero bit in the most-significant nonzero word when MS one control bit is set. For divide, modulo, and MS one reporting, this register is updated when the RUN bit in the PKA_FUNCTION register is reset at the end of the operation. For the complex sequencer controlled operations, updating of bits [4:0] of this register with the most-significant bit location of the actual result is done near the end of the operation. The result is meaningful only if no errors were detected and that for ECC operations; the PKA_DIVMSW register provides information for the x-coordinate of the result point only.</description>
          <fields>
            <field>
              <name>Reserved1</name>
              <description>[31:16] Ignore on read</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESULT_IS_ZERO</name>
              <description>[15:15] The result vector is all zeroes, ignore the address returned in bits [10:0]</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>Reserved2</name>
              <description>[14:11] Ignore on read</description>
              <bitWidth>4</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>MSW_ADDRESS</name>
              <description>[10:0] Address of the most significant nonzero 32-bit word of the remainder result vector in PKA RAM</description>
              <bitWidth>11</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SEQ_CTRL</name>
          <addressOffset>0xc8</addressOffset>
          <size>32</size>
          <description>PKA sequencer control and status register
The sequencer is interfaced with the outside world through a single control and status register. With the exception of bit [31], the actual use of bits in the separate sub-fields of this register is determined by the sequencer firmware. This register need only be accessed when the sequencer program is stored in RAM. The reset value of the RESTE bit depends upon the option chosen for sequencer program storage.</description>
          <fields>
            <field>
              <name>RESET</name>
              <description>[31:31] Option program ROM: Reset value = 0. Read/Write, reset value 0b (ZERO). Writing 1b resets the sequencer, write to 0b to restart operations again. As the reset value is 0b, the sequencer will automatically start operations executing from program ROM. This bit should always be written with zero and ignored when reading this register.

Option Program RAM: Reset value =1. Read/Write, reset value 1b (ONE). When 1b, the sequencer is held in a reset state and the PKA_PROGRAM area is accessible for loading the sequencer program (while the PKA_DATA_RAM is inaccessible), write to 0b to (re)start sequencer operations and disable PKA_PROGRAM area accessibility (also enables the PKA_DATA_RAM accesses). Resetting the sequencer (in order to load other firmware) should only be done when the PKA Engine is not performing any operations (i.e. the run bit in the PKA_FUNCTION register should be zero).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>Reserved</name>
              <description>[30:16] Set to zero on write, ignore on read</description>
              <bitWidth>15</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>SEQUENCER_STATUS</name>
              <description>[15:8] These read-only bits can be used by the sequencer to communicate status to the outside world. Bit [8] is also used as sequencer interrupt, with the complement of this bit ORed into the run bit in PKA_FUNCTION. This field should always be written with zeroes and ignored when reading this register.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SW_CONTROL_STATUS</name>
              <description>[7:0] These bits can be used by software to trigger sequencer operations. External logic can set these bits by writing 1b, cannot reset them by writing 0b. The sequencer can reset these bits by writing 0b, cannot set them by writing 1b. Setting the run bit in PKA_FUNCTION together with a nonzero sequencer operations field automatically sets bit [0] here. This field should always be written with zeroes and ignored when reading this register.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>OPTIONS</name>
          <addressOffset>0xf4</addressOffset>
          <size>32</size>
          <description>PKA hardware options register
This register provides the host with a means to determine the hardware configuration implemented in this PKA engine, focused on options that have an effect on software interacting with the module.

Note: (32 x (1st LNME nr. of PEs + 1st LNME FIFO RAM depth - 10)) equals the maximum modulus vector length (in bits) that can be handled by the modular exponentiation and ECC operations executed on a PKA engine that includes an LNME.</description>
          <fields>
            <field>
              <name>FIRST_LNME_FIFO_DEPTH</name>
              <description>[31:24] Number of words in the first LNME's FIFO RAM
Should be ignored if LNME configuration is 0. The contents of this field indicate the actual depth as selected by the LNME FIFO RAM size strap input, fifo_size_sel.
Note: Reset value is undefined</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>Reserved1</name>
              <description>[23:22] Ignore on read</description>
              <bitWidth>2</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>FIRST_LNME_NR_OF_PES</name>
              <description>[21:16] Number of processing elements in the pipeline of the first LNME
Should be ignored if LNME configuration is 0.
Note: Reset value is undefined.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved2</name>
              <description>[15:13] Ignore on read</description>
              <bitWidth>3</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>MMM3A</name>
              <description>[12:12] Reserved for a future functional extension to the LNME
Always 0b</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>INT_MASKING</name>
              <description>[11:11] Value 0b indicates that the main interrupt output (bit [1] of the interrupts output bus) is the direct complement of the run bit in the PKA_CONTROL register, value 1b indicates that interrupt masking logic is present for this output.
Note: Reset value is undefined</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>PROTECTION_OPTION</name>
              <description>[10:8] Value 0 indicates no additional protection against side channel attacks, value 1 indicates the SCAP option, value 3 indicates the PROT option; other values are reserved.
Note: Reset value is undefined</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PROGRAM_RAM</name>
              <description>[7:7] Value 1b indicates sequencer program storage in RAM, value 0b in ROM.
Note: Reset value is undefined</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SEQUENCER_CONFIGURATION</name>
              <description>[6:5] Value 1 indicates a standard sequencer; other values are reserved.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>LNME_CONFIGURATION</name>
              <description>[4:2] Value 0 indicates NO LNME, value 1 indicates one standard LNME (with alpha = 32, beta = 8); other values reserved.
Note: Reset value is undefined</description>
              <bitWidth>3</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PKCP_CONFIGURATION</name>
              <description>[1:0] Value 1 indicates a PKCP with a 16x16 multiplier, value 2 indicates a PKCP with a 32x32 multiplier, other values reserved.
Note: Reset value is undefined.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>SW_REV</name>
          <addressOffset>0xf8</addressOffset>
          <size>32</size>
          <description>PKA firmware revision and capabilities register
This register allows the host access to the internal firmware revision number of the PKA Engine for software driver matching and diagnostic purposes. This register also contains a field that encodes the capabilities of the embedded firmware.
The PKA_SW_REV register is written by the firmware within a few clock cycles after starting up that firmware. The hardware reset value is zero, indicating that the information has not been written yet.</description>
          <fields>
            <field>
              <name>FW_CAPABILITIES</name>
              <description>[31:28] 4-bit binary encoding for the functionality implemented in the firmware. Value 0 indicates basic ModExp with/without CRT. Value 1 adds Modular Inversion, value 2 adds Modular Inversion and ECC operations. Values 3-15 are reserved.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>MAJOR_FW_REVISION</name>
              <description>[27:24] 4-bit binary encoding of the major firmware revision number</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>MINOR_FW_REVISION</name>
              <description>[23:20] 4-bit binary encoding of the minor firmware revision number</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>FW_PATCH_LEVEL</name>
              <description>[19:16] 4-bit binary encoding of the firmware patch level, initial release will carry value zero
Patches are used to remove bugs without changing the functionality or interface of a module.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>Reserved</name>
              <description>[15:0] Ignore on read</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>REVISION</name>
          <addressOffset>0xfc</addressOffset>
          <size>32</size>
          <description>PKA hardware revision register
This register allows the host access to the hardware revision number of the PKA engine for software driver matching and diagnostic purposes. It is always located at the highest address in the access space of the module and contains an encoding of the EIP number (with its complement as signature) for recognition of the hardware module.</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:28] Ignore on read</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>MAJOR_HW_REVISION</name>
              <description>[27:24] 4-bit binary encoding of the major hardware revision number</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>MINOR_HW_REVISION</name>
              <description>[23:20] 4-bit binary encoding of the minor hardware revision number</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>HW_PATCH_LEVEL</name>
              <description>[19:16] 4-bit binary encoding of the hardware patch level, initial release will carry value zero
Patches are used to remove bugs without changing the functionality or interface of a module.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>COMPLEMENT_OF_BASIC_EIP_NUMBER</name>
              <description>[15:8] Bit-by-bit logic complement of bits [7:0], EIP-28 gives 0xE3</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>BASIC_EIP_NUMBER</name>
              <description>[7:0] 8-bit binary encoding of the EIP number, EIP-28 gives 0x1C</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CCTEST</name>
      <baseAddress>0x44010000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x00000100</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Register fields should be considered static unless otherwise noted as dynamic.</description>
      <registers>
        <register>
          <name>IO</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Output strength control</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:1] Reserved (read zero)</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SC</name>
              <description>[0:0] I/O strength control bit
Common to all digital output pads
Should be set when unregulated voltage is below approximately 2.6 V.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>OBSSEL0</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Select output signal on observation output 0</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved (read zero)</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[7:7] Observation output 0 enable control for PC0
0: Observation output disabled
1: Observation output enabled
Note: If enabled, this overwrites the standard GPIO behavior of PC0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SEL</name>
              <description>[6:0] n - obs_sigs[n] output on output 0:
0: rfc_obs_sig0
1: rfc_obs_sig1
2: rfc_obs_sig2
Others: Reserved</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>OBSSEL1</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Select output signal on observation output 1</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved (read zero)</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[7:7] Observation output 1 enable control for PC1
0: Observation output disabled
1: Observation output enabled
Note: If enabled, this overwrites the standard GPIO behavior of PC1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SEL</name>
              <description>[6:0] n - obs_sigs[n] output on output 1:
0: rfc_obs_sig0
1: rfc_obs_sig1
2: rfc_obs_sig2
Others: Reserved</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>OBSSEL2</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Select output signal on observation output 2</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved (read zero)</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[7:7] Observation output 2 enable control for PC2
0: Observation output disabled
1: Observation output enabled
Note: If enabled, this overwrites the standard GPIO behavior of PC2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SEL</name>
              <description>[6:0] n - obs_sigs[n] output on output 2:
0: rfc_obs_sig0
1: rfc_obs_sig1
2: rfc_obs_sig2
Others: Reserved</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>OBSSEL3</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Select output signal on observation output 3</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved (read zero)</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[7:7] Observation output 3 enable control for PC3
0: Observation output disabled
1: Observation output enabled
Note: If enabled, this overwrites the standard GPIO behavior of PC3.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SEL</name>
              <description>[6:0] n - obs_sigs[n] output on output 3:
0: rfc_obs_sig0
1: rfc_obs_sig1
2: rfc_obs_sig2
Others: Reserved</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>OBSSEL4</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Select output signal on observation output 4</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved (read zero)</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[7:7] Observation output 4 enable control for PC4
0: Observation output disabled
1: Observation output enabled
Note: If enabled, this overwrites the standard GPIO behavior of PC4.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SEL</name>
              <description>[6:0] n - obs_sigs[n] output on output 4:
0: rfc_obs_sig0
1: rfc_obs_sig1
2: rfc_obs_sig2
Others: Reserved</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>OBSSEL5</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Select output signal on observation output 5</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved (read zero)</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[7:7] Observation output 5 enable control for PC5
0: Observation output disabled
1: Observation output enabled
Note: If enabled, this overwrites the standard GPIO behavior of PC5.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SEL</name>
              <description>[6:0] n - obs_sigs[n] output on output 5:
0: rfc_obs_sig0
1: rfc_obs_sig1
2: rfc_obs_sig2
Others: Reserved</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>OBSSEL6</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>Select output signal on observation output 6</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved (read zero)</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[7:7] Observation output 6 enable control for PC6
0: Observation output disabled
1: Observation output enabled
Note: If enabled, this overwrites the standard GPIO behavior of PC6.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SEL</name>
              <description>[6:0] n - obs_sigs[n] output on output 6:
0: rfc_obs_sig0
1: rfc_obs_sig1
2: rfc_obs_sig2
Others: Reserved</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>OBSSEL7</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>Select output signal on observation output 7</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:8] Reserved (read zero)</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[7:7] Observation output 7 enable control for PC7
0: Observation output disabled
1: Observation output enabled
Note: If enabled, this overwrites the standard GPIO behavior of PC7.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SEL</name>
              <description>[6:0] n - obs_sigs[n] output on output 7:
0: rfc_obs_sig0
1: rfc_obs_sig1
2: rfc_obs_sig2
Others: Reserved</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>TR0</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Test register 0</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:3] Reserved (read zero)</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>Reserved2</name>
              <description>[2:2] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>ADCTM</name>
              <description>[1:1] Set to 1 to connect the temperature sensor to the SOC_ADC. See also RFCORE_XREG_ATEST register description
to enable the temperature sensor.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>Reserved0</name>
              <description>[0:0] Software should not rely on the value of a reserved bit. To provide compatibility with future products, the value of a reserved bit should be preserved across a read-modify-write operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
        <register>
          <name>USBCTRL</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>USB PHY stand-by control</description>
          <fields>
            <field>
              <name>Reserved</name>
              <description>[31:1] Reserved (read zero)</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>USB_STB</name>
              <description>[0:0] USB PHY stand-by override bit
When this bit is cleared to 0 (default state) the USB module cannot change the stand-by mode of the PHY (USB pads) and the PHY is forced out of stand-by mode. This bit must be 1 as well as the stand-by control from the USB controller, before the mode of the PHY is stand-by.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0</resetValue>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>